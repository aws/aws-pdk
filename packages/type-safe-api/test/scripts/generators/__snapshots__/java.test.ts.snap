// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Java Client Code Generation Script Unit Tests Generates With multiple-tags.yaml 1`] = `
{
  ".github/workflows/maven.yml": "# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven
#
# This file is auto-generated by OpenAPI Generator (https://openapi-generator.tech)

name: Java CI with Maven

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    name: Build Multiple Tags Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [ '8' ]
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK
      uses: actions/setup-java@v2
      with:
        java-version: \${{ matrix.java }}
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --no-transfer-progress --file pom.xml
",
  ".gitignore": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# exclude jar for gradle wrapper
!gradle/wrapper/*.jar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*

# build files
**/target
target
.gradle
build
",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".github/workflows/maven.yml
.gitignore
.openapi-generator-ignore
.travis.yml
README.md
api/openapi.yaml
build.gradle
build.sbt
docs/DefaultApi.md
docs/Tag1Api.md
docs/Tag2Api.md
git_push.sh
gradle.properties
gradle/wrapper/gradle-wrapper.jar
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
pom.xml
settings.gradle
src/main/AndroidManifest.xml
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/api/DefaultApi/Handlers.java
src/main/java/test/test/runtime/api/DefaultApi/OperationConfig.java
src/main/java/test/test/runtime/api/DefaultApi/OperationLookup.java
src/main/java/test/test/runtime/api/DefaultApi/Operations.java
src/main/java/test/test/runtime/api/Tag1Api.java
src/main/java/test/test/runtime/api/Tag2Api.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/test/java/test/test/runtime/api/DefaultApiTest.java
src/test/java/test/test/runtime/api/Tag1ApiTest.java
src/test/java/test/test/runtime/api/Tag2ApiTest.java
",
  ".openapi-generator/VERSION": "6.3.0",
  "README.md": "# com.aws.pdk.test

Multiple Tags Test
- API version: 1.0.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)


*Automatically generated by the [OpenAPI Generator](https://openapi-generator.tech)*


## Requirements

Building the API client library requires:
1. Java 1.8+
2. Maven (3.8.3+)/Gradle (7.2+)

## Installation

To install the API client library to your local Maven repository, simply execute:

\`\`\`shell
mvn clean install
\`\`\`

To deploy it to a remote Maven repository instead, configure the settings of the repository and execute:

\`\`\`shell
mvn clean deploy
\`\`\`

Refer to the [OSSRH Guide](http://central.sonatype.org/pages/ossrh-guide.html) for more information.

### Maven users

Add this dependency to your project's POM:

\`\`\`xml
<dependency>
  <groupId>test</groupId>
  <artifactId>com.aws.pdk.test</artifactId>
  <version>1.0.0</version>
  <scope>compile</scope>
</dependency>
\`\`\`

### Gradle users

Add this dependency to your project's build file:

\`\`\`groovy
  repositories {
    mavenCentral()     // Needed if the 'com.aws.pdk.test' jar has been published to maven central.
    mavenLocal()       // Needed if the 'com.aws.pdk.test' jar has been published to the local maven repo.
  }

  dependencies {
     implementation "test:com.aws.pdk.test:1.0.0"
  }
\`\`\`

### Others

At first generate the JAR by executing:

\`\`\`shell
mvn clean package
\`\`\`

Then manually install the following JARs:

* \`target/com.aws.pdk.test-1.0.0.jar\`
* \`target/lib/*.jar\`

## Getting Started

Please follow the [installation](#installation) instruction and execute the following Java code:

\`\`\`java

// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    try {
      apiInstance.neither()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#neither");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}

\`\`\`

## Documentation for API Endpoints

All URIs are relative to *http://localhost*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**neither**](docs/DefaultApi.md#neither) | **GET** /neither | 
*Tag1Api* | [**both**](docs/Tag1Api.md#both) | **GET** /both | 
*Tag1Api* | [**tag1**](docs/Tag1Api.md#tag1) | **GET** /tag1 | 
*Tag2Api* | [**tag2**](docs/Tag2Api.md#tag2) | **GET** /tag2 | 


## Documentation for Models



## Documentation for Authorization

All endpoints do not require authorization.
Authentication schemes defined for the API:

## Recommendation

It's recommended to create an instance of \`ApiClient\` per thread in a multithreaded environment to avoid any potential issues.

## Author



",
  "api/openapi.yaml": "openapi: 3.0.3
info:
  title: Multiple Tags Test
  version: 1.0.0
servers:
- url: /
paths:
  /tag1:
    get:
      operationId: tag1
      responses:
        "200":
          description: Ok
      tags:
      - tag1
      x-accepts: application/json
  /tag2:
    get:
      operationId: tag2
      responses:
        "200":
          description: Ok
      tags:
      - tag2
      x-accepts: application/json
  /both:
    get:
      operationId: both
      responses:
        "200":
          description: Ok
      tags:
      - tag1
      x-accepts: application/json
  /neither:
    get:
      operationId: neither
      responses:
        "200":
          description: Ok
      x-accepts: application/json
components:
  schemas: {}

",
  "docs/DefaultApi.md": "# DefaultApi

All URIs are relative to *http://localhost*

| Method | HTTP request | Description |
|------------- | ------------- | -------------|
| [**neither**](DefaultApi.md#neither) | **GET** /neither |  |


<a name="neither"></a>
# **neither**
> neither().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    try {
      apiInstance.neither()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#neither");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

null (empty response body)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Ok |  -  |

",
  "docs/Tag1Api.md": "# Tag1Api

All URIs are relative to *http://localhost*

| Method | HTTP request | Description |
|------------- | ------------- | -------------|
| [**both**](Tag1Api.md#both) | **GET** /both |  |
| [**tag1**](Tag1Api.md#tag1) | **GET** /tag1 |  |


<a name="both"></a>
# **both**
> both().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.Tag1Api;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    Tag1Api apiInstance = new Tag1Api(defaultClient);
    try {
      apiInstance.both()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling Tag1Api#both");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

null (empty response body)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Ok |  -  |

<a name="tag1"></a>
# **tag1**
> tag1().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.Tag1Api;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    Tag1Api apiInstance = new Tag1Api(defaultClient);
    try {
      apiInstance.tag1()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling Tag1Api#tag1");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

null (empty response body)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Ok |  -  |

",
  "docs/Tag2Api.md": "# Tag2Api

All URIs are relative to *http://localhost*

| Method | HTTP request | Description |
|------------- | ------------- | -------------|
| [**tag2**](Tag2Api.md#tag2) | **GET** /tag2 |  |


<a name="tag2"></a>
# **tag2**
> tag2().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.Tag2Api;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    Tag2Api apiInstance = new Tag2Api(defaultClient);
    try {
      apiInstance.tag2()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling Tag2Api#tag2");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

null (empty response body)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Ok |  -  |

",
  "openapitools.json": "{
  "$schema": "node_modules/@openapitools/openapi-generator-cli/config.schema.json",
  "spaces": 2,
  "generator-cli": {
    "version": "6.3.0",
    "storageDir": "~/.open-api-generator-cli"
  },
  "//": "~~ Generated by projen. To modify, edit src/test/java/projenrc.java and run \\"npx projen\\"."
}
",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/1.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder 
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */ 
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;
 
    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers 
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;



import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call neitherCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/neither";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call neitherValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return neitherCall(_callback);

    }


    private ApiResponse<Void> neitherWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = neitherValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call neitherAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = neitherValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIneitherRequest {

        private APIneitherRequest() {
        }

        /**
         * Build call for neither
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return neitherCall(_callback);
        }

        /**
         * Execute neither request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            neitherWithHttpInfo();
        }

        /**
         * Execute neither request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return neitherWithHttpInfo();
        }

        /**
         * Execute neither request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return neitherAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIneitherRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public APIneitherRequest neither() {
        return new APIneitherRequest();
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/Handlers.java": "package test.test.runtime.api;

import test.test.runtime.model.*;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;


import test.test.runtime.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here to ensure that the static Gson instance is always available.
        new JSON();
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    private static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    private static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    private static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    private static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    private static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    /**
     * Represents an HTTP response from an api operation
     */
    public static interface Response {
        /**
         * Returns the response body
         */
        String getBody();
        /**
         * Returns the response status code
         */
        int getStatusCode();
        /**
         * Returns the response headers
         */
        Map<String, String> getHeaders();
    }

    @lombok.experimental.SuperBuilder
    @lombok.AllArgsConstructor
    @lombok.Getter
    public static class ApiResponse implements Response {
        private String body;
        private int statusCode;
        private Map<String, String> headers;
    }

    /**
     * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
     * of the request chain.
     */
    public static interface Interceptor<TInput> {
        /**
         * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
         * remainder of the chain, however you may wish to return an alternative Response.
         */
        Response handle(ChainedRequestInput<TInput> input);
    }

    /**
     * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
     * constructor with no arguments.
     */
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.TYPE)
    public static @interface Interceptors {
        public Class<? extends Interceptor>[] value() default {};
    }

    /**
     * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
     * The lambda handler is always the last method in the chain.
     */
    public static interface HandlerChain<TInput> {
        /**
         * Delegate to the remainder of the handler chain
         */
        Response next(ChainedRequestInput<TInput> input);
    }

    /**
     * Defines the input for a request.
     */
    public static interface RequestInput<TInput> {
        /**
         * The raw event from API Gateway
         */
        APIGatewayProxyRequestEvent getEvent();
        /**
         * Lambda execution context
         */
        Context getContext();
        /**
         * Demarshalled request input
         */
        TInput getInput();
        /**
         * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
         * between interceptors or to the final handler.
         */
        Map<String, Object> getInterceptorContext();
    }

    /**
     * Reqeust input with a handler chain
     */
    public static interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
        /**
         * The chain for handling requests
         */
        HandlerChain<TInput> getChain();
    }

    private static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }

    /**
     * Response for the neither operation
     */
    public static interface NeitherResponse extends Response {}

    /**
     * Response with status code 200 for the neither operation
     */
    public static class Neither200Response implements NeitherResponse {
        private String body;
        private Map<String, String> headers;

        private Neither200Response(final Map<String, String> headers) {
            this.body = "";
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a Neither200Response without a body
         */
        public static Neither200Response of() {
            return new Neither200Response(new HashMap<>());
        }

        /**
         * Create a Neither200Response without a body and headers
         */
        public static Neither200Response of(final Map<String, String> headers) {
            return new Neither200Response(headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the neither operation
     */
    public static class NeitherRequestParameters {

        public NeitherRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the neither operation
     */
    public static class NeitherRequestArrayParameters {

        public NeitherRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the neither operation
     */
    public static class NeitherInput {
        private NeitherRequestParameters requestParameters;
        private NeitherRequestArrayParameters requestArrayParameters;

        public NeitherInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new NeitherRequestParameters(event);
            this.requestArrayParameters = new NeitherRequestArrayParameters(event);
        }

        public NeitherRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public NeitherRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the neither operation, including the raw API Gateway event
     */
    public static class NeitherRequestInput implements RequestInput<NeitherInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private NeitherInput input;

        public NeitherRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final NeitherInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public NeitherInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the neither operation
     */
    public static abstract class Neither implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the neither operation
         */
        public abstract NeitherResponse handle(final NeitherRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<NeitherInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<NeitherInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<NeitherInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<NeitherInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<NeitherInput>() {
                @Override
                public Response next(ChainedRequestInput<NeitherInput> input) {
                    return handle(new NeitherRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<NeitherInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public NeitherInput getInput() {
                    return new NeitherInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the both operation
     */
    public static interface BothResponse extends Response {}

    /**
     * Response with status code 200 for the both operation
     */
    public static class Both200Response implements BothResponse {
        private String body;
        private Map<String, String> headers;

        private Both200Response(final Map<String, String> headers) {
            this.body = "";
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a Both200Response without a body
         */
        public static Both200Response of() {
            return new Both200Response(new HashMap<>());
        }

        /**
         * Create a Both200Response without a body and headers
         */
        public static Both200Response of(final Map<String, String> headers) {
            return new Both200Response(headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the both operation
     */
    public static class BothRequestParameters {

        public BothRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the both operation
     */
    public static class BothRequestArrayParameters {

        public BothRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the both operation
     */
    public static class BothInput {
        private BothRequestParameters requestParameters;
        private BothRequestArrayParameters requestArrayParameters;

        public BothInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new BothRequestParameters(event);
            this.requestArrayParameters = new BothRequestArrayParameters(event);
        }

        public BothRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public BothRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the both operation, including the raw API Gateway event
     */
    public static class BothRequestInput implements RequestInput<BothInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private BothInput input;

        public BothRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final BothInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public BothInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the both operation
     */
    public static abstract class Both implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the both operation
         */
        public abstract BothResponse handle(final BothRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<BothInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<BothInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<BothInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<BothInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<BothInput>() {
                @Override
                public Response next(ChainedRequestInput<BothInput> input) {
                    return handle(new BothRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<BothInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public BothInput getInput() {
                    return new BothInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the tag1 operation
     */
    public static interface Tag1Response extends Response {}

    /**
     * Response with status code 200 for the tag1 operation
     */
    public static class Tag1200Response implements Tag1Response {
        private String body;
        private Map<String, String> headers;

        private Tag1200Response(final Map<String, String> headers) {
            this.body = "";
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a Tag1200Response without a body
         */
        public static Tag1200Response of() {
            return new Tag1200Response(new HashMap<>());
        }

        /**
         * Create a Tag1200Response without a body and headers
         */
        public static Tag1200Response of(final Map<String, String> headers) {
            return new Tag1200Response(headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the tag1 operation
     */
    public static class Tag1RequestParameters {

        public Tag1RequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the tag1 operation
     */
    public static class Tag1RequestArrayParameters {

        public Tag1RequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the tag1 operation
     */
    public static class Tag1Input {
        private Tag1RequestParameters requestParameters;
        private Tag1RequestArrayParameters requestArrayParameters;

        public Tag1Input(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new Tag1RequestParameters(event);
            this.requestArrayParameters = new Tag1RequestArrayParameters(event);
        }

        public Tag1RequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public Tag1RequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the tag1 operation, including the raw API Gateway event
     */
    public static class Tag1RequestInput implements RequestInput<Tag1Input> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private Tag1Input input;

        public Tag1RequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final Tag1Input input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public Tag1Input getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the tag1 operation
     */
    public static abstract class Tag1 implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the tag1 operation
         */
        public abstract Tag1Response handle(final Tag1RequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<Tag1Input>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<Tag1Input>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<Tag1Input>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<Tag1Input>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<Tag1Input>() {
                @Override
                public Response next(ChainedRequestInput<Tag1Input> input) {
                    return handle(new Tag1RequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<Tag1Input>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public Tag1Input getInput() {
                    return new Tag1Input(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the tag2 operation
     */
    public static interface Tag2Response extends Response {}

    /**
     * Response with status code 200 for the tag2 operation
     */
    public static class Tag2200Response implements Tag2Response {
        private String body;
        private Map<String, String> headers;

        private Tag2200Response(final Map<String, String> headers) {
            this.body = "";
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a Tag2200Response without a body
         */
        public static Tag2200Response of() {
            return new Tag2200Response(new HashMap<>());
        }

        /**
         * Create a Tag2200Response without a body and headers
         */
        public static Tag2200Response of(final Map<String, String> headers) {
            return new Tag2200Response(headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the tag2 operation
     */
    public static class Tag2RequestParameters {

        public Tag2RequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the tag2 operation
     */
    public static class Tag2RequestArrayParameters {

        public Tag2RequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the tag2 operation
     */
    public static class Tag2Input {
        private Tag2RequestParameters requestParameters;
        private Tag2RequestArrayParameters requestArrayParameters;

        public Tag2Input(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new Tag2RequestParameters(event);
            this.requestArrayParameters = new Tag2RequestArrayParameters(event);
        }

        public Tag2RequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public Tag2RequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the tag2 operation, including the raw API Gateway event
     */
    public static class Tag2RequestInput implements RequestInput<Tag2Input> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private Tag2Input input;

        public Tag2RequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final Tag2Input input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public Tag2Input getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the tag2 operation
     */
    public static abstract class Tag2 implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the tag2 operation
         */
        public abstract Tag2Response handle(final Tag2RequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<Tag2Input>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<Tag2Input>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<Tag2Input>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<Tag2Input>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<Tag2Input>() {
                @Override
                public Response next(ChainedRequestInput<Tag2Input> input) {
                    return handle(new Tag2RequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<Tag2Input>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public Tag2Input getInput() {
                    return new Tag2Input(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    public static abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        private static final String neitherMethodAndPath = concatMethodAndPath("GET", "/neither");
        private static final String bothMethodAndPath = concatMethodAndPath("GET", "/both");
        private static final String tag1MethodAndPath = concatMethodAndPath("GET", "/tag1");
        private static final String tag2MethodAndPath = concatMethodAndPath("GET", "/tag2");

        private final Neither constructedNeither;
        private final Both constructedBoth;
        private final Tag1 constructedTag1;
        private final Tag2 constructedTag2;

        /**
         * This method must return your implementation of the Neither operation
         */
        public abstract Neither neither();
        /**
         * This method must return your implementation of the Both operation
         */
        public abstract Both both();
        /**
         * This method must return your implementation of the Tag1 operation
         */
        public abstract Tag1 tag1();
        /**
         * This method must return your implementation of the Tag2 operation
         */
        public abstract Tag2 tag2();

        private static enum Route {
            neitherRoute,
            bothRoute,
            tag1Route,
            tag2Route,
        }

        /**
         * Map of method and path to the route to map to
         */
        private final Map<String, Route> routes = new HashMap<>();

        public HandlerRouter() {
            this.routes.put(neitherMethodAndPath, Route.neitherRoute);
            this.routes.put(bothMethodAndPath, Route.bothRoute);
            this.routes.put(tag1MethodAndPath, Route.tag1Route);
            this.routes.put(tag2MethodAndPath, Route.tag2Route);
            // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
            // ie resources created in the constructor remain in memory between invocations.
            // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
            this.constructedNeither = this.neither();
            this.constructedBoth = this.both();
            this.constructedTag1 = this.tag1();
            this.constructedTag2 = this.tag2();
        }

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public <T> List<Interceptor<T>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            String method = event.getRequestContext().getHttpMethod();
            String path = event.getRequestContext().getResourcePath();
            String methodAndPath = concatMethodAndPath(method, path);
            Route route = this.routes.get(methodAndPath);

            switch (route) {
                case neitherRoute:
                    List<Interceptor<NeitherInput>> neitherInterceptors = getAnnotationInterceptors(this.getClass());
                    neitherInterceptors.addAll(this.getInterceptors());
                    return this.constructedNeither.handleRequestWithAdditionalInterceptors(event, context, neitherInterceptors);
                case bothRoute:
                    List<Interceptor<BothInput>> bothInterceptors = getAnnotationInterceptors(this.getClass());
                    bothInterceptors.addAll(this.getInterceptors());
                    return this.constructedBoth.handleRequestWithAdditionalInterceptors(event, context, bothInterceptors);
                case tag1Route:
                    List<Interceptor<Tag1Input>> tag1Interceptors = getAnnotationInterceptors(this.getClass());
                    tag1Interceptors.addAll(this.getInterceptors());
                    return this.constructedTag1.handleRequestWithAdditionalInterceptors(event, context, tag1Interceptors);
                case tag2Route:
                    List<Interceptor<Tag2Input>> tag2Interceptors = getAnnotationInterceptors(this.getClass());
                    tag2Interceptors.addAll(this.getInterceptors());
                    return this.constructedTag2.handleRequestWithAdditionalInterceptors(event, context, tag2Interceptors);
                default:
                    throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
            }
        }
    }
}",
  "src/main/java/test/test/runtime/api/DefaultApi/OperationConfig.java": "package test.test.runtime.api;

import test.test.runtime.model.*;


import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T neither;
    private T both;
    private T tag1;
    private T tag2;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("neither", this.neither);
        map.put("both", this.both);
        map.put("tag1", this.tag1);
        map.put("tag2", this.tag2);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/OperationLookup.java": "package test.test.runtime.api;

import test.test.runtime.model.*;


import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("neither", OperationLookupEntry.builder()
            .path("/neither")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("both", OperationLookupEntry.builder()
            .path("/both")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("tag1", OperationLookupEntry.builder()
            .path("/tag1")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("tag2", OperationLookupEntry.builder()
            .path("/tag2")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/Operations.java": "package test.test.runtime.api;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .neither(value)
                .both(value)
                .tag1(value)
                .tag2(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/api/Tag1Api.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;



import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class Tag1Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public Tag1Api() {
        this(Configuration.getDefaultApiClient());
    }

    public Tag1Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call bothCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/both";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bothValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return bothCall(_callback);

    }


    private ApiResponse<Void> bothWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = bothValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call bothAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = bothValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIbothRequest {

        private APIbothRequest() {
        }

        /**
         * Build call for both
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return bothCall(_callback);
        }

        /**
         * Execute both request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            bothWithHttpInfo();
        }

        /**
         * Execute both request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return bothWithHttpInfo();
        }

        /**
         * Execute both request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return bothAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIbothRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public APIbothRequest both() {
        return new APIbothRequest();
    }
    private okhttp3.Call tag1Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tag1";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tag1ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return tag1Call(_callback);

    }


    private ApiResponse<Void> tag1WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = tag1ValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call tag1Async(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = tag1ValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APItag1Request {

        private APItag1Request() {
        }

        /**
         * Build call for tag1
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return tag1Call(_callback);
        }

        /**
         * Execute tag1 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            tag1WithHttpInfo();
        }

        /**
         * Execute tag1 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return tag1WithHttpInfo();
        }

        /**
         * Execute tag1 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return tag1Async(_callback);
        }
    }

    /**
     * 
     * 
     * @return APItag1Request
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public APItag1Request tag1() {
        return new APItag1Request();
    }
}
",
  "src/main/java/test/test/runtime/api/Tag2Api.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;



import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class Tag2Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public Tag2Api() {
        this(Configuration.getDefaultApiClient());
    }

    public Tag2Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call tag2Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tag2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call tag2ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return tag2Call(_callback);

    }


    private ApiResponse<Void> tag2WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = tag2ValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call tag2Async(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = tag2ValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APItag2Request {

        private APItag2Request() {
        }

        /**
         * Build call for tag2
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return tag2Call(_callback);
        }

        /**
         * Execute tag2 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            tag2WithHttpInfo();
        }

        /**
         * Execute tag2 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return tag2WithHttpInfo();
        }

        /**
         * Execute tag2 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return tag2Async(_callback);
        }
    }

    /**
     * 
     * 
     * @return APItag2Request
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public APItag2Request tag2() {
        return new APItag2Request();
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".github/workflows/maven.yml": "# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven
#
# This file is auto-generated by OpenAPI Generator (https://openapi-generator.tech)

name: Java CI with Maven

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    name: Build Example API
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [ '8' ]
    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK
      uses: actions/setup-java@v2
      with:
        java-version: \${{ matrix.java }}
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --no-transfer-progress --file pom.xml
",
  ".gitignore": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# exclude jar for gradle wrapper
!gradle/wrapper/*.jar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*

# build files
**/target
target
.gradle
build
",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".github/workflows/maven.yml
.gitignore
.openapi-generator-ignore
.travis.yml
README.md
api/openapi.yaml
build.gradle
build.sbt
docs/ApiError.md
docs/DefaultApi.md
docs/MapResponse.md
docs/MapResponseMapPropertyValue.md
docs/TestRequest.md
docs/TestResponse.md
docs/TestResponseMessagesInner.md
git_push.sh
gradle.properties
gradle/wrapper/gradle-wrapper.jar
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
pom.xml
settings.gradle
src/main/AndroidManifest.xml
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/api/DefaultApi/Handlers.java
src/main/java/test/test/runtime/api/DefaultApi/OperationConfig.java
src/main/java/test/test/runtime/api/DefaultApi/OperationLookup.java
src/main/java/test/test/runtime/api/DefaultApi/Operations.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/ApiError.java
src/main/java/test/test/runtime/model/MapResponse.java
src/main/java/test/test/runtime/model/MapResponseMapPropertyValue.java
src/main/java/test/test/runtime/model/TestRequest.java
src/main/java/test/test/runtime/model/TestResponse.java
src/main/java/test/test/runtime/model/TestResponseMessagesInner.java
src/test/java/test/test/runtime/api/DefaultApiTest.java
src/test/java/test/test/runtime/model/ApiErrorTest.java
src/test/java/test/test/runtime/model/MapResponseMapPropertyValueTest.java
src/test/java/test/test/runtime/model/MapResponseTest.java
src/test/java/test/test/runtime/model/TestRequestTest.java
src/test/java/test/test/runtime/model/TestResponseMessagesInnerTest.java
src/test/java/test/test/runtime/model/TestResponseTest.java
",
  ".openapi-generator/VERSION": "6.3.0",
  "README.md": "# com.aws.pdk.test

Example API
- API version: 1.0.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)


*Automatically generated by the [OpenAPI Generator](https://openapi-generator.tech)*


## Requirements

Building the API client library requires:
1. Java 1.8+
2. Maven (3.8.3+)/Gradle (7.2+)

## Installation

To install the API client library to your local Maven repository, simply execute:

\`\`\`shell
mvn clean install
\`\`\`

To deploy it to a remote Maven repository instead, configure the settings of the repository and execute:

\`\`\`shell
mvn clean deploy
\`\`\`

Refer to the [OSSRH Guide](http://central.sonatype.org/pages/ossrh-guide.html) for more information.

### Maven users

Add this dependency to your project's POM:

\`\`\`xml
<dependency>
  <groupId>test</groupId>
  <artifactId>com.aws.pdk.test</artifactId>
  <version>1.0.0</version>
  <scope>compile</scope>
</dependency>
\`\`\`

### Gradle users

Add this dependency to your project's build file:

\`\`\`groovy
  repositories {
    mavenCentral()     // Needed if the 'com.aws.pdk.test' jar has been published to maven central.
    mavenLocal()       // Needed if the 'com.aws.pdk.test' jar has been published to the local maven repo.
  }

  dependencies {
     implementation "test:com.aws.pdk.test:1.0.0"
  }
\`\`\`

### Others

At first generate the JAR by executing:

\`\`\`shell
mvn clean package
\`\`\`

Then manually install the following JARs:

* \`target/com.aws.pdk.test-1.0.0.jar\`
* \`target/lib/*.jar\`

## Getting Started

Please follow the [installation](#installation) instruction and execute the following Java code:

\`\`\`java

// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    Object body = null; // Object | 
    try {
      Object result = apiInstance.anyRequestResponse()
            .body(body)
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#anyRequestResponse");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}

\`\`\`

## Documentation for API Endpoints

All URIs are relative to *http://localhost*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**anyRequestResponse**](docs/DefaultApi.md#anyRequestResponse) | **PUT** /any-request-response | 
*DefaultApi* | [**empty**](docs/DefaultApi.md#empty) | **PUT** /empty-response | 
*DefaultApi* | [**mapResponse**](docs/DefaultApi.md#mapResponse) | **GET** /map-response | 
*DefaultApi* | [**mediaTypes**](docs/DefaultApi.md#mediaTypes) | **POST** /different-media-type | 
*DefaultApi* | [**multipleContentTypes**](docs/DefaultApi.md#multipleContentTypes) | **POST** /multiple-content-types | 
*DefaultApi* | [**operationOne**](docs/DefaultApi.md#operationOne) | **POST** /path/{pathParam} | 
*DefaultApi* | [**withoutOperationIdDelete**](docs/DefaultApi.md#withoutOperationIdDelete) | **DELETE** /without-operation-id | 


## Documentation for Models

 - [ApiError](docs/ApiError.md)
 - [MapResponse](docs/MapResponse.md)
 - [MapResponseMapPropertyValue](docs/MapResponseMapPropertyValue.md)
 - [TestRequest](docs/TestRequest.md)
 - [TestResponse](docs/TestResponse.md)
 - [TestResponseMessagesInner](docs/TestResponseMessagesInner.md)


## Documentation for Authorization

All endpoints do not require authorization.
Authentication schemes defined for the API:

## Recommendation

It's recommended to create an instance of \`ApiClient\` per thread in a multithreaded environment to avoid any potential issues.

## Author



",
  "api/openapi.yaml": "openapi: 3.0.3
info:
  title: Example API
  version: 1.0.0
servers:
- url: /
paths:
  /path/{pathParam}:
    post:
      operationId: operationOne
      parameters:
      - explode: true
        in: query
        name: param1
        required: true
        schema:
          type: string
        style: form
      - explode: true
        in: query
        name: param2
        required: true
        schema:
          items:
            type: string
          type: array
        style: form
      - explode: true
        in: query
        name: param3
        required: true
        schema:
          type: number
        style: form
      - explode: true
        in: query
        name: param4
        required: false
        schema:
          type: string
        style: form
      - explode: false
        in: path
        name: pathParam
        required: true
        schema:
          type: string
        style: simple
      - explode: false
        in: header
        name: x-header-param
        required: true
        schema:
          type: string
        style: simple
      - explode: false
        in: header
        name: x-multi-value-header-param
        required: false
        schema:
          items:
            type: string
          type: array
        style: simple
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TestRequest'
        required: true
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TestResponse'
          description: Successful response
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ApiError'
          description: Error response
      x-content-type: application/json
      x-accepts: application/json
  /without-operation-id:
    delete:
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TestResponse'
          description: Successful response
      x-accepts: application/json
  /empty-response:
    put:
      operationId: empty
      responses:
        "204":
          description: No response body!
      x-accepts: application/json
  /map-response:
    get:
      operationId: mapResponse
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MapResponse'
          description: Successful response
      x-accepts: application/json
  /any-request-response:
    put:
      operationId: anyRequestResponse
      requestBody:
        content:
          application/json:
            schema: {}
      responses:
        "200":
          content:
            application/json:
              schema: {}
          description: Any response
      x-content-type: application/json
      x-accepts: application/json
  /different-media-type:
    post:
      operationId: mediaTypes
      requestBody:
        content:
          application/pdf:
            schema:
              format: binary
              type: string
        required: true
      responses:
        "200":
          content:
            application/x-mpegurl:
              schema:
                type: string
          description: Success
      x-content-type: application/pdf
      x-accepts: application/x-mpegurl
  /multiple-content-types:
    post:
      operationId: multipleContentTypes
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TestRequest'
          application/pdf:
            schema:
              format: binary
              type: string
        required: true
      responses:
        "200":
          content:
            application/json:
              schema:
                type: string
          description: Success
      x-content-type: application/json
      x-accepts: application/json
components:
  schemas:
    ApiError:
      properties:
        errorMessage:
          type: string
      required:
      - errorMessage
      type: object
    TestRequest:
      properties:
        myInput:
          type: number
      type: object
    TestResponse:
      properties:
        messages:
          items:
            $ref: '#/components/schemas/TestResponse_messages_inner'
          type: array
      required:
      - messages
      type: object
    MapResponse:
      properties:
        mapProperty:
          additionalProperties:
            $ref: '#/components/schemas/MapResponse_mapProperty_value'
          type: object
      required:
      - mapProperty
      type: object
    TestResponse_messages_inner:
      properties:
        message:
          type: string
        id:
          type: integer
      required:
      - id
      type: object
    MapResponse_mapProperty_value:
      properties:
        a:
          type: string
        b:
          type: string
      required:
      - a
      type: object

",
  "docs/ApiError.md": "

# ApiError


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**errorMessage** | **String** |  |  |



",
  "docs/DefaultApi.md": "# DefaultApi

All URIs are relative to *http://localhost*

| Method | HTTP request | Description |
|------------- | ------------- | -------------|
| [**anyRequestResponse**](DefaultApi.md#anyRequestResponse) | **PUT** /any-request-response |  |
| [**empty**](DefaultApi.md#empty) | **PUT** /empty-response |  |
| [**mapResponse**](DefaultApi.md#mapResponse) | **GET** /map-response |  |
| [**mediaTypes**](DefaultApi.md#mediaTypes) | **POST** /different-media-type |  |
| [**multipleContentTypes**](DefaultApi.md#multipleContentTypes) | **POST** /multiple-content-types |  |
| [**operationOne**](DefaultApi.md#operationOne) | **POST** /path/{pathParam} |  |
| [**withoutOperationIdDelete**](DefaultApi.md#withoutOperationIdDelete) | **DELETE** /without-operation-id |  |


<a name="anyRequestResponse"></a>
# **anyRequestResponse**
> Object anyRequestResponse().body(body).execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    Object body = null; // Object | 
    try {
      Object result = apiInstance.anyRequestResponse()
            .body(body)
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#anyRequestResponse");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters

| Name | Type | Description  | Notes |
|------------- | ------------- | ------------- | -------------|
| **body** | **Object**|  | [optional] |

### Return type

**Object**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: application/json
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Any response |  -  |

<a name="empty"></a>
# **empty**
> empty().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    try {
      apiInstance.empty()
            .execute();
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#empty");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

null (empty response body)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **204** | No response body! |  -  |

<a name="mapResponse"></a>
# **mapResponse**
> MapResponse mapResponse().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    try {
      MapResponse result = apiInstance.mapResponse()
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#mapResponse");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

[**MapResponse**](MapResponse.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Successful response |  -  |

<a name="mediaTypes"></a>
# **mediaTypes**
> String mediaTypes(body).execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    File body = new File("/path/to/file"); // File | 
    try {
      String result = apiInstance.mediaTypes(body)
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#mediaTypes");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters

| Name | Type | Description  | Notes |
|------------- | ------------- | ------------- | -------------|
| **body** | **File**|  | |

### Return type

**String**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: application/pdf
 - **Accept**: application/x-mpegurl

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Success |  -  |

<a name="multipleContentTypes"></a>
# **multipleContentTypes**
> String multipleContentTypes(testRequest).execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    TestRequest testRequest = new TestRequest(); // TestRequest | 
    try {
      String result = apiInstance.multipleContentTypes(testRequest)
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#multipleContentTypes");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters

| Name | Type | Description  | Notes |
|------------- | ------------- | ------------- | -------------|
| **testRequest** | [**TestRequest**](TestRequest.md)|  | |

### Return type

**String**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: application/json, application/pdf
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Success |  -  |

<a name="operationOne"></a>
# **operationOne**
> TestResponse operationOne(param1, param2, param3, pathParam, xHeaderParam, testRequest).param4(param4).xMultiValueHeaderParam(xMultiValueHeaderParam).execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    String param1 = "param1_example"; // String | 
    List<String> param2 = Arrays.asList(); // List<String> | 
    BigDecimal param3 = new BigDecimal(78); // BigDecimal | 
    String pathParam = "pathParam_example"; // String | 
    String xHeaderParam = "xHeaderParam_example"; // String | 
    TestRequest testRequest = new TestRequest(); // TestRequest | 
    String param4 = "param4_example"; // String | 
    List<String> xMultiValueHeaderParam = Arrays.asList(); // List<String> | 
    try {
      TestResponse result = apiInstance.operationOne(param1, param2, param3, pathParam, xHeaderParam, testRequest)
            .param4(param4)
            .xMultiValueHeaderParam(xMultiValueHeaderParam)
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#operationOne");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters

| Name | Type | Description  | Notes |
|------------- | ------------- | ------------- | -------------|
| **param1** | **String**|  | |
| **param2** | [**List&lt;String&gt;**](String.md)|  | |
| **param3** | **BigDecimal**|  | |
| **pathParam** | **String**|  | |
| **xHeaderParam** | **String**|  | |
| **testRequest** | [**TestRequest**](TestRequest.md)|  | |
| **param4** | **String**|  | [optional] |
| **xMultiValueHeaderParam** | [**List&lt;String&gt;**](String.md)|  | [optional] |

### Return type

[**TestResponse**](TestResponse.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: application/json
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Successful response |  -  |
| **400** | Error response |  -  |

<a name="withoutOperationIdDelete"></a>
# **withoutOperationIdDelete**
> TestResponse withoutOperationIdDelete().execute();



### Example
\`\`\`java
// Import classes:
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.Configuration;
import test.test.runtime.models.*;
import test.test.runtime.api.DefaultApi;

public class Example {
  public static void main(String[] args) {
    ApiClient defaultClient = Configuration.getDefaultApiClient();
    defaultClient.setBasePath("http://localhost");

    DefaultApi apiInstance = new DefaultApi(defaultClient);
    try {
      TestResponse result = apiInstance.withoutOperationIdDelete()
            .execute();
      System.out.println(result);
    } catch (ApiException e) {
      System.err.println("Exception when calling DefaultApi#withoutOperationIdDelete");
      System.err.println("Status code: " + e.getCode());
      System.err.println("Reason: " + e.getResponseBody());
      System.err.println("Response headers: " + e.getResponseHeaders());
      e.printStackTrace();
    }
  }
}
\`\`\`

### Parameters
This endpoint does not need any parameter.

### Return type

[**TestResponse**](TestResponse.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Successful response |  -  |

",
  "docs/MapResponse.md": "

# MapResponse


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**mapProperty** | [**Map&lt;String, MapResponseMapPropertyValue&gt;**](MapResponseMapPropertyValue.md) |  |  |



",
  "docs/MapResponseMapPropertyValue.md": "

# MapResponseMapPropertyValue


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**a** | **String** |  |  |
|**b** | **String** |  |  [optional] |



",
  "docs/TestRequest.md": "

# TestRequest


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**myInput** | **BigDecimal** |  |  [optional] |



",
  "docs/TestResponse.md": "

# TestResponse


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**messages** | [**List&lt;TestResponseMessagesInner&gt;**](TestResponseMessagesInner.md) |  |  |



",
  "docs/TestResponseMessagesInner.md": "

# TestResponseMessagesInner


## Properties

| Name | Type | Description | Notes |
|------------ | ------------- | ------------- | -------------|
|**message** | **String** |  |  [optional] |
|**id** | **Integer** |  |  |



",
  "openapitools.json": "{
  "$schema": "node_modules/@openapitools/openapi-generator-cli/config.schema.json",
  "spaces": 2,
  "generator-cli": {
    "version": "6.3.0",
    "storageDir": "~/.open-api-generator-cli"
  },
  "//": "~~ Generated by projen. To modify, edit src/test/java/projenrc.java and run \\"npx projen\\"."
}
",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/1.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder 
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */ 
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;
 
    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers 
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.ApiError.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.MapResponse.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.MapResponseMapPropertyValue.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestRequest.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestResponse.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestResponseMessagesInner.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import test.test.runtime.model.ApiError;
import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.MapResponse;
import test.test.runtime.model.TestRequest;
import test.test.runtime.model.TestResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call anyRequestResponseCall(Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/any-request-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call anyRequestResponseValidateBeforeCall(Object body, final ApiCallback _callback) throws ApiException {
        return anyRequestResponseCall(body, _callback);

    }


    private ApiResponse<Object> anyRequestResponseWithHttpInfo(Object body) throws ApiException {
        okhttp3.Call localVarCall = anyRequestResponseValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call anyRequestResponseAsync(Object body, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = anyRequestResponseValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIanyRequestResponseRequest {
        private Object body;

        private APIanyRequestResponseRequest() {
        }

        /**
         * Set body
         * @param body  (optional)
         * @return APIanyRequestResponseRequest
         */
        public APIanyRequestResponseRequest body(Object body) {
            this.body = body;
            return this;
        }

        /**
         * Build call for anyRequestResponse
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return anyRequestResponseCall(body, _callback);
        }

        /**
         * Execute anyRequestResponse request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = anyRequestResponseWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute anyRequestResponse request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return anyRequestResponseWithHttpInfo(body);
        }

        /**
         * Execute anyRequestResponse request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return anyRequestResponseAsync(body, _callback);
        }
    }

    /**
     * 
     * 
     * @return APIanyRequestResponseRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
     </table>
     */
    public APIanyRequestResponseRequest anyRequestResponse() {
        return new APIanyRequestResponseRequest();
    }
    private okhttp3.Call emptyCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/empty-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call emptyValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return emptyCall(_callback);

    }


    private ApiResponse<Void> emptyWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = emptyValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call emptyAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = emptyValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIemptyRequest {

        private APIemptyRequest() {
        }

        /**
         * Build call for empty
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return emptyCall(_callback);
        }

        /**
         * Execute empty request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            emptyWithHttpInfo();
        }

        /**
         * Execute empty request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return emptyWithHttpInfo();
        }

        /**
         * Execute empty request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return emptyAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIemptyRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
     </table>
     */
    public APIemptyRequest empty() {
        return new APIemptyRequest();
    }
    private okhttp3.Call mapResponseCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/map-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call mapResponseValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return mapResponseCall(_callback);

    }


    private ApiResponse<MapResponse> mapResponseWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = mapResponseValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<MapResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call mapResponseAsync(final ApiCallback<MapResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = mapResponseValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<MapResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImapResponseRequest {

        private APImapResponseRequest() {
        }

        /**
         * Build call for mapResponse
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return mapResponseCall(_callback);
        }

        /**
         * Execute mapResponse request
         * @return MapResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public MapResponse execute() throws ApiException {
            ApiResponse<MapResponse> localVarResp = mapResponseWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute mapResponse request with HTTP info returned
         * @return ApiResponse&lt;MapResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MapResponse> executeWithHttpInfo() throws ApiException {
            return mapResponseWithHttpInfo();
        }

        /**
         * Execute mapResponse request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MapResponse> _callback) throws ApiException {
            return mapResponseAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APImapResponseRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public APImapResponseRequest mapResponse() {
        return new APImapResponseRequest();
    }
    private okhttp3.Call mediaTypesCall(File body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/different-media-type";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/x-mpegurl"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/pdf"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call mediaTypesValidateBeforeCall(File body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling mediaTypes(Async)");
        }

        return mediaTypesCall(body, _callback);

    }


    private ApiResponse<String> mediaTypesWithHttpInfo(File body) throws ApiException {
        okhttp3.Call localVarCall = mediaTypesValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call mediaTypesAsync(File body, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = mediaTypesValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImediaTypesRequest {
        private final File body;

        private APImediaTypesRequest(File body) {
            this.body = body;
        }

        /**
         * Build call for mediaTypes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return mediaTypesCall(body, _callback);
        }

        /**
         * Execute mediaTypes request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = mediaTypesWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute mediaTypes request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return mediaTypesWithHttpInfo(body);
        }

        /**
         * Execute mediaTypes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return mediaTypesAsync(body, _callback);
        }
    }

    /**
     * 
     * 
     * @param body  (required)
     * @return APImediaTypesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public APImediaTypesRequest mediaTypes(File body) {
        return new APImediaTypesRequest(body);
    }
    private okhttp3.Call multipleContentTypesCall(TestRequest testRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = testRequest;

        // create path and map variables
        String localVarPath = "/multiple-content-types";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/pdf"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call multipleContentTypesValidateBeforeCall(TestRequest testRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'testRequest' is set
        if (testRequest == null) {
            throw new ApiException("Missing the required parameter 'testRequest' when calling multipleContentTypes(Async)");
        }

        return multipleContentTypesCall(testRequest, _callback);

    }


    private ApiResponse<String> multipleContentTypesWithHttpInfo(TestRequest testRequest) throws ApiException {
        okhttp3.Call localVarCall = multipleContentTypesValidateBeforeCall(testRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call multipleContentTypesAsync(TestRequest testRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = multipleContentTypesValidateBeforeCall(testRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImultipleContentTypesRequest {
        private final TestRequest testRequest;

        private APImultipleContentTypesRequest(TestRequest testRequest) {
            this.testRequest = testRequest;
        }

        /**
         * Build call for multipleContentTypes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return multipleContentTypesCall(testRequest, _callback);
        }

        /**
         * Execute multipleContentTypes request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = multipleContentTypesWithHttpInfo(testRequest);
            return localVarResp.getData();
        }

        /**
         * Execute multipleContentTypes request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return multipleContentTypesWithHttpInfo(testRequest);
        }

        /**
         * Execute multipleContentTypes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return multipleContentTypesAsync(testRequest, _callback);
        }
    }

    /**
     * 
     * 
     * @param testRequest  (required)
     * @return APImultipleContentTypesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public APImultipleContentTypesRequest multipleContentTypes(TestRequest testRequest) {
        return new APImultipleContentTypesRequest(testRequest);
    }
    private okhttp3.Call operationOneCall(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = testRequest;

        // create path and map variables
        String localVarPath = "/path/{pathParam}"
            .replace("{" + "pathParam" + "}", localVarApiClient.escapeString(pathParam.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (param1 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param1", param1));
        }

        if (param2 != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "param2", param2));
        }

        if (param3 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param3", param3));
        }

        if (param4 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param4", param4));
        }

        if (xHeaderParam != null) {
            localVarHeaderParams.put("x-header-param", localVarApiClient.parameterToString(xHeaderParam));
        }

        if (xMultiValueHeaderParam != null) {
            localVarHeaderParams.put("x-multi-value-header-param", localVarApiClient.parameterToString(xMultiValueHeaderParam));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call operationOneValidateBeforeCall(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'param1' is set
        if (param1 == null) {
            throw new ApiException("Missing the required parameter 'param1' when calling operationOne(Async)");
        }

        // verify the required parameter 'param2' is set
        if (param2 == null) {
            throw new ApiException("Missing the required parameter 'param2' when calling operationOne(Async)");
        }

        // verify the required parameter 'param3' is set
        if (param3 == null) {
            throw new ApiException("Missing the required parameter 'param3' when calling operationOne(Async)");
        }

        // verify the required parameter 'pathParam' is set
        if (pathParam == null) {
            throw new ApiException("Missing the required parameter 'pathParam' when calling operationOne(Async)");
        }

        // verify the required parameter 'xHeaderParam' is set
        if (xHeaderParam == null) {
            throw new ApiException("Missing the required parameter 'xHeaderParam' when calling operationOne(Async)");
        }

        // verify the required parameter 'testRequest' is set
        if (testRequest == null) {
            throw new ApiException("Missing the required parameter 'testRequest' when calling operationOne(Async)");
        }

        return operationOneCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);

    }


    private ApiResponse<TestResponse> operationOneWithHttpInfo(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam) throws ApiException {
        okhttp3.Call localVarCall = operationOneValidateBeforeCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, null);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call operationOneAsync(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback<TestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = operationOneValidateBeforeCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIoperationOneRequest {
        private final String param1;
        private final List<String> param2;
        private final BigDecimal param3;
        private final String pathParam;
        private final String xHeaderParam;
        private final TestRequest testRequest;
        private String param4;
        private List<String> xMultiValueHeaderParam;

        private APIoperationOneRequest(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest) {
            this.param1 = param1;
            this.param2 = param2;
            this.param3 = param3;
            this.pathParam = pathParam;
            this.xHeaderParam = xHeaderParam;
            this.testRequest = testRequest;
        }

        /**
         * Set param4
         * @param param4  (optional)
         * @return APIoperationOneRequest
         */
        public APIoperationOneRequest param4(String param4) {
            this.param4 = param4;
            return this;
        }

        /**
         * Set xMultiValueHeaderParam
         * @param xMultiValueHeaderParam  (optional)
         * @return APIoperationOneRequest
         */
        public APIoperationOneRequest xMultiValueHeaderParam(List<String> xMultiValueHeaderParam) {
            this.xMultiValueHeaderParam = xMultiValueHeaderParam;
            return this;
        }

        /**
         * Build call for operationOne
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return operationOneCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        }

        /**
         * Execute operationOne request
         * @return TestResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public TestResponse execute() throws ApiException {
            ApiResponse<TestResponse> localVarResp = operationOneWithHttpInfo(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam);
            return localVarResp.getData();
        }

        /**
         * Execute operationOne request with HTTP info returned
         * @return ApiResponse&lt;TestResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TestResponse> executeWithHttpInfo() throws ApiException {
            return operationOneWithHttpInfo(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam);
        }

        /**
         * Execute operationOne request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TestResponse> _callback) throws ApiException {
            return operationOneAsync(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        }
    }

    /**
     * 
     * 
     * @param param1  (required)
     * @param param2  (required)
     * @param param3  (required)
     * @param pathParam  (required)
     * @param xHeaderParam  (required)
     * @param testRequest  (required)
     * @return APIoperationOneRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
     </table>
     */
    public APIoperationOneRequest operationOne(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest) {
        return new APIoperationOneRequest(param1, param2, param3, pathParam, xHeaderParam, testRequest);
    }
    private okhttp3.Call withoutOperationIdDeleteCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/without-operation-id";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call withoutOperationIdDeleteValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return withoutOperationIdDeleteCall(_callback);

    }


    private ApiResponse<TestResponse> withoutOperationIdDeleteWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = withoutOperationIdDeleteValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call withoutOperationIdDeleteAsync(final ApiCallback<TestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = withoutOperationIdDeleteValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwithoutOperationIdDeleteRequest {

        private APIwithoutOperationIdDeleteRequest() {
        }

        /**
         * Build call for withoutOperationIdDelete
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return withoutOperationIdDeleteCall(_callback);
        }

        /**
         * Execute withoutOperationIdDelete request
         * @return TestResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public TestResponse execute() throws ApiException {
            ApiResponse<TestResponse> localVarResp = withoutOperationIdDeleteWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute withoutOperationIdDelete request with HTTP info returned
         * @return ApiResponse&lt;TestResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TestResponse> executeWithHttpInfo() throws ApiException {
            return withoutOperationIdDeleteWithHttpInfo();
        }

        /**
         * Execute withoutOperationIdDelete request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TestResponse> _callback) throws ApiException {
            return withoutOperationIdDeleteAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIwithoutOperationIdDeleteRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public APIwithoutOperationIdDeleteRequest withoutOperationIdDelete() {
        return new APIwithoutOperationIdDeleteRequest();
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/Handlers.java": "package test.test.runtime.api;

import test.test.runtime.model.*;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.model.ApiError;
import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.MapResponse;
import test.test.runtime.model.TestRequest;
import test.test.runtime.model.TestResponse;

import test.test.runtime.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here to ensure that the static Gson instance is always available.
        new JSON();
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    private static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    private static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    private static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    private static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    private static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    /**
     * Represents an HTTP response from an api operation
     */
    public static interface Response {
        /**
         * Returns the response body
         */
        String getBody();
        /**
         * Returns the response status code
         */
        int getStatusCode();
        /**
         * Returns the response headers
         */
        Map<String, String> getHeaders();
    }

    @lombok.experimental.SuperBuilder
    @lombok.AllArgsConstructor
    @lombok.Getter
    public static class ApiResponse implements Response {
        private String body;
        private int statusCode;
        private Map<String, String> headers;
    }

    /**
     * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
     * of the request chain.
     */
    public static interface Interceptor<TInput> {
        /**
         * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
         * remainder of the chain, however you may wish to return an alternative Response.
         */
        Response handle(ChainedRequestInput<TInput> input);
    }

    /**
     * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
     * constructor with no arguments.
     */
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.TYPE)
    public static @interface Interceptors {
        public Class<? extends Interceptor>[] value() default {};
    }

    /**
     * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
     * The lambda handler is always the last method in the chain.
     */
    public static interface HandlerChain<TInput> {
        /**
         * Delegate to the remainder of the handler chain
         */
        Response next(ChainedRequestInput<TInput> input);
    }

    /**
     * Defines the input for a request.
     */
    public static interface RequestInput<TInput> {
        /**
         * The raw event from API Gateway
         */
        APIGatewayProxyRequestEvent getEvent();
        /**
         * Lambda execution context
         */
        Context getContext();
        /**
         * Demarshalled request input
         */
        TInput getInput();
        /**
         * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
         * between interceptors or to the final handler.
         */
        Map<String, Object> getInterceptorContext();
    }

    /**
     * Reqeust input with a handler chain
     */
    public static interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
        /**
         * The chain for handling requests
         */
        HandlerChain<TInput> getChain();
    }

    private static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }

    /**
     * Response for the anyRequestResponse operation
     */
    public static interface AnyRequestResponseResponse extends Response {}

    /**
     * Response with status code 200 for the anyRequestResponse operation
     */
    public static class AnyRequestResponse200Response implements AnyRequestResponseResponse {
        private String body;
        private Map<String, String> headers;

        private AnyRequestResponse200Response(final String body, final Map<String, String> headers) {
            this.body = body;
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a AnyRequestResponse200Response with a body
         */
        public static AnyRequestResponse200Response of(final String body) {
            return new AnyRequestResponse200Response(body, new HashMap<>());
        }

        /**
         * Create a AnyRequestResponse200Response with a body and headers
         */
        public static AnyRequestResponse200Response of(final String body, final Map<String, String> headers) {
            return new AnyRequestResponse200Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the anyRequestResponse operation
     */
    public static class AnyRequestResponseRequestParameters {

        public AnyRequestResponseRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the anyRequestResponse operation
     */
    public static class AnyRequestResponseRequestArrayParameters {

        public AnyRequestResponseRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the anyRequestResponse operation
     */
    public static class AnyRequestResponseInput {
        private AnyRequestResponseRequestParameters requestParameters;
        private AnyRequestResponseRequestArrayParameters requestArrayParameters;
        private String body;

        public AnyRequestResponseInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new AnyRequestResponseRequestParameters(event);
            this.requestArrayParameters = new AnyRequestResponseRequestArrayParameters(event);
            this.body = event.getBody();
        }

        public AnyRequestResponseRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public AnyRequestResponseRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

        public String getBody() {
            return this.body;
        }
    }

    /**
     * Full request input for the anyRequestResponse operation, including the raw API Gateway event
     */
    public static class AnyRequestResponseRequestInput implements RequestInput<AnyRequestResponseInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private AnyRequestResponseInput input;

        public AnyRequestResponseRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final AnyRequestResponseInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public AnyRequestResponseInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the anyRequestResponse operation
     */
    public static abstract class AnyRequestResponse implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the anyRequestResponse operation
         */
        public abstract AnyRequestResponseResponse handle(final AnyRequestResponseRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<AnyRequestResponseInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<AnyRequestResponseInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<AnyRequestResponseInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<AnyRequestResponseInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<AnyRequestResponseInput>() {
                @Override
                public Response next(ChainedRequestInput<AnyRequestResponseInput> input) {
                    return handle(new AnyRequestResponseRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<AnyRequestResponseInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public AnyRequestResponseInput getInput() {
                    return new AnyRequestResponseInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the empty operation
     */
    public static interface EmptyResponse extends Response {}

    /**
     * Response with status code 204 for the empty operation
     */
    public static class Empty204Response implements EmptyResponse {
        private String body;
        private Map<String, String> headers;

        private Empty204Response(final Map<String, String> headers) {
            this.body = "";
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 204;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a Empty204Response without a body
         */
        public static Empty204Response of() {
            return new Empty204Response(new HashMap<>());
        }

        /**
         * Create a Empty204Response without a body and headers
         */
        public static Empty204Response of(final Map<String, String> headers) {
            return new Empty204Response(headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the empty operation
     */
    public static class EmptyRequestParameters {

        public EmptyRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the empty operation
     */
    public static class EmptyRequestArrayParameters {

        public EmptyRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the empty operation
     */
    public static class EmptyInput {
        private EmptyRequestParameters requestParameters;
        private EmptyRequestArrayParameters requestArrayParameters;

        public EmptyInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new EmptyRequestParameters(event);
            this.requestArrayParameters = new EmptyRequestArrayParameters(event);
        }

        public EmptyRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public EmptyRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the empty operation, including the raw API Gateway event
     */
    public static class EmptyRequestInput implements RequestInput<EmptyInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private EmptyInput input;

        public EmptyRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final EmptyInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public EmptyInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the empty operation
     */
    public static abstract class Empty implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the empty operation
         */
        public abstract EmptyResponse handle(final EmptyRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<EmptyInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<EmptyInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<EmptyInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<EmptyInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<EmptyInput>() {
                @Override
                public Response next(ChainedRequestInput<EmptyInput> input) {
                    return handle(new EmptyRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<EmptyInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public EmptyInput getInput() {
                    return new EmptyInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the mapResponse operation
     */
    public static interface MapResponseResponse extends Response {}

    /**
     * Response with status code 200 for the mapResponse operation
     */
    public static class MapResponse200Response implements MapResponseResponse {
        private String body;
        private Map<String, String> headers;

        private MapResponse200Response(final MapResponse body, final Map<String, String> headers) {
            this.body = body.toJson();
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a MapResponse200Response with a body
         */
        public static MapResponse200Response of(final MapResponse body) {
            return new MapResponse200Response(body, new HashMap<>());
        }

        /**
         * Create a MapResponse200Response with a body and headers
         */
        public static MapResponse200Response of(final MapResponse body, final Map<String, String> headers) {
            return new MapResponse200Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the mapResponse operation
     */
    public static class MapResponseRequestParameters {

        public MapResponseRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the mapResponse operation
     */
    public static class MapResponseRequestArrayParameters {

        public MapResponseRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the mapResponse operation
     */
    public static class MapResponseInput {
        private MapResponseRequestParameters requestParameters;
        private MapResponseRequestArrayParameters requestArrayParameters;

        public MapResponseInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new MapResponseRequestParameters(event);
            this.requestArrayParameters = new MapResponseRequestArrayParameters(event);
        }

        public MapResponseRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public MapResponseRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the mapResponse operation, including the raw API Gateway event
     */
    public static class MapResponseRequestInput implements RequestInput<MapResponseInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private MapResponseInput input;

        public MapResponseRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final MapResponseInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public MapResponseInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the mapResponse operation
     */
    public static abstract class MapResponse implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the mapResponse operation
         */
        public abstract MapResponseResponse handle(final MapResponseRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<MapResponseInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MapResponseInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<MapResponseInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<MapResponseInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<MapResponseInput>() {
                @Override
                public Response next(ChainedRequestInput<MapResponseInput> input) {
                    return handle(new MapResponseRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<MapResponseInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public MapResponseInput getInput() {
                    return new MapResponseInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the mediaTypes operation
     */
    public static interface MediaTypesResponse extends Response {}

    /**
     * Response with status code 200 for the mediaTypes operation
     */
    public static class MediaTypes200Response implements MediaTypesResponse {
        private String body;
        private Map<String, String> headers;

        private MediaTypes200Response(final String body, final Map<String, String> headers) {
            this.body = body;
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a MediaTypes200Response with a body
         */
        public static MediaTypes200Response of(final String body) {
            return new MediaTypes200Response(body, new HashMap<>());
        }

        /**
         * Create a MediaTypes200Response with a body and headers
         */
        public static MediaTypes200Response of(final String body, final Map<String, String> headers) {
            return new MediaTypes200Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the mediaTypes operation
     */
    public static class MediaTypesRequestParameters {

        public MediaTypesRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the mediaTypes operation
     */
    public static class MediaTypesRequestArrayParameters {

        public MediaTypesRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the mediaTypes operation
     */
    public static class MediaTypesInput {
        private MediaTypesRequestParameters requestParameters;
        private MediaTypesRequestArrayParameters requestArrayParameters;
        private String body;

        public MediaTypesInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new MediaTypesRequestParameters(event);
            this.requestArrayParameters = new MediaTypesRequestArrayParameters(event);
            this.body = event.getBody();
        }

        public MediaTypesRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public MediaTypesRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

        public String getBody() {
            return this.body;
        }
    }

    /**
     * Full request input for the mediaTypes operation, including the raw API Gateway event
     */
    public static class MediaTypesRequestInput implements RequestInput<MediaTypesInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private MediaTypesInput input;

        public MediaTypesRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final MediaTypesInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public MediaTypesInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the mediaTypes operation
     */
    public static abstract class MediaTypes implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the mediaTypes operation
         */
        public abstract MediaTypesResponse handle(final MediaTypesRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<MediaTypesInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MediaTypesInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<MediaTypesInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<MediaTypesInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<MediaTypesInput>() {
                @Override
                public Response next(ChainedRequestInput<MediaTypesInput> input) {
                    return handle(new MediaTypesRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<MediaTypesInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public MediaTypesInput getInput() {
                    return new MediaTypesInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the multipleContentTypes operation
     */
    public static interface MultipleContentTypesResponse extends Response {}

    /**
     * Response with status code 200 for the multipleContentTypes operation
     */
    public static class MultipleContentTypes200Response implements MultipleContentTypesResponse {
        private String body;
        private Map<String, String> headers;

        private MultipleContentTypes200Response(final String body, final Map<String, String> headers) {
            this.body = body;
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a MultipleContentTypes200Response with a body
         */
        public static MultipleContentTypes200Response of(final String body) {
            return new MultipleContentTypes200Response(body, new HashMap<>());
        }

        /**
         * Create a MultipleContentTypes200Response with a body and headers
         */
        public static MultipleContentTypes200Response of(final String body, final Map<String, String> headers) {
            return new MultipleContentTypes200Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the multipleContentTypes operation
     */
    public static class MultipleContentTypesRequestParameters {

        public MultipleContentTypesRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the multipleContentTypes operation
     */
    public static class MultipleContentTypesRequestArrayParameters {

        public MultipleContentTypesRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the multipleContentTypes operation
     */
    public static class MultipleContentTypesInput {
        private MultipleContentTypesRequestParameters requestParameters;
        private MultipleContentTypesRequestArrayParameters requestArrayParameters;
        private TestRequest body;

        public MultipleContentTypesInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new MultipleContentTypesRequestParameters(event);
            this.requestArrayParameters = new MultipleContentTypesRequestArrayParameters(event);
            try {
                this.body = TestRequest.fromJson(event.getBody());
            } catch (IOException e) {
                throw new RuntimeException(e);
            };
        }

        public MultipleContentTypesRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public MultipleContentTypesRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

        public TestRequest getBody() {
            return this.body;
        }
    }

    /**
     * Full request input for the multipleContentTypes operation, including the raw API Gateway event
     */
    public static class MultipleContentTypesRequestInput implements RequestInput<MultipleContentTypesInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private MultipleContentTypesInput input;

        public MultipleContentTypesRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final MultipleContentTypesInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public MultipleContentTypesInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the multipleContentTypes operation
     */
    public static abstract class MultipleContentTypes implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the multipleContentTypes operation
         */
        public abstract MultipleContentTypesResponse handle(final MultipleContentTypesRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<MultipleContentTypesInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MultipleContentTypesInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<MultipleContentTypesInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<MultipleContentTypesInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<MultipleContentTypesInput>() {
                @Override
                public Response next(ChainedRequestInput<MultipleContentTypesInput> input) {
                    return handle(new MultipleContentTypesRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<MultipleContentTypesInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public MultipleContentTypesInput getInput() {
                    return new MultipleContentTypesInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the operationOne operation
     */
    public static interface OperationOneResponse extends Response {}

    /**
     * Response with status code 200 for the operationOne operation
     */
    public static class OperationOne200Response implements OperationOneResponse {
        private String body;
        private Map<String, String> headers;

        private OperationOne200Response(final TestResponse body, final Map<String, String> headers) {
            this.body = body.toJson();
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a OperationOne200Response with a body
         */
        public static OperationOne200Response of(final TestResponse body) {
            return new OperationOne200Response(body, new HashMap<>());
        }

        /**
         * Create a OperationOne200Response with a body and headers
         */
        public static OperationOne200Response of(final TestResponse body, final Map<String, String> headers) {
            return new OperationOne200Response(body, headers);
        }
    }

    /**
     * Response with status code 400 for the operationOne operation
     */
    public static class OperationOne400Response implements OperationOneResponse {
        private String body;
        private Map<String, String> headers;

        private OperationOne400Response(final ApiError body, final Map<String, String> headers) {
            this.body = body.toJson();
            this.headers = headers;
            if ("ApiError".endsWith("ResponseContent")) {
                this.headers.put("x-amzn-errortype", "ApiError".substring(0, "ApiError".length() - "ResponseContent".length()));
            }
        }

        @Override
        public int getStatusCode() {
            return 400;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a OperationOne400Response with a body
         */
        public static OperationOne400Response of(final ApiError body) {
            return new OperationOne400Response(body, new HashMap<>());
        }

        /**
         * Create a OperationOne400Response with a body and headers
         */
        public static OperationOne400Response of(final ApiError body, final Map<String, String> headers) {
            return new OperationOne400Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the operationOne operation
     */
    public static class OperationOneRequestParameters {
        private String param1;
        private String param3;
        private String pathParam;
        private String xHeaderParam;
        private Optional<String> param4;

        public OperationOneRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

            this.param1 = decodedParameters.get("param1");
            this.param3 = decodedParameters.get("param3");
            this.pathParam = decodedParameters.get("pathParam");
            this.xHeaderParam = decodedParameters.get("x-header-param");
            this.param4 = Optional.ofNullable(decodedParameters.get("param4"));
        }

        public String getParam1() {
            return this.param1;
        }
        public String getParam3() {
            return this.param3;
        }
        public String getPathParam() {
            return this.pathParam;
        }
        public String getxHeaderParam() {
            return this.xHeaderParam;
        }
        public Optional<String> getParam4() {
            return this.param4;
        }
    }

    /**
     * Multi-value query and header parameters for the operationOne operation
     */
    public static class OperationOneRequestArrayParameters {
        private List<String> param2;
        private Optional<List<String>> xMultiValueHeaderParam;

        public OperationOneRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

            this.param2 = decodedParameters.get("param2");
            this.xMultiValueHeaderParam = Optional.ofNullable(decodedParameters.get("x-multi-value-header-param"));
        }

        public List<String> getParam2() {
            return this.param2;
        }
        public Optional<List<String>> getxMultiValueHeaderParam() {
            return this.xMultiValueHeaderParam;
        }
    }

    /**
     * Input for the operationOne operation
     */
    public static class OperationOneInput {
        private OperationOneRequestParameters requestParameters;
        private OperationOneRequestArrayParameters requestArrayParameters;
        private TestRequest body;

        public OperationOneInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new OperationOneRequestParameters(event);
            this.requestArrayParameters = new OperationOneRequestArrayParameters(event);
            try {
                this.body = TestRequest.fromJson(event.getBody());
            } catch (IOException e) {
                throw new RuntimeException(e);
            };
        }

        public OperationOneRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public OperationOneRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

        public TestRequest getBody() {
            return this.body;
        }
    }

    /**
     * Full request input for the operationOne operation, including the raw API Gateway event
     */
    public static class OperationOneRequestInput implements RequestInput<OperationOneInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private OperationOneInput input;

        public OperationOneRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final OperationOneInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public OperationOneInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the operationOne operation
     */
    public static abstract class OperationOne implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the operationOne operation
         */
        public abstract OperationOneResponse handle(final OperationOneRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<OperationOneInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<OperationOneInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<OperationOneInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<OperationOneInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<OperationOneInput>() {
                @Override
                public Response next(ChainedRequestInput<OperationOneInput> input) {
                    return handle(new OperationOneRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<OperationOneInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public OperationOneInput getInput() {
                    return new OperationOneInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    /**
     * Response for the withoutOperationIdDelete operation
     */
    public static interface WithoutOperationIdDeleteResponse extends Response {}

    /**
     * Response with status code 200 for the withoutOperationIdDelete operation
     */
    public static class WithoutOperationIdDelete200Response implements WithoutOperationIdDeleteResponse {
        private String body;
        private Map<String, String> headers;

        private WithoutOperationIdDelete200Response(final TestResponse body, final Map<String, String> headers) {
            this.body = body.toJson();
            this.headers = headers;
        }

        @Override
        public int getStatusCode() {
            return 200;
        }

        @Override
        public String getBody() {
            return this.body;
        }

        @Override
        public Map<String, String> getHeaders() {
            return this.headers;
        }

        /**
         * Create a WithoutOperationIdDelete200Response with a body
         */
        public static WithoutOperationIdDelete200Response of(final TestResponse body) {
            return new WithoutOperationIdDelete200Response(body, new HashMap<>());
        }

        /**
         * Create a WithoutOperationIdDelete200Response with a body and headers
         */
        public static WithoutOperationIdDelete200Response of(final TestResponse body, final Map<String, String> headers) {
            return new WithoutOperationIdDelete200Response(body, headers);
        }
    }

    /**
     * Single-value query, path and header parameters for the withoutOperationIdDelete operation
     */
    public static class WithoutOperationIdDeleteRequestParameters {

        public WithoutOperationIdDeleteRequestParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, String> parameters = new HashMap<>();
            putAllFromNullableMap(event.getPathParameters(), parameters);
            putAllFromNullableMap(event.getQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getHeaders(), parameters);
            Map<String, String> decodedParameters = decodeRequestParameters(parameters);

        }

    }

    /**
     * Multi-value query and header parameters for the withoutOperationIdDelete operation
     */
    public static class WithoutOperationIdDeleteRequestArrayParameters {

        public WithoutOperationIdDeleteRequestArrayParameters(final APIGatewayProxyRequestEvent event) {
            Map<String, List<String>> parameters = new HashMap<>();
            putAllFromNullableMap(event.getMultiValueQueryStringParameters(), parameters);
            putAllFromNullableMap(event.getMultiValueHeaders(), parameters);
            Map<String, List<String>> decodedParameters = decodeRequestArrayParameters(parameters);

        }

    }

    /**
     * Input for the withoutOperationIdDelete operation
     */
    public static class WithoutOperationIdDeleteInput {
        private WithoutOperationIdDeleteRequestParameters requestParameters;
        private WithoutOperationIdDeleteRequestArrayParameters requestArrayParameters;

        public WithoutOperationIdDeleteInput(final APIGatewayProxyRequestEvent event) {
            this.requestParameters = new WithoutOperationIdDeleteRequestParameters(event);
            this.requestArrayParameters = new WithoutOperationIdDeleteRequestArrayParameters(event);
        }

        public WithoutOperationIdDeleteRequestParameters getRequestParameters() {
            return this.requestParameters;
        }

        public WithoutOperationIdDeleteRequestArrayParameters getRequestArrayParameters() {
            return this.requestArrayParameters;
        }

    }

    /**
     * Full request input for the withoutOperationIdDelete operation, including the raw API Gateway event
     */
    public static class WithoutOperationIdDeleteRequestInput implements RequestInput<WithoutOperationIdDeleteInput> {
        private APIGatewayProxyRequestEvent event;
        private Context context;
        private Map<String, Object> interceptorContext;
        private WithoutOperationIdDeleteInput input;

        public WithoutOperationIdDeleteRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Map<String, Object> interceptorContext, final WithoutOperationIdDeleteInput input) {
            this.event = event;
            this.context = context;
            this.interceptorContext = interceptorContext;
            this.input = input;
        }

        /**
         * Returns the typed request input, with path, query and body parameters
         */
        public WithoutOperationIdDeleteInput getInput() {
            return this.input;
        }

        /**
         * Returns the raw API Gateway event
         */
        public APIGatewayProxyRequestEvent getEvent() {
            return this.event;
        }

        /**
         * Returns the lambda context
         */
        public Context getContext() {
            return this.context;
        }

        /**
         * Returns the interceptor context, which may contain values set by request interceptors
         */
        public Map<String, Object> getInterceptorContext() {
            return this.interceptorContext;
        }
    }

    /**
     * Lambda handler wrapper for the withoutOperationIdDelete operation
     */
    public static abstract class WithoutOperationIdDelete implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        /**
         * Handle the request for the withoutOperationIdDelete operation
         */
        public abstract WithoutOperationIdDeleteResponse handle(final WithoutOperationIdDeleteRequestInput request);

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public List<Interceptor<WithoutOperationIdDeleteInput>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
        }

        public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<WithoutOperationIdDeleteInput>> additionalInterceptors) {
            final Map<String, Object> interceptorContext = new HashMap<>();

            List<Interceptor<WithoutOperationIdDeleteInput>> interceptors = new ArrayList<>();
            interceptors.addAll(additionalInterceptors);

            List<Interceptor<WithoutOperationIdDeleteInput>> annotationInterceptors = getAnnotationInterceptors(this.getClass());

            interceptors.addAll(annotationInterceptors);
            interceptors.addAll(this.getInterceptors());

            final HandlerChain chain = buildHandlerChain(interceptors, new HandlerChain<WithoutOperationIdDeleteInput>() {
                @Override
                public Response next(ChainedRequestInput<WithoutOperationIdDeleteInput> input) {
                    return handle(new WithoutOperationIdDeleteRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
                }
            });

            final Response response = chain.next(new ChainedRequestInput<WithoutOperationIdDeleteInput>() {
                @Override
                public HandlerChain getChain() {
                    // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                    // chain.
                    return null;
                }

                @Override
                public APIGatewayProxyRequestEvent getEvent() {
                    return event;
                }

                @Override
                public Context getContext() {
                    return context;
                }

                @Override
                public WithoutOperationIdDeleteInput getInput() {
                    return new WithoutOperationIdDeleteInput(event);
                }

                @Override
                public Map<String, Object> getInterceptorContext() {
                    return interceptorContext;
                }
            });

            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(response.getStatusCode())
                    .withHeaders(response.getHeaders())
                    .withBody(response.getBody());
        }
    }

    public static abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
        private static final String anyRequestResponseMethodAndPath = concatMethodAndPath("PUT", "/any-request-response");
        private static final String emptyMethodAndPath = concatMethodAndPath("PUT", "/empty-response");
        private static final String mapResponseMethodAndPath = concatMethodAndPath("GET", "/map-response");
        private static final String mediaTypesMethodAndPath = concatMethodAndPath("POST", "/different-media-type");
        private static final String multipleContentTypesMethodAndPath = concatMethodAndPath("POST", "/multiple-content-types");
        private static final String operationOneMethodAndPath = concatMethodAndPath("POST", "/path/{pathParam}");
        private static final String withoutOperationIdDeleteMethodAndPath = concatMethodAndPath("DELETE", "/without-operation-id");

        private final AnyRequestResponse constructedAnyRequestResponse;
        private final Empty constructedEmpty;
        private final MapResponse constructedMapResponse;
        private final MediaTypes constructedMediaTypes;
        private final MultipleContentTypes constructedMultipleContentTypes;
        private final OperationOne constructedOperationOne;
        private final WithoutOperationIdDelete constructedWithoutOperationIdDelete;

        /**
         * This method must return your implementation of the AnyRequestResponse operation
         */
        public abstract AnyRequestResponse anyRequestResponse();
        /**
         * This method must return your implementation of the Empty operation
         */
        public abstract Empty empty();
        /**
         * This method must return your implementation of the MapResponse operation
         */
        public abstract MapResponse mapResponse();
        /**
         * This method must return your implementation of the MediaTypes operation
         */
        public abstract MediaTypes mediaTypes();
        /**
         * This method must return your implementation of the MultipleContentTypes operation
         */
        public abstract MultipleContentTypes multipleContentTypes();
        /**
         * This method must return your implementation of the OperationOne operation
         */
        public abstract OperationOne operationOne();
        /**
         * This method must return your implementation of the WithoutOperationIdDelete operation
         */
        public abstract WithoutOperationIdDelete withoutOperationIdDelete();

        private static enum Route {
            anyRequestResponseRoute,
            emptyRoute,
            mapResponseRoute,
            mediaTypesRoute,
            multipleContentTypesRoute,
            operationOneRoute,
            withoutOperationIdDeleteRoute,
        }

        /**
         * Map of method and path to the route to map to
         */
        private final Map<String, Route> routes = new HashMap<>();

        public HandlerRouter() {
            this.routes.put(anyRequestResponseMethodAndPath, Route.anyRequestResponseRoute);
            this.routes.put(emptyMethodAndPath, Route.emptyRoute);
            this.routes.put(mapResponseMethodAndPath, Route.mapResponseRoute);
            this.routes.put(mediaTypesMethodAndPath, Route.mediaTypesRoute);
            this.routes.put(multipleContentTypesMethodAndPath, Route.multipleContentTypesRoute);
            this.routes.put(operationOneMethodAndPath, Route.operationOneRoute);
            this.routes.put(withoutOperationIdDeleteMethodAndPath, Route.withoutOperationIdDeleteRoute);
            // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
            // ie resources created in the constructor remain in memory between invocations.
            // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
            this.constructedAnyRequestResponse = this.anyRequestResponse();
            this.constructedEmpty = this.empty();
            this.constructedMapResponse = this.mapResponse();
            this.constructedMediaTypes = this.mediaTypes();
            this.constructedMultipleContentTypes = this.multipleContentTypes();
            this.constructedOperationOne = this.operationOne();
            this.constructedWithoutOperationIdDelete = this.withoutOperationIdDelete();
        }

        /**
         * For more complex interceptors that require instantiation with parameters, you may override this method to
         * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
         * prefer the @Interceptors annotation.
         */
        public <T> List<Interceptor<T>> getInterceptors() {
            return Collections.emptyList();
        }

        @Override
        public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
            String method = event.getRequestContext().getHttpMethod();
            String path = event.getRequestContext().getResourcePath();
            String methodAndPath = concatMethodAndPath(method, path);
            Route route = this.routes.get(methodAndPath);

            switch (route) {
                case anyRequestResponseRoute:
                    List<Interceptor<AnyRequestResponseInput>> anyRequestResponseInterceptors = getAnnotationInterceptors(this.getClass());
                    anyRequestResponseInterceptors.addAll(this.getInterceptors());
                    return this.constructedAnyRequestResponse.handleRequestWithAdditionalInterceptors(event, context, anyRequestResponseInterceptors);
                case emptyRoute:
                    List<Interceptor<EmptyInput>> emptyInterceptors = getAnnotationInterceptors(this.getClass());
                    emptyInterceptors.addAll(this.getInterceptors());
                    return this.constructedEmpty.handleRequestWithAdditionalInterceptors(event, context, emptyInterceptors);
                case mapResponseRoute:
                    List<Interceptor<MapResponseInput>> mapResponseInterceptors = getAnnotationInterceptors(this.getClass());
                    mapResponseInterceptors.addAll(this.getInterceptors());
                    return this.constructedMapResponse.handleRequestWithAdditionalInterceptors(event, context, mapResponseInterceptors);
                case mediaTypesRoute:
                    List<Interceptor<MediaTypesInput>> mediaTypesInterceptors = getAnnotationInterceptors(this.getClass());
                    mediaTypesInterceptors.addAll(this.getInterceptors());
                    return this.constructedMediaTypes.handleRequestWithAdditionalInterceptors(event, context, mediaTypesInterceptors);
                case multipleContentTypesRoute:
                    List<Interceptor<MultipleContentTypesInput>> multipleContentTypesInterceptors = getAnnotationInterceptors(this.getClass());
                    multipleContentTypesInterceptors.addAll(this.getInterceptors());
                    return this.constructedMultipleContentTypes.handleRequestWithAdditionalInterceptors(event, context, multipleContentTypesInterceptors);
                case operationOneRoute:
                    List<Interceptor<OperationOneInput>> operationOneInterceptors = getAnnotationInterceptors(this.getClass());
                    operationOneInterceptors.addAll(this.getInterceptors());
                    return this.constructedOperationOne.handleRequestWithAdditionalInterceptors(event, context, operationOneInterceptors);
                case withoutOperationIdDeleteRoute:
                    List<Interceptor<WithoutOperationIdDeleteInput>> withoutOperationIdDeleteInterceptors = getAnnotationInterceptors(this.getClass());
                    withoutOperationIdDeleteInterceptors.addAll(this.getInterceptors());
                    return this.constructedWithoutOperationIdDelete.handleRequestWithAdditionalInterceptors(event, context, withoutOperationIdDeleteInterceptors);
                default:
                    throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
            }
        }
    }
}",
  "src/main/java/test/test/runtime/api/DefaultApi/OperationConfig.java": "package test.test.runtime.api;

import test.test.runtime.model.*;

import test.test.runtime.model.ApiError;
import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.MapResponse;
import test.test.runtime.model.TestRequest;
import test.test.runtime.model.TestResponse;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T anyRequestResponse;
    private T empty;
    private T mapResponse;
    private T mediaTypes;
    private T multipleContentTypes;
    private T operationOne;
    private T withoutOperationIdDelete;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("anyRequestResponse", this.anyRequestResponse);
        map.put("empty", this.empty);
        map.put("mapResponse", this.mapResponse);
        map.put("mediaTypes", this.mediaTypes);
        map.put("multipleContentTypes", this.multipleContentTypes);
        map.put("operationOne", this.operationOne);
        map.put("withoutOperationIdDelete", this.withoutOperationIdDelete);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/OperationLookup.java": "package test.test.runtime.api;

import test.test.runtime.model.*;

import test.test.runtime.model.ApiError;
import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.MapResponse;
import test.test.runtime.model.TestRequest;
import test.test.runtime.model.TestResponse;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("anyRequestResponse", OperationLookupEntry.builder()
            .path("/any-request-response")
            .method("PUT")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("empty", OperationLookupEntry.builder()
            .path("/empty-response")
            .method("PUT")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("mapResponse", OperationLookupEntry.builder()
            .path("/map-response")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("mediaTypes", OperationLookupEntry.builder()
            .path("/different-media-type")
            .method("POST")
            .contentTypes(Arrays.asList("application/pdf"))
            .build());
        config.put("multipleContentTypes", OperationLookupEntry.builder()
            .path("/multiple-content-types")
            .method("POST")
            .contentTypes(Arrays.asList("application/json","application/pdf"))
            .build());
        config.put("operationOne", OperationLookupEntry.builder()
            .path("/path/{pathParam}")
            .method("POST")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("withoutOperationIdDelete", OperationLookupEntry.builder()
            .path("/without-operation-id")
            .method("DELETE")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi/Operations.java": "package test.test.runtime.api;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .anyRequestResponse(value)
                .empty(value)
                .mapResponse(value)
                .mediaTypes(value)
                .multipleContentTypes(value)
                .operationOne(value)
                .withoutOperationIdDelete(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/ApiError.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * ApiError
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiError {
  public static final String SERIALIZED_NAME_ERROR_MESSAGE = "errorMessage";
  @SerializedName(SERIALIZED_NAME_ERROR_MESSAGE)
  private String errorMessage;

  public ApiError() {
  }

  public ApiError errorMessage(String errorMessage) {
    
    this.errorMessage = errorMessage;
    return this;
  }

   /**
   * Get errorMessage
   * @return errorMessage
  **/
  @javax.annotation.Nonnull

  public String getErrorMessage() {
    return errorMessage;
  }


  public void setErrorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiError apiError = (ApiError) o;
    return Objects.equals(this.errorMessage, apiError.errorMessage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(errorMessage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiError {\\n");
    sb.append("    errorMessage: ").append(toIndentedString(errorMessage)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("errorMessage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("errorMessage");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ApiError
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ApiError.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApiError is not found in the empty JSON string", ApiError.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ApiError.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`ApiError\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ApiError.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("errorMessage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`errorMessage\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("errorMessage").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApiError.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApiError' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApiError> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApiError.class));

       return (TypeAdapter<T>) new TypeAdapter<ApiError>() {
           @Override
           public void write(JsonWriter out, ApiError value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApiError read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ApiError given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ApiError
  * @throws IOException if the JSON string is invalid with respect to ApiError
  */
  public static ApiError fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiError.class);
  }

 /**
  * Convert an instance of ApiError to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
  "src/main/java/test/test/runtime/model/MapResponse.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import test.test.runtime.model.MapResponseMapPropertyValue;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * MapResponse
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class MapResponse {
  public static final String SERIALIZED_NAME_MAP_PROPERTY = "mapProperty";
  @SerializedName(SERIALIZED_NAME_MAP_PROPERTY)
  private Map<String, MapResponseMapPropertyValue> mapProperty = new HashMap<>();

  public MapResponse() {
  }

  public MapResponse mapProperty(Map<String, MapResponseMapPropertyValue> mapProperty) {
    
    this.mapProperty = mapProperty;
    return this;
  }

  public MapResponse putMapPropertyItem(String key, MapResponseMapPropertyValue mapPropertyItem) {
    this.mapProperty.put(key, mapPropertyItem);
    return this;
  }

   /**
   * Get mapProperty
   * @return mapProperty
  **/
  @javax.annotation.Nonnull

  public Map<String, MapResponseMapPropertyValue> getMapProperty() {
    return mapProperty;
  }


  public void setMapProperty(Map<String, MapResponseMapPropertyValue> mapProperty) {
    this.mapProperty = mapProperty;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MapResponse mapResponse = (MapResponse) o;
    return Objects.equals(this.mapProperty, mapResponse.mapProperty);
  }

  @Override
  public int hashCode() {
    return Objects.hash(mapProperty);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MapResponse {\\n");
    sb.append("    mapProperty: ").append(toIndentedString(mapProperty)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("mapProperty");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("mapProperty");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MapResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MapResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MapResponse is not found in the empty JSON string", MapResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MapResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`MapResponse\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MapResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MapResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MapResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MapResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MapResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<MapResponse>() {
           @Override
           public void write(JsonWriter out, MapResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MapResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MapResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MapResponse
  * @throws IOException if the JSON string is invalid with respect to MapResponse
  */
  public static MapResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MapResponse.class);
  }

 /**
  * Convert an instance of MapResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
  "src/main/java/test/test/runtime/model/MapResponseMapPropertyValue.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * MapResponseMapPropertyValue
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class MapResponseMapPropertyValue {
  public static final String SERIALIZED_NAME_A = "a";
  @SerializedName(SERIALIZED_NAME_A)
  private String a;

  public static final String SERIALIZED_NAME_B = "b";
  @SerializedName(SERIALIZED_NAME_B)
  private String b;

  public MapResponseMapPropertyValue() {
  }

  public MapResponseMapPropertyValue a(String a) {
    
    this.a = a;
    return this;
  }

   /**
   * Get a
   * @return a
  **/
  @javax.annotation.Nonnull

  public String getA() {
    return a;
  }


  public void setA(String a) {
    this.a = a;
  }


  public MapResponseMapPropertyValue b(String b) {
    
    this.b = b;
    return this;
  }

   /**
   * Get b
   * @return b
  **/
  @javax.annotation.Nullable

  public String getB() {
    return b;
  }


  public void setB(String b) {
    this.b = b;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MapResponseMapPropertyValue mapResponseMapPropertyValue = (MapResponseMapPropertyValue) o;
    return Objects.equals(this.a, mapResponseMapPropertyValue.a) &&
        Objects.equals(this.b, mapResponseMapPropertyValue.b);
  }

  @Override
  public int hashCode() {
    return Objects.hash(a, b);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MapResponseMapPropertyValue {\\n");
    sb.append("    a: ").append(toIndentedString(a)).append("\\n");
    sb.append("    b: ").append(toIndentedString(b)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("a");
    openapiFields.add("b");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("a");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MapResponseMapPropertyValue
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MapResponseMapPropertyValue.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MapResponseMapPropertyValue is not found in the empty JSON string", MapResponseMapPropertyValue.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MapResponseMapPropertyValue.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`MapResponseMapPropertyValue\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MapResponseMapPropertyValue.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("a").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`a\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("a").toString()));
      }
      if ((jsonObj.get("b") != null && !jsonObj.get("b").isJsonNull()) && !jsonObj.get("b").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`b\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("b").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MapResponseMapPropertyValue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MapResponseMapPropertyValue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MapResponseMapPropertyValue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MapResponseMapPropertyValue.class));

       return (TypeAdapter<T>) new TypeAdapter<MapResponseMapPropertyValue>() {
           @Override
           public void write(JsonWriter out, MapResponseMapPropertyValue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MapResponseMapPropertyValue read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MapResponseMapPropertyValue given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MapResponseMapPropertyValue
  * @throws IOException if the JSON string is invalid with respect to MapResponseMapPropertyValue
  */
  public static MapResponseMapPropertyValue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MapResponseMapPropertyValue.class);
  }

 /**
  * Convert an instance of MapResponseMapPropertyValue to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
  "src/main/java/test/test/runtime/model/TestRequest.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * TestRequest
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class TestRequest {
  public static final String SERIALIZED_NAME_MY_INPUT = "myInput";
  @SerializedName(SERIALIZED_NAME_MY_INPUT)
  private BigDecimal myInput;

  public TestRequest() {
  }

  public TestRequest myInput(BigDecimal myInput) {
    
    this.myInput = myInput;
    return this;
  }

   /**
   * Get myInput
   * @return myInput
  **/
  @javax.annotation.Nullable

  public BigDecimal getMyInput() {
    return myInput;
  }


  public void setMyInput(BigDecimal myInput) {
    this.myInput = myInput;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestRequest testRequest = (TestRequest) o;
    return Objects.equals(this.myInput, testRequest.myInput);
  }

  @Override
  public int hashCode() {
    return Objects.hash(myInput);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestRequest {\\n");
    sb.append("    myInput: ").append(toIndentedString(myInput)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("myInput");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestRequest is not found in the empty JSON string", TestRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestRequest\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<TestRequest>() {
           @Override
           public void write(JsonWriter out, TestRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestRequest
  * @throws IOException if the JSON string is invalid with respect to TestRequest
  */
  public static TestRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestRequest.class);
  }

 /**
  * Convert an instance of TestRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
  "src/main/java/test/test/runtime/model/TestResponse.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import test.test.runtime.model.TestResponseMessagesInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * TestResponse
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class TestResponse {
  public static final String SERIALIZED_NAME_MESSAGES = "messages";
  @SerializedName(SERIALIZED_NAME_MESSAGES)
  private List<TestResponseMessagesInner> messages = new ArrayList<>();

  public TestResponse() {
  }

  public TestResponse messages(List<TestResponseMessagesInner> messages) {
    
    this.messages = messages;
    return this;
  }

  public TestResponse addMessagesItem(TestResponseMessagesInner messagesItem) {
    this.messages.add(messagesItem);
    return this;
  }

   /**
   * Get messages
   * @return messages
  **/
  @javax.annotation.Nonnull

  public List<TestResponseMessagesInner> getMessages() {
    return messages;
  }


  public void setMessages(List<TestResponseMessagesInner> messages) {
    this.messages = messages;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResponse testResponse = (TestResponse) o;
    return Objects.equals(this.messages, testResponse.messages);
  }

  @Override
  public int hashCode() {
    return Objects.hash(messages);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResponse {\\n");
    sb.append("    messages: ").append(toIndentedString(messages)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("messages");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("messages");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResponse is not found in the empty JSON string", TestResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestResponse\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TestResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("messages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field \`messages\` to be an array in the JSON string but got \`%s\`", jsonObj.get("messages").toString()));
      }

      JsonArray jsonArraymessages = jsonObj.getAsJsonArray("messages");
      // validate the required field \`messages\` (array)
      for (int i = 0; i < jsonArraymessages.size(); i++) {
        TestResponseMessagesInner.validateJsonObject(jsonArraymessages.get(i).getAsJsonObject());
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResponse>() {
           @Override
           public void write(JsonWriter out, TestResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestResponse
  * @throws IOException if the JSON string is invalid with respect to TestResponse
  */
  public static TestResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResponse.class);
  }

 /**
  * Convert an instance of TestResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
  "src/main/java/test/test/runtime/model/TestResponseMessagesInner.java": "/*
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import test.test.runtime.JSON;

/**
 * TestResponseMessagesInner
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class TestResponseMessagesInner {
  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public TestResponseMessagesInner() {
  }

  public TestResponseMessagesInner message(String message) {
    
    this.message = message;
    return this;
  }

   /**
   * Get message
   * @return message
  **/
  @javax.annotation.Nullable

  public String getMessage() {
    return message;
  }


  public void setMessage(String message) {
    this.message = message;
  }


  public TestResponseMessagesInner id(Integer id) {
    
    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull

  public Integer getId() {
    return id;
  }


  public void setId(Integer id) {
    this.id = id;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResponseMessagesInner testResponseMessagesInner = (TestResponseMessagesInner) o;
    return Objects.equals(this.message, testResponseMessagesInner.message) &&
        Objects.equals(this.id, testResponseMessagesInner.id);
  }

  @Override
  public int hashCode() {
    return Objects.hash(message, id);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResponseMessagesInner {\\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("message");
    openapiFields.add("id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestResponseMessagesInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestResponseMessagesInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResponseMessagesInner is not found in the empty JSON string", TestResponseMessagesInner.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestResponseMessagesInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestResponseMessagesInner\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TestResponseMessagesInner.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) && !jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`message\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("message").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResponseMessagesInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResponseMessagesInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResponseMessagesInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResponseMessagesInner.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResponseMessagesInner>() {
           @Override
           public void write(JsonWriter out, TestResponseMessagesInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResponseMessagesInner read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestResponseMessagesInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestResponseMessagesInner
  * @throws IOException if the JSON string is invalid with respect to TestResponseMessagesInner
  */
  public static TestResponseMessagesInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResponseMessagesInner.class);
  }

 /**
  * Convert an instance of TestResponseMessagesInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

",
}
`;
