// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Typescript Client Code Generation Script Unit Tests Generates With multiple-tags.yaml 1`] = `
{
  ".gitignore": "wwwroot/*.js
node_modules
typings
dist
",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".gitignore
.npmignore
.openapi-generator-ignore
README.md
package.json
src/apis/DefaultApi.ts
src/apis/DefaultApi/OperationConfig.ts
src/apis/Tag1Api.ts
src/apis/Tag2Api.ts
src/apis/index.ts
src/index.ts
src/runtime.ts
tsconfig.esm.json
tsconfig.json
",
  ".openapi-generator/VERSION": "6.3.0",
  "README.md": "## test@1.0.0

This generator creates TypeScript/JavaScript client that utilizes [Fetch API](https://fetch.spec.whatwg.org/). The generated Node module can be used in the following environments:

Environment
* Node.js
* Webpack
* Browserify

Language level
* ES5 - you must have a Promises/A+ library installed
* ES6

Module system
* CommonJS
* ES6 module system

It can be used in both TypeScript and JavaScript. In TypeScript, the definition should be automatically resolved via \`package.json\`. ([Reference](http://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html))

### Building

To build and compile the typescript sources to javascript use:
\`\`\`
npm install
npm run build
\`\`\`

### Publishing

First build the package then run \`\`\`npm publish\`\`\`

### Consuming

navigate to the folder of your consuming project and run one of the following commands.

_published:_

\`\`\`
npm install test@1.0.0 --save
\`\`\`

_unPublished (not recommended):_

\`\`\`
npm install PATH_TO_GENERATED_PACKAGE --save
",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async neitherRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/neither\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async neither(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.neitherRaw(initOverrides);
    }

}
",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
} from '../../models';
// Import request parameter interfaces
import {
    
    
    
    
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    neither: T;
    both: T;
    tag1: T;
    tag2: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    neither: {
        path: '/neither',
        method: 'GET',
    },
    both: {
        path: '/both',
        method: 'GET',
    },
    tag1: {
        path: '/tag1',
        method: 'GET',
    },
    tag2: {
        path: '/tag2',
        method: 'GET',
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

type OperationIds = | 'neither' | 'both' | 'tag1' | 'tag2';
type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody> = {
    requestParameters: RequestParameters,
    requestArrayParameters: RequestArrayParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestArrayParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestArrayParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestArrayParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestArrayParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestArrayParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestArrayParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestArrayParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Single-value path/query parameters for Neither
 */
export interface NeitherRequestParameters {
}

/**
 * Multi-value query parameters for Neither
 */
export interface NeitherRequestArrayParameters {
}

/**
 * Request body parameter for Neither
 */
export type NeitherRequestBody = never;

export type Neither200OperationResponse = OperationResponse<200, undefined>;
export type NeitherOperationResponses = | Neither200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type NeitherHandlerFunction = LambdaHandlerFunction<NeitherRequestParameters, NeitherRequestArrayParameters, NeitherRequestBody, NeitherOperationResponses>;
export type NeitherChainedHandlerFunction = ChainedLambdaHandlerFunction<NeitherRequestParameters, NeitherRequestArrayParameters, NeitherRequestBody, NeitherOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of neither
 */
export const neitherHandler = (
    firstHandler: NeitherChainedHandlerFunction,
    ...remainingHandlers: NeitherChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'neither'> => async (event: any, context: any, _callback?: any, additionalInterceptors: NeitherChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as NeitherRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as NeitherRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as NeitherRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for Both
 */
export interface BothRequestParameters {
}

/**
 * Multi-value query parameters for Both
 */
export interface BothRequestArrayParameters {
}

/**
 * Request body parameter for Both
 */
export type BothRequestBody = never;

export type Both200OperationResponse = OperationResponse<200, undefined>;
export type BothOperationResponses = | Both200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type BothHandlerFunction = LambdaHandlerFunction<BothRequestParameters, BothRequestArrayParameters, BothRequestBody, BothOperationResponses>;
export type BothChainedHandlerFunction = ChainedLambdaHandlerFunction<BothRequestParameters, BothRequestArrayParameters, BothRequestBody, BothOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of both
 */
export const bothHandler = (
    firstHandler: BothChainedHandlerFunction,
    ...remainingHandlers: BothChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'both'> => async (event: any, context: any, _callback?: any, additionalInterceptors: BothChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as BothRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as BothRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as BothRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for Tag1
 */
export interface Tag1RequestParameters {
}

/**
 * Multi-value query parameters for Tag1
 */
export interface Tag1RequestArrayParameters {
}

/**
 * Request body parameter for Tag1
 */
export type Tag1RequestBody = never;

export type Tag1200OperationResponse = OperationResponse<200, undefined>;
export type Tag1OperationResponses = | Tag1200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type Tag1HandlerFunction = LambdaHandlerFunction<Tag1RequestParameters, Tag1RequestArrayParameters, Tag1RequestBody, Tag1OperationResponses>;
export type Tag1ChainedHandlerFunction = ChainedLambdaHandlerFunction<Tag1RequestParameters, Tag1RequestArrayParameters, Tag1RequestBody, Tag1OperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of tag1
 */
export const tag1Handler = (
    firstHandler: Tag1ChainedHandlerFunction,
    ...remainingHandlers: Tag1ChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'tag1'> => async (event: any, context: any, _callback?: any, additionalInterceptors: Tag1ChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as Tag1RequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as Tag1RequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as Tag1RequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for Tag2
 */
export interface Tag2RequestParameters {
}

/**
 * Multi-value query parameters for Tag2
 */
export interface Tag2RequestArrayParameters {
}

/**
 * Request body parameter for Tag2
 */
export type Tag2RequestBody = never;

export type Tag2200OperationResponse = OperationResponse<200, undefined>;
export type Tag2OperationResponses = | Tag2200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type Tag2HandlerFunction = LambdaHandlerFunction<Tag2RequestParameters, Tag2RequestArrayParameters, Tag2RequestBody, Tag2OperationResponses>;
export type Tag2ChainedHandlerFunction = ChainedLambdaHandlerFunction<Tag2RequestParameters, Tag2RequestArrayParameters, Tag2RequestBody, Tag2OperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of tag2
 */
export const tag2Handler = (
    firstHandler: Tag2ChainedHandlerFunction,
    ...remainingHandlers: Tag2ChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'tag2'> => async (event: any, context: any, _callback?: any, additionalInterceptors: Tag2ChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as Tag2RequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as Tag2RequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as Tag2RequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly neither: OperationApiGatewayLambdaHandler<'neither'>;
  readonly both: OperationApiGatewayLambdaHandler<'both'>;
  readonly tag1: OperationApiGatewayLambdaHandler<'tag1'>;
  readonly tag2: OperationApiGatewayLambdaHandler<'tag2'>;
}

export type AnyOperationRequestParameters = | NeitherRequestParameters| BothRequestParameters| Tag1RequestParameters| Tag2RequestParameters;
export type AnyOperationRequestArrayParameters = | NeitherRequestArrayParameters| BothRequestArrayParameters| Tag1RequestArrayParameters| Tag2RequestArrayParameters;
export type AnyOperationRequestBodies = | NeitherRequestBody| BothRequestBody| Tag1RequestBody| Tag2RequestBody;
export type AnyOperationResponses = | NeitherOperationResponses| BothOperationResponses| Tag1OperationResponses| Tag2OperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestArrayParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestArrayParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/Tag1Api.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

/**
 * 
 */
export class Tag1Api extends runtime.BaseAPI {

    /**
     */
    async bothRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/both\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async both(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bothRaw(initOverrides);
    }

    /**
     */
    async tag1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/tag1\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async tag1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tag1Raw(initOverrides);
    }

}
",
  "src/apis/Tag2Api.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

/**
 * 
 */
export class Tag2Api extends runtime.BaseAPI {

    /**
     */
    async tag2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/tag2\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async tag2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tag2Raw(initOverrides);
    }

}
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
export * from './Tag1Api';
export * from './Tag2Api';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".gitignore": "wwwroot/*.js
node_modules
typings
dist
",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".gitignore
.npmignore
.openapi-generator-ignore
README.md
package.json
src/apis/DefaultApi.ts
src/apis/DefaultApi/OperationConfig.ts
src/apis/index.ts
src/index.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/index.ts
src/runtime.ts
tsconfig.esm.json
tsconfig.json
",
  ".openapi-generator/VERSION": "6.3.0",
  "README.md": "## test@1.0.0

This generator creates TypeScript/JavaScript client that utilizes [Fetch API](https://fetch.spec.whatwg.org/). The generated Node module can be used in the following environments:

Environment
* Node.js
* Webpack
* Browserify

Language level
* ES5 - you must have a Promises/A+ library installed
* ES6

Module system
* CommonJS
* ES6 module system

It can be used in both TypeScript and JavaScript. In TypeScript, the definition should be automatically resolved via \`package.json\`. ([Reference](http://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html))

### Building

To build and compile the typescript sources to javascript use:
\`\`\`
npm install
npm run build
\`\`\`

### Publishing

First build the package then run \`\`\`npm publish\`\`\`

### Consuming

navigate to the folder of your consuming project and run one of the following commands.

_published:_

\`\`\`
npm install test@1.0.0 --save
\`\`\`

_unPublished (not recommended):_

\`\`\`
npm install PATH_TO_GENERATED_PACKAGE --save
",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  TestRequest,
  TestResponse,
} from '../models';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../models';

export interface AnyRequestResponseRequest {
    body?: any | null;
}

export interface MediaTypesRequest {
    body: Blob;
}

export interface OperationOneRequest {
    param1: string;
    param2: Array<string>;
    param3: number;
    pathParam: string;
    testRequest: TestRequest;
    param4?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async anyRequestResponseRaw(requestParameters: AnyRequestResponseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: \`/any-request-response\`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async anyRequestResponse(requestParameters: AnyRequestResponseRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.anyRequestResponseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async emptyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/empty-response\`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async empty(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.emptyRaw(initOverrides);
    }

    /**
     */
    async mediaTypesRaw(requestParameters: MediaTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling mediaTypes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/pdf';

        const response = await this.request({
            path: \`/different-media-type\`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async mediaTypes(requestParameters: MediaTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.mediaTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async operationOneRaw(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        if (requestParameters.param1 === null || requestParameters.param1 === undefined) {
            throw new runtime.RequiredError('param1','Required parameter requestParameters.param1 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param2 === null || requestParameters.param2 === undefined) {
            throw new runtime.RequiredError('param2','Required parameter requestParameters.param2 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param3 === null || requestParameters.param3 === undefined) {
            throw new runtime.RequiredError('param3','Required parameter requestParameters.param3 was null or undefined when calling operationOne.');
        }

        if (requestParameters.pathParam === null || requestParameters.pathParam === undefined) {
            throw new runtime.RequiredError('pathParam','Required parameter requestParameters.pathParam was null or undefined when calling operationOne.');
        }

        if (requestParameters.testRequest === null || requestParameters.testRequest === undefined) {
            throw new runtime.RequiredError('testRequest','Required parameter requestParameters.testRequest was null or undefined when calling operationOne.');
        }

        const queryParameters: any = {};

        if (requestParameters.param1 !== undefined) {
            queryParameters['param1'] = requestParameters.param1;
        }

        if (requestParameters.param2) {
            queryParameters['param2'] = requestParameters.param2;
        }

        if (requestParameters.param3 !== undefined) {
            queryParameters['param3'] = requestParameters.param3;
        }

        if (requestParameters.param4 !== undefined) {
            queryParameters['param4'] = requestParameters.param4;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: \`/path/{pathParam}\`.replace(\`{\${"pathParam"}}\`, encodeURIComponent(String(requestParameters.pathParam))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestRequestToJSON(requestParameters.testRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     */
    async operationOne(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestResponse> {
        const response = await this.operationOneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async withoutOperationIdDeleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/without-operation-id\`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     */
    async withoutOperationIdDelete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestResponse> {
        const response = await this.withoutOperationIdDeleteRaw(initOverrides);
        return await response.value();
    }

}
",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    AnyRequestResponseRequest,
    
    MediaTypesRequest,
    OperationOneRequest,
    
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    anyRequestResponse: T;
    empty: T;
    mediaTypes: T;
    operationOne: T;
    withoutOperationIdDelete: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    anyRequestResponse: {
        path: '/any-request-response',
        method: 'PUT',
    },
    empty: {
        path: '/empty-response',
        method: 'PUT',
    },
    mediaTypes: {
        path: '/different-media-type',
        method: 'POST',
    },
    operationOne: {
        path: '/path/{pathParam}',
        method: 'POST',
    },
    withoutOperationIdDelete: {
        path: '/without-operation-id',
        method: 'DELETE',
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

type OperationIds = | 'anyRequestResponse' | 'empty' | 'mediaTypes' | 'operationOne' | 'withoutOperationIdDelete';
type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody> = {
    requestParameters: RequestParameters,
    requestArrayParameters: RequestArrayParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestArrayParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestArrayParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestArrayParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestArrayParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestArrayParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestArrayParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestArrayParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestArrayParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Single-value path/query parameters for AnyRequestResponse
 */
export interface AnyRequestResponseRequestParameters {
}

/**
 * Multi-value query parameters for AnyRequestResponse
 */
export interface AnyRequestResponseRequestArrayParameters {
}

/**
 * Request body parameter for AnyRequestResponse
 */
export type AnyRequestResponseRequestBody = string;

export type AnyRequestResponse200OperationResponse = OperationResponse<200, string>;
export type AnyRequestResponseOperationResponses = | AnyRequestResponse200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type AnyRequestResponseHandlerFunction = LambdaHandlerFunction<AnyRequestResponseRequestParameters, AnyRequestResponseRequestArrayParameters, AnyRequestResponseRequestBody, AnyRequestResponseOperationResponses>;
export type AnyRequestResponseChainedHandlerFunction = ChainedLambdaHandlerFunction<AnyRequestResponseRequestParameters, AnyRequestResponseRequestArrayParameters, AnyRequestResponseRequestBody, AnyRequestResponseOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of anyRequestResponse
 */
export const anyRequestResponseHandler = (
    firstHandler: AnyRequestResponseChainedHandlerFunction,
    ...remainingHandlers: AnyRequestResponseChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'anyRequestResponse'> => async (event: any, context: any, _callback?: any, additionalInterceptors: AnyRequestResponseChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as AnyRequestResponseRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as AnyRequestResponseRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as AnyRequestResponseRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for Empty
 */
export interface EmptyRequestParameters {
}

/**
 * Multi-value query parameters for Empty
 */
export interface EmptyRequestArrayParameters {
}

/**
 * Request body parameter for Empty
 */
export type EmptyRequestBody = never;

export type Empty204OperationResponse = OperationResponse<204, undefined>;
export type EmptyOperationResponses = | Empty204OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type EmptyHandlerFunction = LambdaHandlerFunction<EmptyRequestParameters, EmptyRequestArrayParameters, EmptyRequestBody, EmptyOperationResponses>;
export type EmptyChainedHandlerFunction = ChainedLambdaHandlerFunction<EmptyRequestParameters, EmptyRequestArrayParameters, EmptyRequestBody, EmptyOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of empty
 */
export const emptyHandler = (
    firstHandler: EmptyChainedHandlerFunction,
    ...remainingHandlers: EmptyChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'empty'> => async (event: any, context: any, _callback?: any, additionalInterceptors: EmptyChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as EmptyRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as EmptyRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as EmptyRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 204:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for MediaTypes
 */
export interface MediaTypesRequestParameters {
}

/**
 * Multi-value query parameters for MediaTypes
 */
export interface MediaTypesRequestArrayParameters {
}

/**
 * Request body parameter for MediaTypes
 */
export type MediaTypesRequestBody = string;

export type MediaTypes200OperationResponse = OperationResponse<200, string>;
export type MediaTypesOperationResponses = | MediaTypes200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type MediaTypesHandlerFunction = LambdaHandlerFunction<MediaTypesRequestParameters, MediaTypesRequestArrayParameters, MediaTypesRequestBody, MediaTypesOperationResponses>;
export type MediaTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MediaTypesRequestParameters, MediaTypesRequestArrayParameters, MediaTypesRequestBody, MediaTypesOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mediaTypes
 */
export const mediaTypesHandler = (
    firstHandler: MediaTypesChainedHandlerFunction,
    ...remainingHandlers: MediaTypesChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'mediaTypes'> => async (event: any, context: any, _callback?: any, additionalInterceptors: MediaTypesChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as MediaTypesRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as MediaTypesRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/pdf',]) as MediaTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for OperationOne
 */
export interface OperationOneRequestParameters {
    readonly param1: string;
    readonly param3: string;
    readonly pathParam: string;
    readonly param4?: string;
}

/**
 * Multi-value query parameters for OperationOne
 */
export interface OperationOneRequestArrayParameters {
    readonly param2: string[];
}

/**
 * Request body parameter for OperationOne
 */
export type OperationOneRequestBody = TestRequest;

export type OperationOne200OperationResponse = OperationResponse<200, TestResponse>;
export type OperationOne400OperationResponse = OperationResponse<400, ApiError>;
export type OperationOneOperationResponses = | OperationOne200OperationResponse | OperationOne400OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type OperationOneHandlerFunction = LambdaHandlerFunction<OperationOneRequestParameters, OperationOneRequestArrayParameters, OperationOneRequestBody, OperationOneOperationResponses>;
export type OperationOneChainedHandlerFunction = ChainedLambdaHandlerFunction<OperationOneRequestParameters, OperationOneRequestArrayParameters, OperationOneRequestBody, OperationOneOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of operationOne
 */
export const operationOneHandler = (
    firstHandler: OperationOneChainedHandlerFunction,
    ...remainingHandlers: OperationOneChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'operationOne'> => async (event: any, context: any, _callback?: any, additionalInterceptors: OperationOneChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as OperationOneRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as OperationOneRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString));
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as OperationOneRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(TestResponseToJSON(marshalledBody));
                break;
            case 400:
                marshalledBody = JSON.stringify(ApiErrorToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Single-value path/query parameters for WithoutOperationIdDelete
 */
export interface WithoutOperationIdDeleteRequestParameters {
}

/**
 * Multi-value query parameters for WithoutOperationIdDelete
 */
export interface WithoutOperationIdDeleteRequestArrayParameters {
}

/**
 * Request body parameter for WithoutOperationIdDelete
 */
export type WithoutOperationIdDeleteRequestBody = never;

export type WithoutOperationIdDelete200OperationResponse = OperationResponse<200, TestResponse>;
export type WithoutOperationIdDeleteOperationResponses = | WithoutOperationIdDelete200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type WithoutOperationIdDeleteHandlerFunction = LambdaHandlerFunction<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestArrayParameters, WithoutOperationIdDeleteRequestBody, WithoutOperationIdDeleteOperationResponses>;
export type WithoutOperationIdDeleteChainedHandlerFunction = ChainedLambdaHandlerFunction<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestArrayParameters, WithoutOperationIdDeleteRequestBody, WithoutOperationIdDeleteOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of withoutOperationIdDelete
 */
export const withoutOperationIdDeleteHandler = (
    firstHandler: WithoutOperationIdDeleteChainedHandlerFunction,
    ...remainingHandlers: WithoutOperationIdDeleteChainedHandlerFunction[]
): OperationApiGatewayLambdaHandler<'withoutOperationIdDelete'> => async (event: any, context: any, _callback?: any, additionalInterceptors: WithoutOperationIdDeleteChainedHandlerFunction[] = []): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as WithoutOperationIdDeleteRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as WithoutOperationIdDeleteRequestArrayParameters;

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as WithoutOperationIdDeleteRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, firstHandler, ...remainingHandlers);
    const response = await chain.next({
        input: {
            requestParameters,
            requestArrayParameters,
            body,
        },
        event,
        context,
        interceptorContext: {},
    });

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(TestResponseToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    return {
        ...response,
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly anyRequestResponse: OperationApiGatewayLambdaHandler<'anyRequestResponse'>;
  readonly empty: OperationApiGatewayLambdaHandler<'empty'>;
  readonly mediaTypes: OperationApiGatewayLambdaHandler<'mediaTypes'>;
  readonly operationOne: OperationApiGatewayLambdaHandler<'operationOne'>;
  readonly withoutOperationIdDelete: OperationApiGatewayLambdaHandler<'withoutOperationIdDelete'>;
}

export type AnyOperationRequestParameters = | AnyRequestResponseRequestParameters| EmptyRequestParameters| MediaTypesRequestParameters| OperationOneRequestParameters| WithoutOperationIdDeleteRequestParameters;
export type AnyOperationRequestArrayParameters = | AnyRequestResponseRequestArrayParameters| EmptyRequestArrayParameters| MediaTypesRequestArrayParameters| OperationOneRequestArrayParameters| WithoutOperationIdDeleteRequestArrayParameters;
export type AnyOperationRequestBodies = | AnyRequestResponseRequestBody| EmptyRequestBody| MediaTypesRequestBody| OperationOneRequestBody| WithoutOperationIdDeleteRequestBody;
export type AnyOperationResponses = | AnyRequestResponseOperationResponses| EmptyOperationResponses| MediaTypesOperationResponses| OperationOneOperationResponses| WithoutOperationIdDeleteOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestArrayParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestArrayParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


/**
 * Check if a given object implements the ApiError interface.
 */
export function instanceOfApiError(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "errorMessage" in value;

    return isInstance;
}

export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


/**
 * Check if a given object implements the TestRequest interface.
 */
export function instanceOfTestRequest(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { TestResponseMessagesInner } from './TestResponseMessagesInner';
import {
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
} from './TestResponseMessagesInner';

/**
 * 
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


/**
 * Check if a given object implements the TestResponse interface.
 */
export function instanceOfTestResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;

    return isInstance;
}

export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


/**
 * Check if a given object implements the TestResponseMessagesInner interface.
 */
export function instanceOfTestResponseMessagesInner(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;
