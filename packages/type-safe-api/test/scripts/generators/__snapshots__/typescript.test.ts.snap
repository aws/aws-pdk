// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Typescript Client Code Generation Script Unit Tests Generates With allof-model.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/Template.ts
src/models/TemplateBase.ts
src/models/TemplateBody.ts
src/models/TemplateID.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  Template,
} from '../models';
import {
    TemplateFromJSON,
    TemplateToJSON,
} from '../models';


/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async sayHelloRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Template>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/hello\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateFromJSON(jsonValue));
    }

    /**
     * 
     */
    async sayHello(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Template> {
        const response = await this.sayHelloRaw(initOverrides);
        return await response.value();
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    Template,
    TemplateFromJSON,
    TemplateToJSON,
    TemplateBase,
    TemplateBaseFromJSON,
    TemplateBaseToJSON,
    TemplateBody,
    TemplateBodyFromJSON,
    TemplateBodyToJSON,
    TemplateID,
    TemplateIDFromJSON,
    TemplateIDToJSON,
} from '../../models';
// Import request parameter interfaces
import {
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    sayHello: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    sayHello: {
        path: '/hello',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'sayHello';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for SayHello
 */
export interface SayHelloRequestParameters {
}

/**
 * Request body parameter for SayHello
 */
export type SayHelloRequestBody = never;

export type SayHello200OperationResponse = OperationResponse<200, Template>;

export type SayHelloOperationResponses = | SayHello200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type SayHelloHandlerFunction = LambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedHandlerFunction = ChainedLambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedRequestInput = ChainedRequestInput<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of sayHello
 */
export const sayHelloHandler = (
    ...handlers: [SayHelloChainedHandlerFunction, ...SayHelloChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'sayHello'> => async (event: any, context: any, _callback?: any, additionalInterceptors: SayHelloChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "sayHello";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(TemplateToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: SayHelloRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as SayHelloRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly sayHello: OperationApiGatewayLambdaHandler<'sayHello'>;
}

export type AnyOperationRequestParameters = | SayHelloRequestParameters;
export type AnyOperationRequestBodies = | SayHelloRequestBody;
export type AnyOperationResponses = | SayHelloOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/Template.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { TemplateBase } from './TemplateBase';
import {
    TemplateBaseFromJSON,
    TemplateBaseFromJSONTyped,
    TemplateBaseToJSON,
} from './TemplateBase';
import type { TemplateBody } from './TemplateBody';
import {
    TemplateBodyFromJSON,
    TemplateBodyFromJSONTyped,
    TemplateBodyToJSON,
} from './TemplateBody';
import type { TemplateID } from './TemplateID';
import {
    TemplateIDFromJSON,
    TemplateIDFromJSONTyped,
    TemplateIDToJSON,
} from './TemplateID';

/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {TemplateID}
     * @memberof Template
     */
    id: TemplateID;
}


/**
 * Check if a given object implements the Template interface.
 */
export function instanceOfTemplate(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function TemplateFromJSON(json: any): Template {
    return TemplateFromJSONTyped(json, false);
}

export function TemplateFromJSONTyped(json: any, ignoreDiscriminator: boolean): Template {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'id': TemplateIDFromJSON(json['id']),
    };
}

export function TemplateToJSON(value?: Template | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'id': TemplateIDToJSON(value.id),
    };
}

",
  "src/models/TemplateBase.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { TemplateID } from './TemplateID';
import {
    TemplateIDFromJSON,
    TemplateIDFromJSONTyped,
    TemplateIDToJSON,
} from './TemplateID';

/**
 * Represents the base properties of a template.

 * @export
 * @interface TemplateBase
 */
export interface TemplateBase {
    /**
     * 
     * @type {TemplateID}
     * @memberof TemplateBase
     */
    id: TemplateID;
}


/**
 * Check if a given object implements the TemplateBase interface.
 */
export function instanceOfTemplateBase(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function TemplateBaseFromJSON(json: any): TemplateBase {
    return TemplateBaseFromJSONTyped(json, false);
}

export function TemplateBaseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TemplateBase {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'id': TemplateIDFromJSON(json['id']),
    };
}

export function TemplateBaseToJSON(value?: TemplateBase | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'id': TemplateIDToJSON(value.id),
    };
}

",
  "src/models/TemplateBody.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { TemplateID } from './TemplateID';
import {
    TemplateIDFromJSON,
    TemplateIDFromJSONTyped,
    TemplateIDToJSON,
} from './TemplateID';

/**
 * Represents the body of a template.

 * @export
 * @interface TemplateBody
 */
export interface TemplateBody {
    /**
     * 
     * @type {TemplateID}
     * @memberof TemplateBody
     */
    parent_id?: TemplateID;
    /**
     * A boolean value.
     * @type {boolean}
     * @memberof TemplateBody
     */
    boolean?: boolean;
}


/**
 * Check if a given object implements the TemplateBody interface.
 */
export function instanceOfTemplateBody(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function TemplateBodyFromJSON(json: any): TemplateBody {
    return TemplateBodyFromJSONTyped(json, false);
}

export function TemplateBodyFromJSONTyped(json: any, ignoreDiscriminator: boolean): TemplateBody {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'parent_id': !exists(json, 'parent_id') ? undefined : TemplateIDFromJSON(json['parent_id']),
        'boolean': !exists(json, 'boolean') ? undefined : json['boolean'],
    };
}

export function TemplateBodyToJSON(value?: TemplateBody | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'parent_id': TemplateIDToJSON(value.parent_id),
        'boolean': value.boolean,
    };
}

",
  "src/models/TemplateID.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * The unique identifier for a template.
 * @export
 * @interface TemplateID
 */
export interface TemplateID {
}


/**
 * Check if a given object implements the TemplateID interface.
 */
export function instanceOfTemplateID(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function TemplateIDFromJSON(json: any): TemplateID {
    return TemplateIDFromJSONTyped(json, false);
}

export function TemplateIDFromJSONTyped(json: any, ignoreDiscriminator: boolean): TemplateID {
    return json;
}

export function TemplateIDToJSON(value?: TemplateID | null): any {
    return value;
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './Template';
export * from './TemplateBase';
export * from './TemplateBody';
export * from './TemplateID';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With data-types.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/DataTypes200Response.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  DataTypes200Response,
} from '../models';
import {
    DataTypes200ResponseFromJSON,
    DataTypes200ResponseToJSON,
} from '../models';


/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async dataTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataTypes200Response>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/types\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataTypes200ResponseFromJSON(jsonValue));
    }

    /**
     * 
     */
    async dataTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataTypes200Response> {
        const response = await this.dataTypesRaw(initOverrides);
        return await response.value();
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    DataTypes200Response,
    DataTypes200ResponseFromJSON,
    DataTypes200ResponseToJSON,
} from '../../models';
// Import request parameter interfaces
import {
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    dataTypes: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    dataTypes: {
        path: '/types',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'dataTypes';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for DataTypes
 */
export interface DataTypesRequestParameters {
}

/**
 * Request body parameter for DataTypes
 */
export type DataTypesRequestBody = never;

export type DataTypes200OperationResponse = OperationResponse<200, DataTypes200Response>;

export type DataTypesOperationResponses = | DataTypes200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type DataTypesHandlerFunction = LambdaHandlerFunction<DataTypesRequestParameters, DataTypesRequestBody, DataTypesOperationResponses>;
export type DataTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<DataTypesRequestParameters, DataTypesRequestBody, DataTypesOperationResponses>;
export type DataTypesChainedRequestInput = ChainedRequestInput<DataTypesRequestParameters, DataTypesRequestBody, DataTypesOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of dataTypes
 */
export const dataTypesHandler = (
    ...handlers: [DataTypesChainedHandlerFunction, ...DataTypesChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'dataTypes'> => async (event: any, context: any, _callback?: any, additionalInterceptors: DataTypesChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "dataTypes";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(DataTypes200ResponseToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: DataTypesRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as DataTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly dataTypes: OperationApiGatewayLambdaHandler<'dataTypes'>;
}

export type AnyOperationRequestParameters = | DataTypesRequestParameters;
export type AnyOperationRequestBodies = | DataTypesRequestBody;
export type AnyOperationResponses = | DataTypesOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/DataTypes200Response.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface DataTypes200Response
 */
export interface DataTypes200Response {
    /**
     * 
     * @type {number}
     * @memberof DataTypes200Response
     */
    myInt?: number;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myString?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myStringLength?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myLongMinStringLength?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataTypes200Response
     */
    myBool?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DataTypes200Response
     */
    myNumber?: number;
    /**
     * 
     * @type {Array<Date>}
     * @memberof DataTypes200Response
     */
    myDateArray?: Array<Date>;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myHostname?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myIpv4?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myIpv6?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myByte?: string;
    /**
     * 
     * @type {Date}
     * @memberof DataTypes200Response
     */
    myDateTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof DataTypes200Response
     */
    myRegexPattern?: string;
    /**
     * 
     * @type {any}
     * @memberof DataTypes200Response
     */
    myOneOf?: any | null;
    /**
     * 
     * @type {any}
     * @memberof DataTypes200Response
     */
    myAnyOf?: any | null;
    /**
     * 
     * @type {any}
     * @memberof DataTypes200Response
     */
    myAllOf?: any | null;
    /**
     * 
     * @type {any}
     * @memberof DataTypes200Response
     */
    myNot?: any | null;
    /**
     * 
     * @type {any}
     * @memberof DataTypes200Response
     */
    myNotString?: any | null;
    /**
     * 
     * @type {{ [key: string]: Array<number>; }}
     * @memberof DataTypes200Response
     */
    myAdditionalProperties?: { [key: string]: Array<number>; };
}


/**
 * Check if a given object implements the DataTypes200Response interface.
 */
export function instanceOfDataTypes200Response(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function DataTypes200ResponseFromJSON(json: any): DataTypes200Response {
    return DataTypes200ResponseFromJSONTyped(json, false);
}

export function DataTypes200ResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): DataTypes200Response {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'myInt': !exists(json, 'myInt') ? undefined : json['myInt'],
        'myString': !exists(json, 'myString') ? undefined : json['myString'],
        'myStringLength': !exists(json, 'myStringLength') ? undefined : json['myStringLength'],
        'myLongMinStringLength': !exists(json, 'myLongMinStringLength') ? undefined : json['myLongMinStringLength'],
        'myBool': !exists(json, 'myBool') ? undefined : json['myBool'],
        'myNumber': !exists(json, 'myNumber') ? undefined : json['myNumber'],
        'myDateArray': !exists(json, 'myDateArray') ? undefined : json['myDateArray'],
        'myEmail': !exists(json, 'myEmail') ? undefined : json['myEmail'],
        'myUrl': !exists(json, 'myUrl') ? undefined : json['myUrl'],
        'myHostname': !exists(json, 'myHostname') ? undefined : json['myHostname'],
        'myIpv4': !exists(json, 'myIpv4') ? undefined : json['myIpv4'],
        'myIpv6': !exists(json, 'myIpv6') ? undefined : json['myIpv6'],
        'myUuid': !exists(json, 'myUuid') ? undefined : json['myUuid'],
        'myByte': !exists(json, 'myByte') ? undefined : json['myByte'],
        'myDateTime': !exists(json, 'myDateTime') ? undefined : (new Date(json['myDateTime'])),
        'myRegexPattern': !exists(json, 'myRegexPattern') ? undefined : json['myRegexPattern'],
        'myOneOf': !exists(json, 'myOneOf') ? undefined : json['myOneOf'],
        'myAnyOf': !exists(json, 'myAnyOf') ? undefined : json['myAnyOf'],
        'myAllOf': !exists(json, 'myAllOf') ? undefined : json['myAllOf'],
        'myNot': !exists(json, 'myNot') ? undefined : json['myNot'],
        'myNotString': !exists(json, 'myNotString') ? undefined : json['myNotString'],
        'myAdditionalProperties': !exists(json, 'myAdditionalProperties') ? undefined : json['myAdditionalProperties'],
    };
}

export function DataTypes200ResponseToJSON(value?: DataTypes200Response | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'myInt': value.myInt,
        'myString': value.myString,
        'myStringLength': value.myStringLength,
        'myLongMinStringLength': value.myLongMinStringLength,
        'myBool': value.myBool,
        'myNumber': value.myNumber,
        'myDateArray': value.myDateArray,
        'myEmail': value.myEmail,
        'myUrl': value.myUrl,
        'myHostname': value.myHostname,
        'myIpv4': value.myIpv4,
        'myIpv6': value.myIpv6,
        'myUuid': value.myUuid,
        'myByte': value.myByte,
        'myDateTime': value.myDateTime === undefined ? undefined : (value.myDateTime.toISOString()),
        'myRegexPattern': value.myRegexPattern,
        'myOneOf': value.myOneOf,
        'myAnyOf': value.myAnyOf,
        'myAllOf': value.myAllOf,
        'myNot': value.myNot,
        'myNotString': value.myNotString,
        'myAdditionalProperties': value.myAdditionalProperties,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DataTypes200Response';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With default-response.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/HelloId.ts
src/models/SayHelloResponseContent.ts
src/models/ServiceUnavailableErrorResponseContent.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  SayHelloResponseContent,
  ServiceUnavailableErrorResponseContent,
} from '../models';
import {
    SayHelloResponseContentFromJSON,
    SayHelloResponseContentToJSON,
    ServiceUnavailableErrorResponseContentFromJSON,
    ServiceUnavailableErrorResponseContentToJSON,
} from '../models';

export interface SayHelloRequest {
    name: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async sayHelloRaw(requestParameters: SayHelloRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SayHelloResponseContent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling sayHello.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/hello\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SayHelloResponseContentFromJSON(jsonValue));
    }

    /**
     * 
     */
    async sayHello(requestParameters: SayHelloRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SayHelloResponseContent> {
        const response = await this.sayHelloRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    HelloId,
    HelloIdFromJSON,
    HelloIdToJSON,
    SayHelloResponseContent,
    SayHelloResponseContentFromJSON,
    SayHelloResponseContentToJSON,
    ServiceUnavailableErrorResponseContent,
    ServiceUnavailableErrorResponseContentFromJSON,
    ServiceUnavailableErrorResponseContentToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    SayHelloRequest,
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    sayHello: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    sayHello: {
        path: '/hello',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'sayHello';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for SayHello
 */
export interface SayHelloRequestParameters {
    readonly name: string;
}

/**
 * Request body parameter for SayHello
 */
export type SayHelloRequestBody = never;

export type SayHello200OperationResponse = OperationResponse<200, SayHelloResponseContent>;
export type SayHello0OperationResponse = OperationResponse<0, ServiceUnavailableErrorResponseContent>;

export type SayHelloOperationResponses = | SayHello200OperationResponse | SayHello0OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type SayHelloHandlerFunction = LambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedHandlerFunction = ChainedLambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedRequestInput = ChainedRequestInput<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of sayHello
 */
export const sayHelloHandler = (
    ...handlers: [SayHelloChainedHandlerFunction, ...SayHelloChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'sayHello'> => async (event: any, context: any, _callback?: any, additionalInterceptors: SayHelloChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "sayHello";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(SayHelloResponseContentToJSON(marshalledBody));
                break;
            case 0:
                marshalledBody = JSON.stringify(ServiceUnavailableErrorResponseContentToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            case 0: {
                if ("ServiceUnavailableErrorResponseContent".endsWith("ResponseContent")) {
                    headers["x-amzn-errortype"] = "ServiceUnavailableErrorResponseContent".slice(0, -"ResponseContent".length);
                }
                break;
            }
            default:
                break;
        }

        return headers;
    };

    let requestParameters: SayHelloRequestParameters | undefined = undefined;

    try {
      requestParameters = {
          name: coerceParameter("name", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as string,

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as SayHelloRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly sayHello: OperationApiGatewayLambdaHandler<'sayHello'>;
}

export type AnyOperationRequestParameters = | SayHelloRequestParameters;
export type AnyOperationRequestBodies = | SayHelloRequestBody;
export type AnyOperationResponses = | SayHelloOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/HelloId.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface HelloId
 */
export interface HelloId {
}


/**
 * Check if a given object implements the HelloId interface.
 */
export function instanceOfHelloId(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function HelloIdFromJSON(json: any): HelloId {
    return HelloIdFromJSONTyped(json, false);
}

export function HelloIdFromJSONTyped(json: any, ignoreDiscriminator: boolean): HelloId {
    return json;
}

export function HelloIdToJSON(value?: HelloId | null): any {
    return value;
}

",
  "src/models/SayHelloResponseContent.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { HelloId } from './HelloId';
import {
    HelloIdFromJSON,
    HelloIdFromJSONTyped,
    HelloIdToJSON,
} from './HelloId';

/**
 * 
 * @export
 * @interface SayHelloResponseContent
 */
export interface SayHelloResponseContent {
    /**
     * 
     * @type {HelloId}
     * @memberof SayHelloResponseContent
     */
    id?: HelloId;
    /**
     * 
     * @type {string}
     * @memberof SayHelloResponseContent
     */
    message: string;
}


/**
 * Check if a given object implements the SayHelloResponseContent interface.
 */
export function instanceOfSayHelloResponseContent(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "message" in value;

    return isInstance;
}

export function SayHelloResponseContentFromJSON(json: any): SayHelloResponseContent {
    return SayHelloResponseContentFromJSONTyped(json, false);
}

export function SayHelloResponseContentFromJSONTyped(json: any, ignoreDiscriminator: boolean): SayHelloResponseContent {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'id': !exists(json, 'id') ? undefined : HelloIdFromJSON(json['id']),
        'message': json['message'],
    };
}

export function SayHelloResponseContentToJSON(value?: SayHelloResponseContent | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'id': HelloIdToJSON(value.id),
        'message': value.message,
    };
}

",
  "src/models/ServiceUnavailableErrorResponseContent.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface ServiceUnavailableErrorResponseContent
 */
export interface ServiceUnavailableErrorResponseContent {
    /**
     * 
     * @type {string}
     * @memberof ServiceUnavailableErrorResponseContent
     */
    message: string;
}


/**
 * Check if a given object implements the ServiceUnavailableErrorResponseContent interface.
 */
export function instanceOfServiceUnavailableErrorResponseContent(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "message" in value;

    return isInstance;
}

export function ServiceUnavailableErrorResponseContentFromJSON(json: any): ServiceUnavailableErrorResponseContent {
    return ServiceUnavailableErrorResponseContentFromJSONTyped(json, false);
}

export function ServiceUnavailableErrorResponseContentFromJSONTyped(json: any, ignoreDiscriminator: boolean): ServiceUnavailableErrorResponseContent {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'message': json['message'],
    };
}

export function ServiceUnavailableErrorResponseContentToJSON(value?: ServiceUnavailableErrorResponseContent | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'message': value.message,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './HelloId';
export * from './SayHelloResponseContent';
export * from './ServiceUnavailableErrorResponseContent';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With edge-cases.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/MyEnum.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  MyEnum,
} from '../models';
import {
    MyEnumFromJSON,
    MyEnumToJSON,
} from '../models';

export interface ArrayRequestParametersRequest {
    myStringArrayRequestParams?: Array<string>;
    myEnumArrayRequestParams?: Array<MyEnum>;
    myIntegerArrayRequestParams?: Array<number>;
    myLongArrayRequestParams?: Array<number>;
    myInt32ArrayRequestParams?: Array<number>;
    myNumberArrayRequestParams?: Array<number>;
    myFloatArrayRequestParams?: Array<number>;
    myDoubleArrayRequestParams?: Array<number>;
}

export interface ReservedKeywordsRequest {
    _with?: string;
    _if?: string;
    _class?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async arrayRequestParametersRaw(requestParameters: ArrayRequestParametersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.myStringArrayRequestParams) {
            queryParameters['my-string-array-request-params'] = requestParameters.myStringArrayRequestParams;
        }

        if (requestParameters.myEnumArrayRequestParams) {
            queryParameters['my-enum-array-request-params'] = requestParameters.myEnumArrayRequestParams;
        }

        if (requestParameters.myIntegerArrayRequestParams) {
            queryParameters['my-integer-array-request-params'] = requestParameters.myIntegerArrayRequestParams;
        }

        if (requestParameters.myLongArrayRequestParams) {
            queryParameters['my-long-array-request-params'] = requestParameters.myLongArrayRequestParams;
        }

        if (requestParameters.myInt32ArrayRequestParams) {
            queryParameters['my-int32-array-request-params'] = requestParameters.myInt32ArrayRequestParams;
        }

        if (requestParameters.myNumberArrayRequestParams) {
            queryParameters['my-number-array-request-params'] = requestParameters.myNumberArrayRequestParams;
        }

        if (requestParameters.myFloatArrayRequestParams) {
            queryParameters['my-float-array-request-params'] = requestParameters.myFloatArrayRequestParams;
        }

        if (requestParameters.myDoubleArrayRequestParams) {
            queryParameters['my-double-array-request-params'] = requestParameters.myDoubleArrayRequestParams;
        }


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/array-request-parameters\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async arrayRequestParameters(requestParameters: ArrayRequestParametersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.arrayRequestParametersRaw(requestParameters, initOverrides);
    }

    /**
     * 
     */
    async reservedKeywordsRaw(requestParameters: ReservedKeywordsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters._with !== undefined) {
            queryParameters['with'] = requestParameters._with;
        }

        if (requestParameters._if !== undefined) {
            queryParameters['if'] = requestParameters._if;
        }

        if (requestParameters._class !== undefined) {
            queryParameters['class'] = requestParameters._class;
        }


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/reserved-keywords\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async reservedKeywords(requestParameters: ReservedKeywordsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.reservedKeywordsRaw(requestParameters, initOverrides);
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    MyEnum,
    MyEnumFromJSON,
    MyEnumToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    ArrayRequestParametersRequest,
    ReservedKeywordsRequest,
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    arrayRequestParameters: T;
    reservedKeywords: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    arrayRequestParameters: {
        path: '/array-request-parameters',
        method: 'GET',
        contentTypes: ['application/json'],
    },
    reservedKeywords: {
        path: '/reserved-keywords',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'arrayRequestParameters' | 'reservedKeywords';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for ArrayRequestParameters
 */
export interface ArrayRequestParametersRequestParameters {
    readonly myStringArrayRequestParams?: Array<string>;
    readonly myEnumArrayRequestParams?: Array<MyEnum>;
    readonly myIntegerArrayRequestParams?: Array<number>;
    readonly myLongArrayRequestParams?: Array<number>;
    readonly myInt32ArrayRequestParams?: Array<number>;
    readonly myNumberArrayRequestParams?: Array<number>;
    readonly myFloatArrayRequestParams?: Array<number>;
    readonly myDoubleArrayRequestParams?: Array<number>;
}

/**
 * Request body parameter for ArrayRequestParameters
 */
export type ArrayRequestParametersRequestBody = never;


export type ArrayRequestParametersOperationResponses = ;

// Type that the handler function provided to the wrapper must conform to
export type ArrayRequestParametersHandlerFunction = LambdaHandlerFunction<ArrayRequestParametersRequestParameters, ArrayRequestParametersRequestBody, ArrayRequestParametersOperationResponses>;
export type ArrayRequestParametersChainedHandlerFunction = ChainedLambdaHandlerFunction<ArrayRequestParametersRequestParameters, ArrayRequestParametersRequestBody, ArrayRequestParametersOperationResponses>;
export type ArrayRequestParametersChainedRequestInput = ChainedRequestInput<ArrayRequestParametersRequestParameters, ArrayRequestParametersRequestBody, ArrayRequestParametersOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of arrayRequestParameters
 */
export const arrayRequestParametersHandler = (
    ...handlers: [ArrayRequestParametersChainedHandlerFunction, ...ArrayRequestParametersChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'arrayRequestParameters'> => async (event: any, context: any, _callback?: any, additionalInterceptors: ArrayRequestParametersChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "arrayRequestParameters";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: ArrayRequestParametersRequestParameters | undefined = undefined;

    try {
      requestParameters = {
          myStringArrayRequestParams: coerceParameter("my-string-array-request-params", "Array<string>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<string> | undefined,
          myEnumArrayRequestParams: coerceParameter("my-enum-array-request-params", "Array<MyEnum>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<MyEnum> | undefined,
          myIntegerArrayRequestParams: coerceParameter("my-integer-array-request-params", "Array<number>", true || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,
          myLongArrayRequestParams: coerceParameter("my-long-array-request-params", "Array<number>", true || true || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,
          myInt32ArrayRequestParams: coerceParameter("my-int32-array-request-params", "Array<number>", true || false || true, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,
          myNumberArrayRequestParams: coerceParameter("my-number-array-request-params", "Array<number>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,
          myFloatArrayRequestParams: coerceParameter("my-float-array-request-params", "Array<number>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,
          myDoubleArrayRequestParams: coerceParameter("my-double-array-request-params", "Array<number>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<number> | undefined,

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as ArrayRequestParametersRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for ReservedKeywords
 */
export interface ReservedKeywordsRequestParameters {
    readonly _with?: string;
    readonly _if?: string;
    readonly _class?: string;
}

/**
 * Request body parameter for ReservedKeywords
 */
export type ReservedKeywordsRequestBody = never;


export type ReservedKeywordsOperationResponses = ;

// Type that the handler function provided to the wrapper must conform to
export type ReservedKeywordsHandlerFunction = LambdaHandlerFunction<ReservedKeywordsRequestParameters, ReservedKeywordsRequestBody, ReservedKeywordsOperationResponses>;
export type ReservedKeywordsChainedHandlerFunction = ChainedLambdaHandlerFunction<ReservedKeywordsRequestParameters, ReservedKeywordsRequestBody, ReservedKeywordsOperationResponses>;
export type ReservedKeywordsChainedRequestInput = ChainedRequestInput<ReservedKeywordsRequestParameters, ReservedKeywordsRequestBody, ReservedKeywordsOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of reservedKeywords
 */
export const reservedKeywordsHandler = (
    ...handlers: [ReservedKeywordsChainedHandlerFunction, ...ReservedKeywordsChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'reservedKeywords'> => async (event: any, context: any, _callback?: any, additionalInterceptors: ReservedKeywordsChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "reservedKeywords";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: ReservedKeywordsRequestParameters | undefined = undefined;

    try {
      requestParameters = {
          _with: coerceParameter("with", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as string | undefined,
          _if: coerceParameter("if", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as string | undefined,
          _class: coerceParameter("class", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as string | undefined,

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as ReservedKeywordsRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly arrayRequestParameters: OperationApiGatewayLambdaHandler<'arrayRequestParameters'>;
  readonly reservedKeywords: OperationApiGatewayLambdaHandler<'reservedKeywords'>;
}

export type AnyOperationRequestParameters = | ArrayRequestParametersRequestParameters| ReservedKeywordsRequestParameters;
export type AnyOperationRequestBodies = | ArrayRequestParametersRequestBody| ReservedKeywordsRequestBody;
export type AnyOperationResponses = | ArrayRequestParametersOperationResponses| ReservedKeywordsOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/MyEnum.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @enum {string}
 */
export type MyEnum =
  'one' | 
  'two' | 
  'three'


export function MyEnumFromJSON(json: any): MyEnum {
    return MyEnumFromJSONTyped(json, false);
}

export function MyEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): MyEnum {
    return json;
}

export function MyEnumToJSON(value?: MyEnum | null): any {
    return value;
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './MyEnum';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With multiple-tags.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/Tag1Api.ts
src/apis/Tag2Api.ts
src/apis/index.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';


/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async neitherRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/neither\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async neither(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.neitherRaw(initOverrides);
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
} from '../../models';
// Import request parameter interfaces
import {
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    neither: T;
    both: T;
    tag1: T;
    tag2: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    neither: {
        path: '/neither',
        method: 'GET',
        contentTypes: ['application/json'],
    },
    both: {
        path: '/both',
        method: 'GET',
        contentTypes: ['application/json'],
    },
    tag1: {
        path: '/tag1',
        method: 'GET',
        contentTypes: ['application/json'],
    },
    tag2: {
        path: '/tag2',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'neither' | 'both' | 'tag1' | 'tag2';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for Neither
 */
export interface NeitherRequestParameters {
}

/**
 * Request body parameter for Neither
 */
export type NeitherRequestBody = never;

export type Neither200OperationResponse = OperationResponse<200, undefined>;

export type NeitherOperationResponses = | Neither200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type NeitherHandlerFunction = LambdaHandlerFunction<NeitherRequestParameters, NeitherRequestBody, NeitherOperationResponses>;
export type NeitherChainedHandlerFunction = ChainedLambdaHandlerFunction<NeitherRequestParameters, NeitherRequestBody, NeitherOperationResponses>;
export type NeitherChainedRequestInput = ChainedRequestInput<NeitherRequestParameters, NeitherRequestBody, NeitherOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of neither
 */
export const neitherHandler = (
    ...handlers: [NeitherChainedHandlerFunction, ...NeitherChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'neither'> => async (event: any, context: any, _callback?: any, additionalInterceptors: NeitherChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "neither";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: NeitherRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as NeitherRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for Both
 */
export interface BothRequestParameters {
}

/**
 * Request body parameter for Both
 */
export type BothRequestBody = never;

export type Both200OperationResponse = OperationResponse<200, undefined>;

export type BothOperationResponses = | Both200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type BothHandlerFunction = LambdaHandlerFunction<BothRequestParameters, BothRequestBody, BothOperationResponses>;
export type BothChainedHandlerFunction = ChainedLambdaHandlerFunction<BothRequestParameters, BothRequestBody, BothOperationResponses>;
export type BothChainedRequestInput = ChainedRequestInput<BothRequestParameters, BothRequestBody, BothOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of both
 */
export const bothHandler = (
    ...handlers: [BothChainedHandlerFunction, ...BothChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'both'> => async (event: any, context: any, _callback?: any, additionalInterceptors: BothChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "both";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: BothRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as BothRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for Tag1
 */
export interface Tag1RequestParameters {
}

/**
 * Request body parameter for Tag1
 */
export type Tag1RequestBody = never;

export type Tag1200OperationResponse = OperationResponse<200, undefined>;

export type Tag1OperationResponses = | Tag1200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type Tag1HandlerFunction = LambdaHandlerFunction<Tag1RequestParameters, Tag1RequestBody, Tag1OperationResponses>;
export type Tag1ChainedHandlerFunction = ChainedLambdaHandlerFunction<Tag1RequestParameters, Tag1RequestBody, Tag1OperationResponses>;
export type Tag1ChainedRequestInput = ChainedRequestInput<Tag1RequestParameters, Tag1RequestBody, Tag1OperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of tag1
 */
export const tag1Handler = (
    ...handlers: [Tag1ChainedHandlerFunction, ...Tag1ChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'tag1'> => async (event: any, context: any, _callback?: any, additionalInterceptors: Tag1ChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "tag1";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: Tag1RequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as Tag1RequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for Tag2
 */
export interface Tag2RequestParameters {
}

/**
 * Request body parameter for Tag2
 */
export type Tag2RequestBody = never;

export type Tag2200OperationResponse = OperationResponse<200, undefined>;

export type Tag2OperationResponses = | Tag2200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type Tag2HandlerFunction = LambdaHandlerFunction<Tag2RequestParameters, Tag2RequestBody, Tag2OperationResponses>;
export type Tag2ChainedHandlerFunction = ChainedLambdaHandlerFunction<Tag2RequestParameters, Tag2RequestBody, Tag2OperationResponses>;
export type Tag2ChainedRequestInput = ChainedRequestInput<Tag2RequestParameters, Tag2RequestBody, Tag2OperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of tag2
 */
export const tag2Handler = (
    ...handlers: [Tag2ChainedHandlerFunction, ...Tag2ChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'tag2'> => async (event: any, context: any, _callback?: any, additionalInterceptors: Tag2ChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "tag2";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: Tag2RequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as Tag2RequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly neither: OperationApiGatewayLambdaHandler<'neither'>;
  readonly both: OperationApiGatewayLambdaHandler<'both'>;
  readonly tag1: OperationApiGatewayLambdaHandler<'tag1'>;
  readonly tag2: OperationApiGatewayLambdaHandler<'tag2'>;
}

export type AnyOperationRequestParameters = | NeitherRequestParameters| BothRequestParameters| Tag1RequestParameters| Tag2RequestParameters;
export type AnyOperationRequestBodies = | NeitherRequestBody| BothRequestBody| Tag1RequestBody| Tag2RequestBody;
export type AnyOperationResponses = | NeitherOperationResponses| BothOperationResponses| Tag1OperationResponses| Tag2OperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/Tag1Api.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';



/**
 * 
 */
export class Tag1Api extends runtime.BaseAPI {
    /**
     * 
     */
    async bothRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/both\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async both(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bothRaw(initOverrides);
    }

    /**
     * 
     */
    async tag1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/tag1\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async tag1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tag1Raw(initOverrides);
    }

}

",
  "src/apis/Tag2Api.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';


/**
 * 
 */
export class Tag2Api extends runtime.BaseAPI {
    /**
     * 
     */
    async tag2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/tag2\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async tag2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.tag2Raw(initOverrides);
    }

}

",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
export * from './Tag1Api';
export * from './Tag2Api';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With parameter-refs.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/HelloId.ts
src/models/HelloResponse.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  HelloId,
  HelloResponse,
} from '../models';
import {
    HelloIdFromJSON,
    HelloIdToJSON,
    HelloResponseFromJSON,
    HelloResponseToJSON,
} from '../models';

export interface SayHelloRequest {
    id?: HelloId;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async sayHelloRaw(requestParameters: SayHelloRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HelloResponse>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/hello\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HelloResponseFromJSON(jsonValue));
    }

    /**
     * 
     */
    async sayHello(requestParameters: SayHelloRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HelloResponse> {
        const response = await this.sayHelloRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    HelloId,
    HelloIdFromJSON,
    HelloIdToJSON,
    HelloResponse,
    HelloResponseFromJSON,
    HelloResponseToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    SayHelloRequest,
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    sayHello: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    sayHello: {
        path: '/hello',
        method: 'GET',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'sayHello';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for SayHello
 */
export interface SayHelloRequestParameters {
    readonly id?: HelloId;
}

/**
 * Request body parameter for SayHello
 */
export type SayHelloRequestBody = never;

export type SayHello200OperationResponse = OperationResponse<200, HelloResponse>;

export type SayHelloOperationResponses = | SayHello200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type SayHelloHandlerFunction = LambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedHandlerFunction = ChainedLambdaHandlerFunction<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;
export type SayHelloChainedRequestInput = ChainedRequestInput<SayHelloRequestParameters, SayHelloRequestBody, SayHelloOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of sayHello
 */
export const sayHelloHandler = (
    ...handlers: [SayHelloChainedHandlerFunction, ...SayHelloChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'sayHello'> => async (event: any, context: any, _callback?: any, additionalInterceptors: SayHelloChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "sayHello";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(HelloResponseToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: SayHelloRequestParameters | undefined = undefined;

    try {
      requestParameters = {
          id: coerceParameter("id", "HelloId", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as HelloId | undefined,

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as SayHelloRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly sayHello: OperationApiGatewayLambdaHandler<'sayHello'>;
}

export type AnyOperationRequestParameters = | SayHelloRequestParameters;
export type AnyOperationRequestBodies = | SayHelloRequestBody;
export type AnyOperationResponses = | SayHelloOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/HelloId.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface HelloId
 */
export interface HelloId {
}


/**
 * Check if a given object implements the HelloId interface.
 */
export function instanceOfHelloId(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function HelloIdFromJSON(json: any): HelloId {
    return HelloIdFromJSONTyped(json, false);
}

export function HelloIdFromJSONTyped(json: any, ignoreDiscriminator: boolean): HelloId {
    return json;
}

export function HelloIdToJSON(value?: HelloId | null): any {
    return value;
}

",
  "src/models/HelloResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { HelloId } from './HelloId';
import {
    HelloIdFromJSON,
    HelloIdFromJSONTyped,
    HelloIdToJSON,
} from './HelloId';
import type { HelloResponse } from './HelloResponse';
import {
    HelloResponseFromJSON,
    HelloResponseFromJSONTyped,
    HelloResponseToJSON,
} from './HelloResponse';

/**
 * 
 * @export
 * @interface HelloResponse
 */
export interface HelloResponse {
    /**
     * 
     * @type {HelloId}
     * @memberof HelloResponse
     */
    id: HelloId;
    /**
     * 
     * @type {HelloResponse}
     * @memberof HelloResponse
     */
    message?: HelloResponse;
}


/**
 * Check if a given object implements the HelloResponse interface.
 */
export function instanceOfHelloResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function HelloResponseFromJSON(json: any): HelloResponse {
    return HelloResponseFromJSONTyped(json, false);
}

export function HelloResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): HelloResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'id': HelloIdFromJSON(json['id']),
        'message': !exists(json, 'message') ? undefined : HelloResponseFromJSON(json['message']),
    };
}

export function HelloResponseToJSON(value?: HelloResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'id': HelloIdToJSON(value.id),
        'message': HelloResponseToJSON(value.message),
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './HelloId';
export * from './HelloResponse';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;

exports[`Typescript Client Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/runtime.ts
src/interceptors/try-catch.ts
src/interceptors/cors.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/apis/DefaultApi/OperationConfig.ts
src/response/response.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/models/index.ts
src/models/ApiError.ts
src/models/MapResponse.ts
src/models/MapResponseMapPropertyValue.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts",
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  ApiError,
  MapResponse,
  TestRequest,
  TestResponse,
} from '../models';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapResponseFromJSON,
    MapResponseToJSON,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../models';

export interface AnyRequestResponseRequest {
    body?: any | null;
}



export interface MediaTypesRequest {
    body: Blob;
}

export interface MultipleContentTypesRequest {
    testRequest: TestRequest;
}

export interface OperationOneRequest {
    param1: string;
    param2: Array<string>;
    param3: number;
    pathParam: string;
    xHeaderParam: string;
    testRequest: TestRequest;
    param4?: string;
    xMultiValueHeaderParam?: Array<string>;
}


/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * 
     */
    async anyRequestResponseRaw(requestParameters: AnyRequestResponseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        const response = await this.request({
            path: \`/any-request-response\`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * 
     */
    async anyRequestResponse(requestParameters: AnyRequestResponseRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.anyRequestResponseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     */
    async emptyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/empty-response\`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 
     */
    async empty(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.emptyRaw(initOverrides);
    }

    /**
     * 
     */
    async mapResponseRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapResponse>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/map-response\`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapResponseFromJSON(jsonValue));
    }

    /**
     * 
     */
    async mapResponse(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapResponse> {
        const response = await this.mapResponseRaw(initOverrides);
        return await response.value();
    }

    /**
     * 
     */
    async mediaTypesRaw(requestParameters: MediaTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling mediaTypes.');
        }

        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/pdf';


        const response = await this.request({
            path: \`/different-media-type\`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * 
     */
    async mediaTypes(requestParameters: MediaTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.mediaTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     */
    async multipleContentTypesRaw(requestParameters: MultipleContentTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.testRequest === null || requestParameters.testRequest === undefined) {
            throw new runtime.RequiredError('testRequest','Required parameter requestParameters.testRequest was null or undefined when calling multipleContentTypes.');
        }

        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        const response = await this.request({
            path: \`/multiple-content-types\`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestRequestToJSON(requestParameters.testRequest),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * 
     */
    async multipleContentTypes(requestParameters: MultipleContentTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.multipleContentTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     */
    async operationOneRaw(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        if (requestParameters.param1 === null || requestParameters.param1 === undefined) {
            throw new runtime.RequiredError('param1','Required parameter requestParameters.param1 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param2 === null || requestParameters.param2 === undefined) {
            throw new runtime.RequiredError('param2','Required parameter requestParameters.param2 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param3 === null || requestParameters.param3 === undefined) {
            throw new runtime.RequiredError('param3','Required parameter requestParameters.param3 was null or undefined when calling operationOne.');
        }

        if (requestParameters.pathParam === null || requestParameters.pathParam === undefined) {
            throw new runtime.RequiredError('pathParam','Required parameter requestParameters.pathParam was null or undefined when calling operationOne.');
        }

        if (requestParameters.xHeaderParam === null || requestParameters.xHeaderParam === undefined) {
            throw new runtime.RequiredError('xHeaderParam','Required parameter requestParameters.xHeaderParam was null or undefined when calling operationOne.');
        }

        if (requestParameters.testRequest === null || requestParameters.testRequest === undefined) {
            throw new runtime.RequiredError('testRequest','Required parameter requestParameters.testRequest was null or undefined when calling operationOne.');
        }

        const queryParameters: any = {};

        if (requestParameters.param1 !== undefined) {
            queryParameters['param1'] = requestParameters.param1;
        }

        if (requestParameters.param2) {
            queryParameters['param2'] = requestParameters.param2;
        }

        if (requestParameters.param3 !== undefined) {
            queryParameters['param3'] = requestParameters.param3;
        }

        if (requestParameters.param4 !== undefined) {
            queryParameters['param4'] = requestParameters.param4;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xHeaderParam !== undefined && requestParameters.xHeaderParam !== null) {
            headerParameters['x-header-param'] = String(requestParameters.xHeaderParam);
        }
        if (requestParameters.xMultiValueHeaderParam) {
            headerParameters['x-multi-value-header-param'] = requestParameters.xMultiValueHeaderParam.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const response = await this.request({
            path: \`/path/{pathParam}\`.replace(\`{\${"pathParam"}}\`, encodeURIComponent(String(requestParameters.pathParam))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestRequestToJSON(requestParameters.testRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     * 
     */
    async operationOne(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestResponse> {
        const response = await this.operationOneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     */
    async withoutOperationIdDeleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        const queryParameters: any = {};


        const headerParameters: runtime.HTTPHeaders = {};



        const response = await this.request({
            path: \`/without-operation-id\`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     * 
     */
    async withoutOperationIdDelete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestResponse> {
        const response = await this.withoutOperationIdDeleteRaw(initOverrides);
        return await response.value();
    }

}

",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapResponse,
    MapResponseFromJSON,
    MapResponseToJSON,
    MapResponseMapPropertyValue,
    MapResponseMapPropertyValueFromJSON,
    MapResponseMapPropertyValueToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    AnyRequestResponseRequest,
    MediaTypesRequest,
    MultipleContentTypesRequest,
    OperationOneRequest,
} from '..';

// API Gateway Types
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from "aws-lambda";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    anyRequestResponse: T;
    empty: T;
    mapResponse: T;
    mediaTypes: T;
    multipleContentTypes: T;
    operationOne: T;
    withoutOperationIdDelete: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    anyRequestResponse: {
        path: '/any-request-response',
        method: 'PUT',
        contentTypes: ['application/json'],
    },
    empty: {
        path: '/empty-response',
        method: 'PUT',
        contentTypes: ['application/json'],
    },
    mapResponse: {
        path: '/map-response',
        method: 'GET',
        contentTypes: ['application/json'],
    },
    mediaTypes: {
        path: '/different-media-type',
        method: 'POST',
        contentTypes: ['application/pdf'],
    },
    multipleContentTypes: {
        path: '/multiple-content-types',
        method: 'POST',
        contentTypes: ['application/json','application/pdf'],
    },
    operationOne: {
        path: '/path/{pathParam}',
        method: 'POST',
        contentTypes: ['application/json'],
    },
    withoutOperationIdDelete: {
        path: '/without-operation-id',
        method: 'DELETE',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

const assertRequired = (required: boolean, baseName: string, parameters: any) => {
    if(required && parameters[baseName] === undefined) {
        throw new Error(\`Missing required request parameter '\${baseName}'\`);
    }
};

const coerceNumber = (baseName: string, s: string, isInteger: boolean): number => {
    const n = Number(s);
    if (isNaN(n)) {
        throw new Error(\`Expected a number for request parameter '\${baseName}'\`);
    }
    if (isInteger && !Number.isInteger(n)) {
        throw new Error(\`Expected an integer for request parameter '\${baseName}'\`);
    }
    return n;
};

const coerceBoolean = (baseName: string, s: string): boolean => {
    switch (s) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(\`Expected a boolean (true or false) for request parameter '\${baseName}'\`);
    }
};

const coerceDate = (baseName: string, s: string): Date => {
    const d = new Date(s);
    if (isNaN(d as any)) {
        throw new Error(\`Expected a valid date (iso format) for request parameter '\${baseName}'\`);
    }
    return d;
};

const coerceParameter = (
    baseName: string,
    dataType: string,
    isInteger: boolean,
    rawStringParameters: { [key: string]: string | undefined },
    rawStringArrayParameters: { [key: string]: string[] | undefined },
    required: boolean,
) => {
    switch (dataType) {
      case "number":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceNumber(baseName, rawStringParameters[baseName], isInteger) : undefined;
      case "boolean":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceBoolean(baseName, rawStringParameters[baseName]) : undefined;
      case "Date":
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName] !== undefined ? coerceDate(baseName, rawStringParameters[baseName]) : undefined;
      case "Array<number>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceNumber(baseName, n, isInteger)) : undefined;
      case "Array<boolean>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceBoolean(baseName, n)) : undefined;
      case "Array<Date>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName] !== undefined ? rawStringArrayParameters[baseName].map(n => coerceDate(baseName, n)) : undefined;
      case "Array<string>":
        assertRequired(required, baseName, rawStringArrayParameters);
        return rawStringArrayParameters[baseName];
      case "string":
      default:
        assertRequired(required, baseName, rawStringParameters);
        return rawStringParameters[baseName];
    }
};

const extractResponseHeadersFromInterceptors = (interceptors: any[]): { [key: string]: string } => {
  return (interceptors ?? []).reduce((interceptor: any, headers: { [key: string]: string }) => ({
    ...headers,
    ...(interceptor?.__type_safe_api_response_headers ?? {}),
  }), {} as { [key: string]: string });
};

export type OperationIds = | 'anyRequestResponse' | 'empty' | 'mapResponse' | 'mediaTypes' | 'multipleContentTypes' | 'operationOne' | 'withoutOperationIdDelete';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResult & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyEvent, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<StatusCode extends number, Body> {
    statusCode: StatusCode;
    headers?: { [key: string]: string };
    multiValueHeaders?: { [key: string]: string[] };
    body: Body;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestBody> = {
    requestParameters: RequestParameters,
    body: RequestBody,
};

export type InterceptorContext = { [key: string]: any };

export interface RequestInput<RequestParameters, RequestBody> {
    input: LambdaRequestParameters<RequestParameters, RequestBody>;
    event: APIGatewayProxyEvent;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface ChainedRequestInput<RequestParameters, RequestBody, Response> extends RequestInput<RequestParameters, RequestBody> {
    chain: LambdaHandlerChain<RequestParameters, RequestBody, Response>;
}

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: ChainedRequestInput<RequestParameters, RequestBody, Response>,
) => Promise<Response>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestBody, Response> = (
  input: RequestInput<RequestParameters, RequestBody>,
) => Promise<Response>;

export interface LambdaHandlerChain<RequestParameters, RequestBody, Response> {
  next: LambdaHandlerFunction<RequestParameters, RequestBody, Response>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestParameters, RequestBody, Response> = ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestParameters, RequestBody, Response>(
  ...handlers: ChainedLambdaHandlerFunction<RequestParameters, RequestBody, Response>[]
): LambdaHandlerChain<RequestParameters, RequestBody, Response> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};

/**
 * Path, Query and Header parameters for AnyRequestResponse
 */
export interface AnyRequestResponseRequestParameters {
}

/**
 * Request body parameter for AnyRequestResponse
 */
export type AnyRequestResponseRequestBody = string;

export type AnyRequestResponse200OperationResponse = OperationResponse<200, string>;

export type AnyRequestResponseOperationResponses = | AnyRequestResponse200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type AnyRequestResponseHandlerFunction = LambdaHandlerFunction<AnyRequestResponseRequestParameters, AnyRequestResponseRequestBody, AnyRequestResponseOperationResponses>;
export type AnyRequestResponseChainedHandlerFunction = ChainedLambdaHandlerFunction<AnyRequestResponseRequestParameters, AnyRequestResponseRequestBody, AnyRequestResponseOperationResponses>;
export type AnyRequestResponseChainedRequestInput = ChainedRequestInput<AnyRequestResponseRequestParameters, AnyRequestResponseRequestBody, AnyRequestResponseOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of anyRequestResponse
 */
export const anyRequestResponseHandler = (
    ...handlers: [AnyRequestResponseChainedHandlerFunction, ...AnyRequestResponseChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'anyRequestResponse'> => async (event: any, context: any, _callback?: any, additionalInterceptors: AnyRequestResponseChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "anyRequestResponse";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: AnyRequestResponseRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as AnyRequestResponseRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for Empty
 */
export interface EmptyRequestParameters {
}

/**
 * Request body parameter for Empty
 */
export type EmptyRequestBody = never;

export type Empty204OperationResponse = OperationResponse<204, undefined>;

export type EmptyOperationResponses = | Empty204OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type EmptyHandlerFunction = LambdaHandlerFunction<EmptyRequestParameters, EmptyRequestBody, EmptyOperationResponses>;
export type EmptyChainedHandlerFunction = ChainedLambdaHandlerFunction<EmptyRequestParameters, EmptyRequestBody, EmptyOperationResponses>;
export type EmptyChainedRequestInput = ChainedRequestInput<EmptyRequestParameters, EmptyRequestBody, EmptyOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of empty
 */
export const emptyHandler = (
    ...handlers: [EmptyChainedHandlerFunction, ...EmptyChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'empty'> => async (event: any, context: any, _callback?: any, additionalInterceptors: EmptyChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "empty";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 204:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: EmptyRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as EmptyRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for MapResponse
 */
export interface MapResponseRequestParameters {
}

/**
 * Request body parameter for MapResponse
 */
export type MapResponseRequestBody = never;

export type MapResponse200OperationResponse = OperationResponse<200, MapResponse>;

export type MapResponseOperationResponses = | MapResponse200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type MapResponseHandlerFunction = LambdaHandlerFunction<MapResponseRequestParameters, MapResponseRequestBody, MapResponseOperationResponses>;
export type MapResponseChainedHandlerFunction = ChainedLambdaHandlerFunction<MapResponseRequestParameters, MapResponseRequestBody, MapResponseOperationResponses>;
export type MapResponseChainedRequestInput = ChainedRequestInput<MapResponseRequestParameters, MapResponseRequestBody, MapResponseOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mapResponse
 */
export const mapResponseHandler = (
    ...handlers: [MapResponseChainedHandlerFunction, ...MapResponseChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'mapResponse'> => async (event: any, context: any, _callback?: any, additionalInterceptors: MapResponseChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "mapResponse";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(MapResponseToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: MapResponseRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as MapResponseRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for MediaTypes
 */
export interface MediaTypesRequestParameters {
}

/**
 * Request body parameter for MediaTypes
 */
export type MediaTypesRequestBody = string;

export type MediaTypes200OperationResponse = OperationResponse<200, string>;

export type MediaTypesOperationResponses = | MediaTypes200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type MediaTypesHandlerFunction = LambdaHandlerFunction<MediaTypesRequestParameters, MediaTypesRequestBody, MediaTypesOperationResponses>;
export type MediaTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MediaTypesRequestParameters, MediaTypesRequestBody, MediaTypesOperationResponses>;
export type MediaTypesChainedRequestInput = ChainedRequestInput<MediaTypesRequestParameters, MediaTypesRequestBody, MediaTypesOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mediaTypes
 */
export const mediaTypesHandler = (
    ...handlers: [MediaTypesChainedHandlerFunction, ...MediaTypesChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'mediaTypes'> => async (event: any, context: any, _callback?: any, additionalInterceptors: MediaTypesChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "mediaTypes";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: MediaTypesRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/pdf']) as MediaTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for MultipleContentTypes
 */
export interface MultipleContentTypesRequestParameters {
}

/**
 * Request body parameter for MultipleContentTypes
 */
export type MultipleContentTypesRequestBody = TestRequest;

export type MultipleContentTypes200OperationResponse = OperationResponse<200, string>;

export type MultipleContentTypesOperationResponses = | MultipleContentTypes200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type MultipleContentTypesHandlerFunction = LambdaHandlerFunction<MultipleContentTypesRequestParameters, MultipleContentTypesRequestBody, MultipleContentTypesOperationResponses>;
export type MultipleContentTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MultipleContentTypesRequestParameters, MultipleContentTypesRequestBody, MultipleContentTypesOperationResponses>;
export type MultipleContentTypesChainedRequestInput = ChainedRequestInput<MultipleContentTypesRequestParameters, MultipleContentTypesRequestBody, MultipleContentTypesOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of multipleContentTypes
 */
export const multipleContentTypesHandler = (
    ...handlers: [MultipleContentTypesChainedHandlerFunction, ...MultipleContentTypesChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'multipleContentTypes'> => async (event: any, context: any, _callback?: any, additionalInterceptors: MultipleContentTypesChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "multipleContentTypes";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: MultipleContentTypesRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString));
    };
    const body = parseBody(event.body, demarshal, ['application/json','application/pdf']) as MultipleContentTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for OperationOne
 */
export interface OperationOneRequestParameters {
    readonly param1: string;
    readonly param2: Array<string>;
    readonly param3: number;
    readonly pathParam: string;
    readonly xHeaderParam: string;
    readonly param4?: string;
    readonly xMultiValueHeaderParam?: Array<string>;
}

/**
 * Request body parameter for OperationOne
 */
export type OperationOneRequestBody = TestRequest;

export type OperationOne200OperationResponse = OperationResponse<200, TestResponse>;
export type OperationOne400OperationResponse = OperationResponse<400, ApiError>;

export type OperationOneOperationResponses = | OperationOne200OperationResponse | OperationOne400OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type OperationOneHandlerFunction = LambdaHandlerFunction<OperationOneRequestParameters, OperationOneRequestBody, OperationOneOperationResponses>;
export type OperationOneChainedHandlerFunction = ChainedLambdaHandlerFunction<OperationOneRequestParameters, OperationOneRequestBody, OperationOneOperationResponses>;
export type OperationOneChainedRequestInput = ChainedRequestInput<OperationOneRequestParameters, OperationOneRequestBody, OperationOneOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of operationOne
 */
export const operationOneHandler = (
    ...handlers: [OperationOneChainedHandlerFunction, ...OperationOneChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'operationOne'> => async (event: any, context: any, _callback?: any, additionalInterceptors: OperationOneChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "operationOne";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(TestResponseToJSON(marshalledBody));
                break;
            case 400:
                marshalledBody = JSON.stringify(ApiErrorToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            case 400: {
                if ("ApiError".endsWith("ResponseContent")) {
                    headers["x-amzn-errortype"] = "ApiError".slice(0, -"ResponseContent".length);
                }
                break;
            }
            default:
                break;
        }

        return headers;
    };

    let requestParameters: OperationOneRequestParameters | undefined = undefined;

    try {
      requestParameters = {
          param1: coerceParameter("param1", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as string,
          param2: coerceParameter("param2", "Array<string>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as Array<string>,
          param3: coerceParameter("param3", "number", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as number,
          pathParam: coerceParameter("pathParam", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as string,
          xHeaderParam: coerceParameter("x-header-param", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, true) as string,
          param4: coerceParameter("param4", "string", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as string | undefined,
          xMultiValueHeaderParam: coerceParameter("x-multi-value-header-param", "Array<string>", false || false || false, rawSingleValueParameters, rawMultiValueParameters, false) as Array<string> | undefined,

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString));
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as OperationOneRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};
/**
 * Path, Query and Header parameters for WithoutOperationIdDelete
 */
export interface WithoutOperationIdDeleteRequestParameters {
}

/**
 * Request body parameter for WithoutOperationIdDelete
 */
export type WithoutOperationIdDeleteRequestBody = never;

export type WithoutOperationIdDelete200OperationResponse = OperationResponse<200, TestResponse>;

export type WithoutOperationIdDeleteOperationResponses = | WithoutOperationIdDelete200OperationResponse ;

// Type that the handler function provided to the wrapper must conform to
export type WithoutOperationIdDeleteHandlerFunction = LambdaHandlerFunction<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestBody, WithoutOperationIdDeleteOperationResponses>;
export type WithoutOperationIdDeleteChainedHandlerFunction = ChainedLambdaHandlerFunction<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestBody, WithoutOperationIdDeleteOperationResponses>;
export type WithoutOperationIdDeleteChainedRequestInput = ChainedRequestInput<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestBody, WithoutOperationIdDeleteOperationResponses>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of withoutOperationIdDelete
 */
export const withoutOperationIdDeleteHandler = (
    ...handlers: [WithoutOperationIdDeleteChainedHandlerFunction, ...WithoutOperationIdDeleteChainedHandlerFunction[]]
): OperationApiGatewayLambdaHandler<'withoutOperationIdDelete'> => async (event: any, context: any, _callback?: any, additionalInterceptors: WithoutOperationIdDeleteChainedHandlerFunction[] = []): Promise<any> => {
    const operationId = "withoutOperationIdDelete";

    const rawSingleValueParameters = decodeRequestParameters({
      ...(event.pathParameters || {}),
      ...(event.queryStringParameters || {}),
      ...(event.headers || {}),
    }) as { [key: string]: string | undefined };
    const rawMultiValueParameters = decodeRequestParameters({
      ...(event.multiValueQueryStringParameters || {}),
      ...(event.multiValueHeaders || {}),
    }) as { [key: string]: string[] | undefined };

    const marshal = (statusCode: number, responseBody: any): string => {
        let marshalledBody = responseBody;
        switch(statusCode) {
            case 200:
                marshalledBody = JSON.stringify(TestResponseToJSON(marshalledBody));
                break;
            default:
                break;
        }

        return marshalledBody;
    };

    const errorHeaders = (statusCode: number): { [key: string]: string } => {
        let headers = {};

        switch(statusCode) {
            default:
                break;
        }

        return headers;
    };

    let requestParameters: WithoutOperationIdDeleteRequestParameters | undefined = undefined;

    try {
      requestParameters = {

      };
    } catch (e: any) {
      const res = {
        statusCode: 400,
        body: { message: e.message },
        headers: extractResponseHeadersFromInterceptors(handlers),
      };
      return {
        ...res,
        headers: {
          ...errorHeaders(res.statusCode),
          ...res.headers,
        },
        body: res.body ? marshal(res.statusCode, res.body) : '',
      };
    }

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as WithoutOperationIdDeleteRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    const response = await chain.next({
        input: {
            requestParameters,
            body,
        },
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        ...response,
        headers: {
          ...errorHeaders(response.statusCode),
          ...response.headers,
        },
        body: response.body ? marshal(response.statusCode, response.body) : '',
    };
};

export interface HandlerRouterHandlers {
  readonly anyRequestResponse: OperationApiGatewayLambdaHandler<'anyRequestResponse'>;
  readonly empty: OperationApiGatewayLambdaHandler<'empty'>;
  readonly mapResponse: OperationApiGatewayLambdaHandler<'mapResponse'>;
  readonly mediaTypes: OperationApiGatewayLambdaHandler<'mediaTypes'>;
  readonly multipleContentTypes: OperationApiGatewayLambdaHandler<'multipleContentTypes'>;
  readonly operationOne: OperationApiGatewayLambdaHandler<'operationOne'>;
  readonly withoutOperationIdDelete: OperationApiGatewayLambdaHandler<'withoutOperationIdDelete'>;
}

export type AnyOperationRequestParameters = | AnyRequestResponseRequestParameters| EmptyRequestParameters| MapResponseRequestParameters| MediaTypesRequestParameters| MultipleContentTypesRequestParameters| OperationOneRequestParameters| WithoutOperationIdDeleteRequestParameters;
export type AnyOperationRequestBodies = | AnyRequestResponseRequestBody| EmptyRequestBody| MapResponseRequestBody| MediaTypesRequestBody| MultipleContentTypesRequestBody| OperationOneRequestBody| WithoutOperationIdDeleteRequestBody;
export type AnyOperationResponses = | AnyRequestResponseOperationResponses| EmptyOperationResponses| MapResponseOperationResponses| MediaTypesOperationResponses| MultipleContentTypesOperationResponses| OperationOneOperationResponses| WithoutOperationIdDeleteOperationResponses;

export interface HandlerRouterProps<
  RequestParameters,
  RequestBody,
  Response extends AnyOperationResponses
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ChainedLambdaHandlerFunction<
    RequestParameters,
    RequestBody,
    Response
  >[];

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const concatMethodAndPath = (method: string, path: string) => \`\${method.toLowerCase()}||\${path}\`;

const OperationIdByMethodAndPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, methodAndPath]) => [concatMethodAndPath(methodAndPath.method, methodAndPath.path), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestParameters,
  AnyOperationRequestBodies,
  AnyOperationResponses
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const operationId = OperationIdByMethodAndPath[concatMethodAndPath(event.requestContext.httpMethod, event.requestContext.resourcePath)];
  const handler = props.handlers[operationId];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';
export * from './response/response';
export * from './interceptors'
",
  "src/interceptors/cors.ts": "import { ChainedRequestInput, OperationResponse } from '..';

// By default, allow all origins and headers
const DEFAULT_CORS_HEADERS: { [key: string]: string } = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
};

/**
 * Create an interceptor for adding headers to the response
 * @param additionalHeaders headers to add to the response
 */
export const buildResponseHeaderInterceptor = (additionalHeaders: { [key: string]: string }) => {
  const interceptor = async <
    RequestParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    const result = await request.chain.next(request);
    return {
      ...result,
      headers: {
        ...additionalHeaders,
        ...result.headers,
      },
    };
  };

  // Any error responses returned during request validation will include the headers
  (interceptor as any).__type_safe_api_response_headers = additionalHeaders;

  return interceptor;
};

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers. Use buildResponseHeaderInterceptor to customise.
 */
export const corsInterceptor = buildResponseHeaderInterceptor(DEFAULT_CORS_HEADERS);
",
  "src/interceptors/index.ts": "import { corsInterceptor } from './cors';
import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './cors';
export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, cors headers and error handling
 */
export const INTERCEPTORS = [
  corsInterceptor,
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { ChainedRequestInput, OperationResponse } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(request: ChainedRequestInput<RequestParameters, RequestBody, Response>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { ChainedRequestInput, OperationResponse } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Promise<Response> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { ChainedRequestInput, OperationResponse } from '../..';

const tracer = new Tracer();

export interface TracingInterceptorOptions {
  /**
   * Whether to add the response as metadata to the trace
   */
  readonly addResponseAsMetadata?: boolean;
}

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = (options?: TracingInterceptorOptions) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>
>(
  request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
): Promise<Response> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    const result = await request.chain.next(request);
    if (options?.addResponseAsMetadata) {
      tracer.addResponseAsMetadata(result, handler);
    }
    return result;
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = <
    RequestParameters,
    RequestArrayParameters,
    RequestBody,
    Response extends OperationResponse<number, any>
  >(
    request: ChainedRequestInput<RequestParameters, RequestBody, Response>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  ChainedRequestInput,
  OperationResponse,
} from '..';

/**
 * Create an interceptor which returns the given error response and status should an error occur
 * @param statusCode the status code to return when an error is thrown
 * @param errorResponseBody the body to return when an error occurs
 */
export const buildTryCatchInterceptor = <TStatus extends number, ErrorResponseBody>(
  statusCode: TStatus,
  errorResponseBody: ErrorResponseBody,
) => async <
  RequestParameters,
  RequestBody,
  Response extends OperationResponse<number, any>,
>(
  request: ChainedRequestInput<
  RequestParameters,
  RequestBody,
  Response
  >,
): Promise<Response | OperationResponse<TStatus, ErrorResponseBody>> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // If the error looks like a response, return it as the response
    if ('statusCode' in e) {
      return e;
    }

    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }

    // Return the default error message
    return { statusCode, body: errorResponseBody };
  }
};

/**
 * Interceptor for catching unhandled exceptions and returning a 500 error.
 * Uncaught exceptions which look like OperationResponses will be returned, such that deeply nested code may return error
 * responses, eg: \`throw ApiResponse.notFound({ message: 'Not found!' })\`
 */
export const tryCatchInterceptor = buildTryCatchInterceptor(500, { message: 'Internal Error' });
",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


/**
 * Check if a given object implements the ApiError interface.
 */
export function instanceOfApiError(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "errorMessage" in value;

    return isInstance;
}

export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/MapResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { MapResponseMapPropertyValue } from './MapResponseMapPropertyValue';
import {
    MapResponseMapPropertyValueFromJSON,
    MapResponseMapPropertyValueFromJSONTyped,
    MapResponseMapPropertyValueToJSON,
} from './MapResponseMapPropertyValue';

/**
 * 
 * @export
 * @interface MapResponse
 */
export interface MapResponse {
    /**
     * 
     * @type {{ [key: string]: MapResponseMapPropertyValue; }}
     * @memberof MapResponse
     */
    mapProperty: { [key: string]: MapResponseMapPropertyValue; };
}


/**
 * Check if a given object implements the MapResponse interface.
 */
export function instanceOfMapResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "mapProperty" in value;

    return isInstance;
}

export function MapResponseFromJSON(json: any): MapResponse {
    return MapResponseFromJSONTyped(json, false);
}

export function MapResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'mapProperty': (mapValues(json['mapProperty'], MapResponseMapPropertyValueFromJSON)),
    };
}

export function MapResponseToJSON(value?: MapResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'mapProperty': (mapValues(value.mapProperty, MapResponseMapPropertyValueToJSON)),
    };
}

",
  "src/models/MapResponseMapPropertyValue.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface MapResponseMapPropertyValue
 */
export interface MapResponseMapPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof MapResponseMapPropertyValue
     */
    a: string;
    /**
     * 
     * @type {string}
     * @memberof MapResponseMapPropertyValue
     */
    b?: string;
}


/**
 * Check if a given object implements the MapResponseMapPropertyValue interface.
 */
export function instanceOfMapResponseMapPropertyValue(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "a" in value;

    return isInstance;
}

export function MapResponseMapPropertyValueFromJSON(json: any): MapResponseMapPropertyValue {
    return MapResponseMapPropertyValueFromJSONTyped(json, false);
}

export function MapResponseMapPropertyValueFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapResponseMapPropertyValue {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'a': json['a'],
        'b': !exists(json, 'b') ? undefined : json['b'],
    };
}

export function MapResponseMapPropertyValueToJSON(value?: MapResponseMapPropertyValue | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'a': value.a,
        'b': value.b,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * This is a test request
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


/**
 * Check if a given object implements the TestRequest interface.
 */
export function instanceOfTestRequest(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';
import type { TestResponseMessagesInner } from './TestResponseMessagesInner';
import {
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
} from './TestResponseMessagesInner';

/**
 * This is a test response
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


/**
 * Check if a given object implements the TestResponse interface.
 */
export function instanceOfTestResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;

    return isInstance;
}

export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from '../runtime';

/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * This is a message
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


/**
 * Check if a given object implements the TestResponseMessagesInner interface.
 */
export function instanceOfTestResponseMessagesInner(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './MapResponse';
export * from './MapResponseMapPropertyValue';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/response/response.ts": "import { OperationResponse } from '..';


/**
 * Helpers for constructing api responses
 */
export class Response {
  /**
   * A successful response
   */
  public static success = <T>(
    body: T
  ): OperationResponse<200, T> => ({
    statusCode: 200,
    body,
  });

  /**
   * A response which indicates a client error
   */
  public static badRequest = <T>(
    body: T
  ): OperationResponse<400, T> => ({
    statusCode: 400,
    body,
  });

  /**
   * A response which indicates the requested resource was not found
   */
  public static notFound = <T>(
    body: T
  ): OperationResponse<404, T> => ({
    statusCode: 404,
    body,
  });

  /**
   * A response which indicates the caller is not authorised to perform the operation or access the resource
   */
  public static notAuthorized = <T>(
    body: T
  ): OperationResponse<403, T> => ({
    statusCode: 403,
    body,
  });

  /**
   * A response to indicate a server error
   */
  public static internalFailure = <T>(
    body: T
  ): OperationResponse<500, T> => ({
    statusCode: 500,
    body,
  });
}
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */

export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
}
`;
