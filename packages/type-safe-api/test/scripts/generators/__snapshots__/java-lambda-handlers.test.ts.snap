// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Java Handlers Code Generation Script Unit Tests Generates With handlers.yaml 1`] = `
"package test.test-handlers.handlers;

import test.test-runtime.runtime.api.interceptors.DefaultInterceptors;
import test.test-runtime.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test-runtime.runtime.api.Handlers.Interceptor;
import test.test-runtime.runtime.api.Handlers.JavaOne;
import test.test-runtime.runtime.api.Handlers.JavaOneInput;
import test.test-runtime.runtime.api.Handlers.JavaOne500Response;
import test.test-runtime.runtime.api.Handlers.JavaOneRequestInput;
import test.test-runtime.runtime.api.Handlers.JavaOneResponse;
import test.test-runtime.runtime.model.*;

import java.util.List;

/**
 * Entry point for the AWS Lambda handler for the JavaOne operation.
 * The JavaOne class manages marshalling inputs and outputs.
 */
public class JavaOneHandler extends JavaOne {
    /**
     * Return the interceptors for this handler.
     * You can also use the @Interceptors annotation on the class to add interceptors
     */
    @Override
    public List<Interceptor<JavaOneInput>> getInterceptors() {
        return DefaultInterceptors.all();
    }

    /**
     * Type-safe handler for the JavaOne operation
     */
    @Override
    public JavaOneResponse handle(final JavaOneRequestInput request) {
        LoggingInterceptor.getLogger(request).info("Start JavaOne Operation");

        // TODO: Implement JavaOne Operation. \`input\` contains the request input.
        JavaOneInput input = request.getInput();

        return JavaOne500Response.of(InternalFailureErrorResponseContent.builder()
                .message("Not Implemented!")
                .build());
    }
}

"
`;

exports[`Java Handlers Code Generation Script Unit Tests Generates With handlers.yaml 2`] = `
"package test.test-handlers.handlers;

import test.test-runtime.runtime.api.interceptors.DefaultInterceptors;
import test.test-runtime.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test-runtime.runtime.api.Handlers.Interceptor;
import test.test-runtime.runtime.api.Handlers.JavaTwo;
import test.test-runtime.runtime.api.Handlers.JavaTwoInput;
import test.test-runtime.runtime.api.Handlers.JavaTwo500Response;
import test.test-runtime.runtime.api.Handlers.JavaTwoRequestInput;
import test.test-runtime.runtime.api.Handlers.JavaTwoResponse;
import test.test-runtime.runtime.model.*;

import java.util.List;

/**
 * Entry point for the AWS Lambda handler for the JavaTwo operation.
 * The JavaTwo class manages marshalling inputs and outputs.
 */
public class JavaTwoHandler extends JavaTwo {
    /**
     * Return the interceptors for this handler.
     * You can also use the @Interceptors annotation on the class to add interceptors
     */
    @Override
    public List<Interceptor<JavaTwoInput>> getInterceptors() {
        return DefaultInterceptors.all();
    }

    /**
     * Type-safe handler for the JavaTwo operation
     */
    @Override
    public JavaTwoResponse handle(final JavaTwoRequestInput request) {
        LoggingInterceptor.getLogger(request).info("Start JavaTwo Operation");

        // TODO: Implement JavaTwo Operation. \`input\` contains the request input.
        JavaTwoInput input = request.getInput();

        return JavaTwo500Response.of(InternalFailureErrorResponseContent.builder()
                .message("Not Implemented!")
                .build());
    }
}



"
`;
