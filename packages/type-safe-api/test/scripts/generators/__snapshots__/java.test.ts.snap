// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Java Client Code Generation Script Unit Tests Generates With allof-model.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/Template.java
src/main/java/test/test/runtime/model/TemplateBase.java
src/main/java/test/test/runtime/model/TemplateBody.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.Template.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TemplateBase.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TemplateBody.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.Template;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call sayHelloCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/hello";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call sayHelloValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return sayHelloCall(_callback);

    }

    private ApiResponse<Template> sayHelloWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<Template>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call sayHelloAsync(final ApiCallback<Template> _callback) throws ApiException {

        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<Template>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIsayHelloRequest {

        private APIsayHelloRequest() {
        }

        /**
         * Build call for sayHello
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return sayHelloCall(_callback);
        }

        /**
         * Execute sayHello request
         * @return Template
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public Template execute() throws ApiException {
            ApiResponse<Template> localVarResp = sayHelloWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute sayHello request with HTTP info returned
         * @return ApiResponse&lt;Template&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Template> executeWithHttpInfo() throws ApiException {
            return sayHelloWithHttpInfo();
        }

        /**
         * Execute sayHello request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Template> _callback) throws ApiException {
            return sayHelloAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIsayHelloRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIsayHelloRequest sayHello() {
        return new APIsayHelloRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.say_hello.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String sayHelloMethodAndPath = Handlers.concatMethodAndPath("GET", "/hello");

    private final SayHello constructedSayHello;

    /**
     * This method must return your implementation of the SayHello operation
     */
    public abstract SayHello sayHello();

    private static enum Route {
        sayHelloRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(sayHelloMethodAndPath, Route.sayHelloRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedSayHello = this.sayHello();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case sayHelloRoute:
                List<Interceptor<SayHelloInput>> sayHelloInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                sayHelloInterceptors.addAll(this.getInterceptors());
                return this.constructedSayHello.handleRequestWithAdditionalInterceptors(event, context, sayHelloInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the sayHello operation
 */
public abstract class SayHello implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the sayHello operation
     */
    public abstract SayHelloResponse handle(final SayHelloRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<SayHelloInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(SayHello.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<SayHelloInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<SayHelloInput>> getHandlerInterceptors() {
        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<SayHelloInput> buildChain(List<Interceptor<SayHelloInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<SayHelloInput>() {
            @Override
            public Response next(ChainedRequestInput<SayHelloInput> input) {
                return handle(new SayHelloRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<SayHelloInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final SayHelloInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<SayHelloInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public SayHelloInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new SayHelloInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<SayHelloInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "sayHello");

        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        SayHelloInput input;

        try {
            input = new SayHelloInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the sayHello operation
 */
public class SayHello200Response extends RuntimeException implements SayHelloResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final Template typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private SayHello200Response(final Template body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public Template getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a SayHello200Response with a body
     */
    public static SayHello200Response of(final Template body) {
        return new SayHello200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body and headers
     */
    public static SayHello200Response of(final Template body, final Map<String, String> headers) {
        return new SayHello200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body, headers and multi-value headers
     */
    public static SayHello200Response of(final Template body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new SayHello200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the sayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final SayHelloRequestParameters requestParameters;

    public SayHelloInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new SayHelloRequestParameters(event);
    }

    public SayHelloRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the sayHello operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestInput implements RequestInput<SayHelloInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final SayHelloInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public SayHelloInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the SayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestParameters {

    public SayHelloRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the sayHello operation
 */
public interface SayHelloResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T sayHello;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("sayHello", this.sayHello);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("sayHello", OperationLookupEntry.builder()
            .path("/hello")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .sayHello(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/Template.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Template
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class Template {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_PARENT_ID = "parent_id";
  @SerializedName(SERIALIZED_NAME_PARENT_ID)
  private UUID parentId;

  public static final String SERIALIZED_NAME_BOOLEAN = "boolean";
  @SerializedName(SERIALIZED_NAME_BOOLEAN)
  private Boolean _boolean;

  public Template() {
  }

  public Template id(UUID id) {

    this.id = id;
    return this;
  }

   /**
   * The unique identifier for a template.
   * @return id
  **/
  @javax.annotation.Nonnull
  public UUID getId() {
    return id;
  }


  public void setId(UUID id) {
    this.id = id;
  }

  public Template parentId(UUID parentId) {

    this.parentId = parentId;
    return this;
  }

   /**
   * The unique identifier for a template.
   * @return parentId
  **/
  @javax.annotation.Nullable
  public UUID getParentId() {
    return parentId;
  }


  public void setParentId(UUID parentId) {
    this.parentId = parentId;
  }

  public Template _boolean(Boolean _boolean) {

    this._boolean = _boolean;
    return this;
  }

   /**
   * A boolean value.
   * @return _boolean
  **/
  @javax.annotation.Nullable
  public Boolean getBoolean() {
    return _boolean;
  }


  public void setBoolean(Boolean _boolean) {
    this._boolean = _boolean;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Template template = (Template) o;
    return Objects.equals(this.id, template.id) &&
        Objects.equals(this.parentId, template.parentId) &&
        Objects.equals(this._boolean, template._boolean);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, parentId, _boolean);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Template {\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\\n");
    sb.append("    _boolean: ").append(toIndentedString(_boolean)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("parent_id");
    openapiFields.add("boolean");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Template
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Template.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Template is not found in the empty JSON string", Template.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!Template.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`Template\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Template.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("parent_id") != null && !jsonObj.get("parent_id").isJsonNull()) && !jsonObj.get("parent_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`parent_id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("parent_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Template.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Template' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Template> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Template.class));

       return (TypeAdapter<T>) new TypeAdapter<Template>() {
           @Override
           public void write(JsonWriter out, Template value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Template read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Template given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Template
  * @throws IOException if the JSON string is invalid with respect to Template
  */
  public static Template fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Template.class);
  }

 /**
  * Convert an instance of Template to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/TemplateBase.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Represents the base properties of a template.

 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class TemplateBase {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public TemplateBase() {
  }

  public TemplateBase id(UUID id) {

    this.id = id;
    return this;
  }

   /**
   * The unique identifier for a template.
   * @return id
  **/
  @javax.annotation.Nonnull
  public UUID getId() {
    return id;
  }


  public void setId(UUID id) {
    this.id = id;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TemplateBase templateBase = (TemplateBase) o;
    return Objects.equals(this.id, templateBase.id);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(id);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TemplateBase {\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TemplateBase
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TemplateBase.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TemplateBase is not found in the empty JSON string", TemplateBase.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TemplateBase.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TemplateBase\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TemplateBase.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TemplateBase.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TemplateBase' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TemplateBase> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TemplateBase.class));

       return (TypeAdapter<T>) new TypeAdapter<TemplateBase>() {
           @Override
           public void write(JsonWriter out, TemplateBase value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TemplateBase read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TemplateBase given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TemplateBase
  * @throws IOException if the JSON string is invalid with respect to TemplateBase
  */
  public static TemplateBase fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TemplateBase.class);
  }

 /**
  * Convert an instance of TemplateBase to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/TemplateBody.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Represents the body of a template.

 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class TemplateBody {
  public static final String SERIALIZED_NAME_PARENT_ID = "parent_id";
  @SerializedName(SERIALIZED_NAME_PARENT_ID)
  private UUID parentId;

  public static final String SERIALIZED_NAME_BOOLEAN = "boolean";
  @SerializedName(SERIALIZED_NAME_BOOLEAN)
  private Boolean _boolean;

  public TemplateBody() {
  }

  public TemplateBody parentId(UUID parentId) {

    this.parentId = parentId;
    return this;
  }

   /**
   * The unique identifier for a template.
   * @return parentId
  **/
  @javax.annotation.Nullable
  public UUID getParentId() {
    return parentId;
  }


  public void setParentId(UUID parentId) {
    this.parentId = parentId;
  }

  public TemplateBody _boolean(Boolean _boolean) {

    this._boolean = _boolean;
    return this;
  }

   /**
   * A boolean value.
   * @return _boolean
  **/
  @javax.annotation.Nullable
  public Boolean getBoolean() {
    return _boolean;
  }


  public void setBoolean(Boolean _boolean) {
    this._boolean = _boolean;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TemplateBody templateBody = (TemplateBody) o;
    return Objects.equals(this.parentId, templateBody.parentId) &&
        Objects.equals(this._boolean, templateBody._boolean);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(parentId, _boolean);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TemplateBody {\\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\\n");
    sb.append("    _boolean: ").append(toIndentedString(_boolean)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("parent_id");
    openapiFields.add("boolean");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TemplateBody
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TemplateBody.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TemplateBody is not found in the empty JSON string", TemplateBody.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TemplateBody.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TemplateBody\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("parent_id") != null && !jsonObj.get("parent_id").isJsonNull()) && !jsonObj.get("parent_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`parent_id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("parent_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TemplateBody.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TemplateBody' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TemplateBody> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TemplateBody.class));

       return (TypeAdapter<T>) new TypeAdapter<TemplateBody>() {
           @Override
           public void write(JsonWriter out, TemplateBody value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TemplateBody read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TemplateBody given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TemplateBody
  * @throws IOException if the JSON string is invalid with respect to TemplateBody
  */
  public static TemplateBody fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TemplateBody.class);
  }

 /**
  * Convert an instance of TemplateBody to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With composite-models.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGetResponse.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGet200Response.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGetRequestParameters.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGetInput.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGetRequestInput.java
src/main/java/test/test/runtime/api/handlers/op_get/OpGet.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/A.java
src/main/java/test/test/runtime/model/AllOfInlineAndRefs.java
src/main/java/test/test/runtime/model/AllOfRefs.java
src/main/java/test/test/runtime/model/AnyOfInlineAndRefs.java
src/main/java/test/test/runtime/model/AnyOfInlineAndRefsAnyOf.java
src/main/java/test/test/runtime/model/AnyOfInlineAndRefsAnyOf1.java
src/main/java/test/test/runtime/model/AnyOfPrimitives.java
src/main/java/test/test/runtime/model/AnyOfPrimitivesAndRefs.java
src/main/java/test/test/runtime/model/AnyOfRefs.java
src/main/java/test/test/runtime/model/B.java
src/main/java/test/test/runtime/model/C.java
src/main/java/test/test/runtime/model/OneOfInlineAndRefs.java
src/main/java/test/test/runtime/model/OneOfInlineAndRefsOneOf.java
src/main/java/test/test/runtime/model/OneOfInlineAndRefsOneOf1.java
src/main/java/test/test/runtime/model/OneOfPrimitives.java
src/main/java/test/test/runtime/model/OneOfPrimitivesAndRefs.java
src/main/java/test/test/runtime/model/OneOfRefs.java
src/main/java/test/test/runtime/model/Wrapper.java
src/main/java/test/test/runtime/model/WrapperAllOf.java
src/main/java/test/test/runtime/model/WrapperAnyOf.java
src/main/java/test/test/runtime/model/WrapperOneOf.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.A.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AllOfInlineAndRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AllOfInlineAndRefsAllOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AllOfInlineAndRefsAllOf1.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AllOfRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfInlineAndRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfInlineAndRefsAnyOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfInlineAndRefsAnyOf1.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfPrimitives.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfPrimitivesAndRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.AnyOfRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.B.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.C.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfInlineAndRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfInlineAndRefsOneOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfInlineAndRefsOneOf1.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfPrimitives.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfPrimitivesAndRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.OneOfRefs.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.Wrapper.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.WrapperAllOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.WrapperAnyOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.WrapperOneOf.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.Wrapper;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call opGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/op";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call opGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return opGetCall(_callback);

    }

    private ApiResponse<Wrapper> opGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = opGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<Wrapper>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call opGetAsync(final ApiCallback<Wrapper> _callback) throws ApiException {

        okhttp3.Call localVarCall = opGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<Wrapper>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIopGetRequest {

        private APIopGetRequest() {
        }

        /**
         * Build call for opGet
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return opGetCall(_callback);
        }

        /**
         * Execute opGet request
         * @return Wrapper
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public Wrapper execute() throws ApiException {
            ApiResponse<Wrapper> localVarResp = opGetWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute opGet request with HTTP info returned
         * @return ApiResponse&lt;Wrapper&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Wrapper> executeWithHttpInfo() throws ApiException {
            return opGetWithHttpInfo();
        }

        /**
         * Execute opGet request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Wrapper> _callback) throws ApiException {
            return opGetAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIopGetRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIopGetRequest opGet() {
        return new APIopGetRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.op_get.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String opGetMethodAndPath = Handlers.concatMethodAndPath("GET", "/op");

    private final OpGet constructedOpGet;

    /**
     * This method must return your implementation of the OpGet operation
     */
    public abstract OpGet opGet();

    private static enum Route {
        opGetRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(opGetMethodAndPath, Route.opGetRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedOpGet = this.opGet();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case opGetRoute:
                List<Interceptor<OpGetInput>> opGetInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                opGetInterceptors.addAll(this.getInterceptors());
                return this.constructedOpGet.handleRequestWithAdditionalInterceptors(event, context, opGetInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGet.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the opGet operation
 */
public abstract class OpGet implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the opGet operation
     */
    public abstract OpGetResponse handle(final OpGetRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<OpGetInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(OpGet.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<OpGetInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<OpGetInput>> getHandlerInterceptors() {
        List<Interceptor<OpGetInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<OpGetInput> buildChain(List<Interceptor<OpGetInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<OpGetInput>() {
            @Override
            public Response next(ChainedRequestInput<OpGetInput> input) {
                return handle(new OpGetRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<OpGetInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final OpGetInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<OpGetInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public OpGetInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new OpGetInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<OpGetInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "opGet");

        List<Interceptor<OpGetInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        OpGetInput input;

        try {
            input = new OpGetInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGet200Response.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the opGet operation
 */
public class OpGet200Response extends RuntimeException implements OpGetResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final Wrapper typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private OpGet200Response(final Wrapper body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public Wrapper getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a OpGet200Response with a body
     */
    public static OpGet200Response of(final Wrapper body) {
        return new OpGet200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a OpGet200Response with a body and headers
     */
    public static OpGet200Response of(final Wrapper body, final Map<String, String> headers) {
        return new OpGet200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a OpGet200Response with a body, headers and multi-value headers
     */
    public static OpGet200Response of(final Wrapper body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new OpGet200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGetInput.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the opGet operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OpGetInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final OpGetRequestParameters requestParameters;

    public OpGetInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new OpGetRequestParameters(event);
    }

    public OpGetRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGetRequestInput.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the opGet operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OpGetRequestInput implements RequestInput<OpGetInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final OpGetInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public OpGetInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGetRequestParameters.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the OpGet operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OpGetRequestParameters {

    public OpGetRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/op_get/OpGetResponse.java": "
package test.test.runtime.api.handlers.op_get;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the opGet operation
 */
public interface OpGetResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T opGet;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("opGet", this.opGet);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("opGet", OperationLookupEntry.builder()
            .path("/op")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .opGet(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/A.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * A
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class A {
  public static final String SERIALIZED_NAME_A = "a";
  @SerializedName(SERIALIZED_NAME_A)
  private String a;

  public A() {
  }

  public A a(String a) {

    this.a = a;
    return this;
  }

   /**
   * Get a
   * @return a
  **/
  @javax.annotation.Nonnull
  public String getA() {
    return a;
  }


  public void setA(String a) {
    this.a = a;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    A a = (A) o;
    return Objects.equals(this.a, a.a);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(a);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class A {\\n");
    sb.append("    a: ").append(toIndentedString(a)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("a");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("a");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to A
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!A.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in A is not found in the empty JSON string", A.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!A.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`A\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : A.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("a").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`a\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("a").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!A.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'A' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<A> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(A.class));

       return (TypeAdapter<T>) new TypeAdapter<A>() {
           @Override
           public void write(JsonWriter out, A value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public A read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of A given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of A
  * @throws IOException if the JSON string is invalid with respect to A
  */
  public static A fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, A.class);
  }

 /**
  * Convert an instance of A to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/AllOfInlineAndRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * AllOfInlineAndRefs
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class AllOfInlineAndRefs {
  public static final String SERIALIZED_NAME_D = "d";
  @SerializedName(SERIALIZED_NAME_D)
  private String d;

  public static final String SERIALIZED_NAME_A = "a";
  @SerializedName(SERIALIZED_NAME_A)
  private String a;

  public static final String SERIALIZED_NAME_B = "b";
  @SerializedName(SERIALIZED_NAME_B)
  private String b;

  public static final String SERIALIZED_NAME_C = "c";
  @SerializedName(SERIALIZED_NAME_C)
  private String c;

  public static final String SERIALIZED_NAME_E = "e";
  @SerializedName(SERIALIZED_NAME_E)
  private String e;

  public AllOfInlineAndRefs() {
  }

  public AllOfInlineAndRefs d(String d) {

    this.d = d;
    return this;
  }

   /**
   * Get d
   * @return d
  **/
  @javax.annotation.Nonnull
  public String getD() {
    return d;
  }


  public void setD(String d) {
    this.d = d;
  }

  public AllOfInlineAndRefs a(String a) {

    this.a = a;
    return this;
  }

   /**
   * Get a
   * @return a
  **/
  @javax.annotation.Nonnull
  public String getA() {
    return a;
  }


  public void setA(String a) {
    this.a = a;
  }

  public AllOfInlineAndRefs b(String b) {

    this.b = b;
    return this;
  }

   /**
   * Get b
   * @return b
  **/
  @javax.annotation.Nonnull
  public String getB() {
    return b;
  }


  public void setB(String b) {
    this.b = b;
  }

  public AllOfInlineAndRefs c(String c) {

    this.c = c;
    return this;
  }

   /**
   * Get c
   * @return c
  **/
  @javax.annotation.Nonnull
  public String getC() {
    return c;
  }


  public void setC(String c) {
    this.c = c;
  }

  public AllOfInlineAndRefs e(String e) {

    this.e = e;
    return this;
  }

   /**
   * Get e
   * @return e
  **/
  @javax.annotation.Nullable
  public String getE() {
    return e;
  }


  public void setE(String e) {
    this.e = e;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AllOfInlineAndRefs allOfInlineAndRefs = (AllOfInlineAndRefs) o;
    return Objects.equals(this.d, allOfInlineAndRefs.d) &&
        Objects.equals(this.a, allOfInlineAndRefs.a) &&
        Objects.equals(this.b, allOfInlineAndRefs.b) &&
        Objects.equals(this.c, allOfInlineAndRefs.c) &&
        Objects.equals(this.e, allOfInlineAndRefs.e);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(d, a, b, c, e);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AllOfInlineAndRefs {\\n");
    sb.append("    d: ").append(toIndentedString(d)).append("\\n");
    sb.append("    a: ").append(toIndentedString(a)).append("\\n");
    sb.append("    b: ").append(toIndentedString(b)).append("\\n");
    sb.append("    c: ").append(toIndentedString(c)).append("\\n");
    sb.append("    e: ").append(toIndentedString(e)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("d");
    openapiFields.add("a");
    openapiFields.add("b");
    openapiFields.add("c");
    openapiFields.add("e");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("d");
    openapiRequiredFields.add("a");
    openapiRequiredFields.add("b");
    openapiRequiredFields.add("c");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AllOfInlineAndRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AllOfInlineAndRefs.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AllOfInlineAndRefs is not found in the empty JSON string", AllOfInlineAndRefs.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!AllOfInlineAndRefs.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`AllOfInlineAndRefs\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AllOfInlineAndRefs.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("d").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`d\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("d").toString()));
      }
      if (!jsonObj.get("a").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`a\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("a").toString()));
      }
      if (!jsonObj.get("b").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`b\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("b").toString()));
      }
      if (!jsonObj.get("c").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`c\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("c").toString()));
      }
      if ((jsonObj.get("e") != null && !jsonObj.get("e").isJsonNull()) && !jsonObj.get("e").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`e\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("e").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AllOfInlineAndRefs.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AllOfInlineAndRefs' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AllOfInlineAndRefs> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AllOfInlineAndRefs.class));

       return (TypeAdapter<T>) new TypeAdapter<AllOfInlineAndRefs>() {
           @Override
           public void write(JsonWriter out, AllOfInlineAndRefs value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AllOfInlineAndRefs read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AllOfInlineAndRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AllOfInlineAndRefs
  * @throws IOException if the JSON string is invalid with respect to AllOfInlineAndRefs
  */
  public static AllOfInlineAndRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AllOfInlineAndRefs.class);
  }

 /**
  * Convert an instance of AllOfInlineAndRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/AllOfRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * AllOfRefs
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class AllOfRefs {
  public static final String SERIALIZED_NAME_A = "a";
  @SerializedName(SERIALIZED_NAME_A)
  private String a;

  public static final String SERIALIZED_NAME_B = "b";
  @SerializedName(SERIALIZED_NAME_B)
  private String b;

  public static final String SERIALIZED_NAME_C = "c";
  @SerializedName(SERIALIZED_NAME_C)
  private String c;

  public AllOfRefs() {
  }

  public AllOfRefs a(String a) {

    this.a = a;
    return this;
  }

   /**
   * Get a
   * @return a
  **/
  @javax.annotation.Nonnull
  public String getA() {
    return a;
  }


  public void setA(String a) {
    this.a = a;
  }

  public AllOfRefs b(String b) {

    this.b = b;
    return this;
  }

   /**
   * Get b
   * @return b
  **/
  @javax.annotation.Nonnull
  public String getB() {
    return b;
  }


  public void setB(String b) {
    this.b = b;
  }

  public AllOfRefs c(String c) {

    this.c = c;
    return this;
  }

   /**
   * Get c
   * @return c
  **/
  @javax.annotation.Nonnull
  public String getC() {
    return c;
  }


  public void setC(String c) {
    this.c = c;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AllOfRefs allOfRefs = (AllOfRefs) o;
    return Objects.equals(this.a, allOfRefs.a) &&
        Objects.equals(this.b, allOfRefs.b) &&
        Objects.equals(this.c, allOfRefs.c);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(a, b, c);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AllOfRefs {\\n");
    sb.append("    a: ").append(toIndentedString(a)).append("\\n");
    sb.append("    b: ").append(toIndentedString(b)).append("\\n");
    sb.append("    c: ").append(toIndentedString(c)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("a");
    openapiFields.add("b");
    openapiFields.add("c");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("a");
    openapiRequiredFields.add("b");
    openapiRequiredFields.add("c");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AllOfRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AllOfRefs.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AllOfRefs is not found in the empty JSON string", AllOfRefs.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!AllOfRefs.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`AllOfRefs\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AllOfRefs.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("a").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`a\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("a").toString()));
      }
      if (!jsonObj.get("b").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`b\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("b").toString()));
      }
      if (!jsonObj.get("c").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`c\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("c").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AllOfRefs.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AllOfRefs' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AllOfRefs> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AllOfRefs.class));

       return (TypeAdapter<T>) new TypeAdapter<AllOfRefs>() {
           @Override
           public void write(JsonWriter out, AllOfRefs value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AllOfRefs read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AllOfRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AllOfRefs
  * @throws IOException if the JSON string is invalid with respect to AllOfRefs
  */
  public static AllOfRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AllOfRefs.class);
  }

 /**
  * Convert an instance of AllOfRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/AnyOfInlineAndRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import test.test.runtime.model.AnyOfInlineAndRefsAnyOf;
import test.test.runtime.model.AnyOfInlineAndRefsAnyOf1;
import test.test.runtime.model.B;
import test.test.runtime.model.C;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class AnyOfInlineAndRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(AnyOfInlineAndRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!AnyOfInlineAndRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'AnyOfInlineAndRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<AnyOfInlineAndRefsAnyOf> adapterAnyOfInlineAndRefsAnyOf = gson.getDelegateAdapter(this, TypeToken.get(AnyOfInlineAndRefsAnyOf.class));
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));
            final TypeAdapter<B> adapterB = gson.getDelegateAdapter(this, TypeToken.get(B.class));
            final TypeAdapter<C> adapterC = gson.getDelegateAdapter(this, TypeToken.get(C.class));
            final TypeAdapter<AnyOfInlineAndRefsAnyOf1> adapterAnyOfInlineAndRefsAnyOf1 = gson.getDelegateAdapter(this, TypeToken.get(AnyOfInlineAndRefsAnyOf1.class));

            return (TypeAdapter<T>) new TypeAdapter<AnyOfInlineAndRefs>() {
                @Override
                public void write(JsonWriter out, AnyOfInlineAndRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`AnyOfInlineAndRefsAnyOf\`
                    if (value.getActualInstance() instanceof AnyOfInlineAndRefsAnyOf) {
                        JsonObject obj = adapterAnyOfInlineAndRefsAnyOf.toJsonTree((AnyOfInlineAndRefsAnyOf)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`B\`
                    if (value.getActualInstance() instanceof B) {
                        JsonObject obj = adapterB.toJsonTree((B)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`C\`
                    if (value.getActualInstance() instanceof C) {
                        JsonObject obj = adapterC.toJsonTree((C)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`AnyOfInlineAndRefsAnyOf1\`
                    if (value.getActualInstance() instanceof AnyOfInlineAndRefsAnyOf1) {
                        JsonObject obj = adapterAnyOfInlineAndRefsAnyOf1.toJsonTree((AnyOfInlineAndRefsAnyOf1)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1");
                }

                @Override
                public AnyOfInlineAndRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();


                    // deserialize AnyOfInlineAndRefsAnyOf
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AnyOfInlineAndRefsAnyOf.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'AnyOfInlineAndRefsAnyOf'");
                        AnyOfInlineAndRefs ret = new AnyOfInlineAndRefs();
                        ret.setActualInstance(adapterAnyOfInlineAndRefsAnyOf.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'AnyOfInlineAndRefsAnyOf'", e);
                    }

                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'A'");
                        AnyOfInlineAndRefs ret = new AnyOfInlineAndRefs();
                        ret.setActualInstance(adapterA.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }

                    // deserialize B
                    try {
                        // validate the JSON object to see if any exception is thrown
                        B.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'B'");
                        AnyOfInlineAndRefs ret = new AnyOfInlineAndRefs();
                        ret.setActualInstance(adapterB.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'B'", e);
                    }

                    // deserialize C
                    try {
                        // validate the JSON object to see if any exception is thrown
                        C.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'C'");
                        AnyOfInlineAndRefs ret = new AnyOfInlineAndRefs();
                        ret.setActualInstance(adapterC.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'C'", e);
                    }

                    // deserialize AnyOfInlineAndRefsAnyOf1
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AnyOfInlineAndRefsAnyOf1.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'AnyOfInlineAndRefsAnyOf1'");
                        AnyOfInlineAndRefs ret = new AnyOfInlineAndRefs();
                        ret.setActualInstance(adapterAnyOfInlineAndRefsAnyOf1.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'AnyOfInlineAndRefsAnyOf1'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for AnyOfInlineAndRefs: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public AnyOfInlineAndRefs() {
        super("anyOf", Boolean.FALSE);
    }

    public AnyOfInlineAndRefs(AnyOfInlineAndRefsAnyOf o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfInlineAndRefs(A o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfInlineAndRefs(B o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfInlineAndRefs(C o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfInlineAndRefs(AnyOfInlineAndRefsAnyOf1 o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AnyOfInlineAndRefsAnyOf", new GenericType<AnyOfInlineAndRefsAnyOf>() {
        });
        schemas.put("A", new GenericType<A>() {
        });
        schemas.put("B", new GenericType<B>() {
        });
        schemas.put("C", new GenericType<C>() {
        });
        schemas.put("AnyOfInlineAndRefsAnyOf1", new GenericType<AnyOfInlineAndRefsAnyOf1>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return AnyOfInlineAndRefs.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof AnyOfInlineAndRefsAnyOf) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof B) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof C) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof AnyOfInlineAndRefsAnyOf1) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1");
    }

    /**
     * Get the actual instance, which can be the following:
     * AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1
     *
     * @return The actual instance (AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`AnyOfInlineAndRefsAnyOf\`. If the actual instance is not \`AnyOfInlineAndRefsAnyOf\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`AnyOfInlineAndRefsAnyOf\`
     * @throws ClassCastException if the instance is not \`AnyOfInlineAndRefsAnyOf\`
     */
    public AnyOfInlineAndRefsAnyOf getAnyOfInlineAndRefsAnyOf() throws ClassCastException {
        return (AnyOfInlineAndRefsAnyOf)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`B\`. If the actual instance is not \`B\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`B\`
     * @throws ClassCastException if the instance is not \`B\`
     */
    public B getB() throws ClassCastException {
        return (B)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`C\`. If the actual instance is not \`C\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`C\`
     * @throws ClassCastException if the instance is not \`C\`
     */
    public C getC() throws ClassCastException {
        return (C)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`AnyOfInlineAndRefsAnyOf1\`. If the actual instance is not \`AnyOfInlineAndRefsAnyOf1\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`AnyOfInlineAndRefsAnyOf1\`
     * @throws ClassCastException if the instance is not \`AnyOfInlineAndRefsAnyOf1\`
     */
    public AnyOfInlineAndRefsAnyOf1 getAnyOfInlineAndRefsAnyOf1() throws ClassCastException {
        return (AnyOfInlineAndRefsAnyOf1)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfInlineAndRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with AnyOfInlineAndRefsAnyOf
    try {
      AnyOfInlineAndRefsAnyOf.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with B
    try {
      B.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with C
    try {
      C.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with AnyOfInlineAndRefsAnyOf1
    try {
      AnyOfInlineAndRefsAnyOf1.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for AnyOfInlineAndRefs with anyOf schemas: AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of AnyOfInlineAndRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfInlineAndRefs
  * @throws IOException if the JSON string is invalid with respect to AnyOfInlineAndRefs
  */
  public static AnyOfInlineAndRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfInlineAndRefs.class);
  }

 /**
  * Convert an instance of AnyOfInlineAndRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/AnyOfInlineAndRefsAnyOf.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * AnyOfInlineAndRefsAnyOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class AnyOfInlineAndRefsAnyOf {
  public static final String SERIALIZED_NAME_D = "d";
  @SerializedName(SERIALIZED_NAME_D)
  private String d;

  public AnyOfInlineAndRefsAnyOf() {
  }

  public AnyOfInlineAndRefsAnyOf d(String d) {

    this.d = d;
    return this;
  }

   /**
   * Get d
   * @return d
  **/
  @javax.annotation.Nonnull
  public String getD() {
    return d;
  }


  public void setD(String d) {
    this.d = d;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AnyOfInlineAndRefsAnyOf anyOfInlineAndRefsAnyOf = (AnyOfInlineAndRefsAnyOf) o;
    return Objects.equals(this.d, anyOfInlineAndRefsAnyOf.d);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(d);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AnyOfInlineAndRefsAnyOf {\\n");
    sb.append("    d: ").append(toIndentedString(d)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("d");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("d");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfInlineAndRefsAnyOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AnyOfInlineAndRefsAnyOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AnyOfInlineAndRefsAnyOf is not found in the empty JSON string", AnyOfInlineAndRefsAnyOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!AnyOfInlineAndRefsAnyOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`AnyOfInlineAndRefsAnyOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AnyOfInlineAndRefsAnyOf.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("d").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`d\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("d").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AnyOfInlineAndRefsAnyOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AnyOfInlineAndRefsAnyOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AnyOfInlineAndRefsAnyOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AnyOfInlineAndRefsAnyOf.class));

       return (TypeAdapter<T>) new TypeAdapter<AnyOfInlineAndRefsAnyOf>() {
           @Override
           public void write(JsonWriter out, AnyOfInlineAndRefsAnyOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AnyOfInlineAndRefsAnyOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AnyOfInlineAndRefsAnyOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfInlineAndRefsAnyOf
  * @throws IOException if the JSON string is invalid with respect to AnyOfInlineAndRefsAnyOf
  */
  public static AnyOfInlineAndRefsAnyOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfInlineAndRefsAnyOf.class);
  }

 /**
  * Convert an instance of AnyOfInlineAndRefsAnyOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/AnyOfInlineAndRefsAnyOf1.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * AnyOfInlineAndRefsAnyOf1
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class AnyOfInlineAndRefsAnyOf1 {
  public static final String SERIALIZED_NAME_E = "e";
  @SerializedName(SERIALIZED_NAME_E)
  private String e;

  public AnyOfInlineAndRefsAnyOf1() {
  }

  public AnyOfInlineAndRefsAnyOf1 e(String e) {

    this.e = e;
    return this;
  }

   /**
   * Get e
   * @return e
  **/
  @javax.annotation.Nullable
  public String getE() {
    return e;
  }


  public void setE(String e) {
    this.e = e;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AnyOfInlineAndRefsAnyOf1 anyOfInlineAndRefsAnyOf1 = (AnyOfInlineAndRefsAnyOf1) o;
    return Objects.equals(this.e, anyOfInlineAndRefsAnyOf1.e);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(e);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AnyOfInlineAndRefsAnyOf1 {\\n");
    sb.append("    e: ").append(toIndentedString(e)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("e");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfInlineAndRefsAnyOf1
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!AnyOfInlineAndRefsAnyOf1.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AnyOfInlineAndRefsAnyOf1 is not found in the empty JSON string", AnyOfInlineAndRefsAnyOf1.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!AnyOfInlineAndRefsAnyOf1.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`AnyOfInlineAndRefsAnyOf1\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("e") != null && !jsonObj.get("e").isJsonNull()) && !jsonObj.get("e").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`e\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("e").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AnyOfInlineAndRefsAnyOf1.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AnyOfInlineAndRefsAnyOf1' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AnyOfInlineAndRefsAnyOf1> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AnyOfInlineAndRefsAnyOf1.class));

       return (TypeAdapter<T>) new TypeAdapter<AnyOfInlineAndRefsAnyOf1>() {
           @Override
           public void write(JsonWriter out, AnyOfInlineAndRefsAnyOf1 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AnyOfInlineAndRefsAnyOf1 read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AnyOfInlineAndRefsAnyOf1 given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfInlineAndRefsAnyOf1
  * @throws IOException if the JSON string is invalid with respect to AnyOfInlineAndRefsAnyOf1
  */
  public static AnyOfInlineAndRefsAnyOf1 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfInlineAndRefsAnyOf1.class);
  }

 /**
  * Convert an instance of AnyOfInlineAndRefsAnyOf1 to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/AnyOfPrimitives.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class AnyOfPrimitives extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(AnyOfPrimitives.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!AnyOfPrimitives.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'AnyOfPrimitives' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<Integer> adapterInteger = gson.getDelegateAdapter(this, TypeToken.get(Integer.class));

            return (TypeAdapter<T>) new TypeAdapter<AnyOfPrimitives>() {
                @Override
                public void write(JsonWriter out, AnyOfPrimitives value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`Integer\`
                    if (value.getActualInstance() instanceof Integer) {
                        JsonObject obj = adapterInteger.toJsonTree((Integer)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, Integer");
                }

                @Override
                public AnyOfPrimitives read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();


                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'String'");
                        AnyOfPrimitives ret = new AnyOfPrimitives();
                        ret.setActualInstance(adapterString.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize Integer
                    try {
                        // validate the JSON object to see if any exception is thrown
                        Integer.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'Integer'");
                        AnyOfPrimitives ret = new AnyOfPrimitives();
                        ret.setActualInstance(adapterInteger.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'Integer'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for AnyOfPrimitives: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public AnyOfPrimitives() {
        super("anyOf", Boolean.FALSE);
    }

    public AnyOfPrimitives(String o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfPrimitives(Integer o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("Integer", new GenericType<Integer>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return AnyOfPrimitives.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * String, Integer
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof Integer) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, Integer");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, Integer
     *
     * @return The actual instance (String, Integer)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`Integer\`. If the actual instance is not \`Integer\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`Integer\`
     * @throws ClassCastException if the instance is not \`Integer\`
     */
    public Integer getInteger() throws ClassCastException {
        return (Integer)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfPrimitives
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with Integer
    try {
      Integer.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for AnyOfPrimitives with anyOf schemas: String, Integer. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of AnyOfPrimitives given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfPrimitives
  * @throws IOException if the JSON string is invalid with respect to AnyOfPrimitives
  */
  public static AnyOfPrimitives fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfPrimitives.class);
  }

 /**
  * Convert an instance of AnyOfPrimitives to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/AnyOfPrimitivesAndRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class AnyOfPrimitivesAndRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(AnyOfPrimitivesAndRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!AnyOfPrimitivesAndRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'AnyOfPrimitivesAndRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));

            return (TypeAdapter<T>) new TypeAdapter<AnyOfPrimitivesAndRefs>() {
                @Override
                public void write(JsonWriter out, AnyOfPrimitivesAndRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, A");
                }

                @Override
                public AnyOfPrimitivesAndRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();


                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'String'");
                        AnyOfPrimitivesAndRefs ret = new AnyOfPrimitivesAndRefs();
                        ret.setActualInstance(adapterString.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'A'");
                        AnyOfPrimitivesAndRefs ret = new AnyOfPrimitivesAndRefs();
                        ret.setActualInstance(adapterA.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for AnyOfPrimitivesAndRefs: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public AnyOfPrimitivesAndRefs() {
        super("anyOf", Boolean.FALSE);
    }

    public AnyOfPrimitivesAndRefs(String o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfPrimitivesAndRefs(A o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("A", new GenericType<A>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return AnyOfPrimitivesAndRefs.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * String, A
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, A");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, A
     *
     * @return The actual instance (String, A)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfPrimitivesAndRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for AnyOfPrimitivesAndRefs with anyOf schemas: String, A. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of AnyOfPrimitivesAndRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfPrimitivesAndRefs
  * @throws IOException if the JSON string is invalid with respect to AnyOfPrimitivesAndRefs
  */
  public static AnyOfPrimitivesAndRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfPrimitivesAndRefs.class);
  }

 /**
  * Convert an instance of AnyOfPrimitivesAndRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/AnyOfRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import test.test.runtime.model.B;
import test.test.runtime.model.C;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class AnyOfRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(AnyOfRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!AnyOfRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'AnyOfRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));
            final TypeAdapter<B> adapterB = gson.getDelegateAdapter(this, TypeToken.get(B.class));
            final TypeAdapter<C> adapterC = gson.getDelegateAdapter(this, TypeToken.get(C.class));

            return (TypeAdapter<T>) new TypeAdapter<AnyOfRefs>() {
                @Override
                public void write(JsonWriter out, AnyOfRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`B\`
                    if (value.getActualInstance() instanceof B) {
                        JsonObject obj = adapterB.toJsonTree((B)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`C\`
                    if (value.getActualInstance() instanceof C) {
                        JsonObject obj = adapterC.toJsonTree((C)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: A, B, C");
                }

                @Override
                public AnyOfRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();


                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'A'");
                        AnyOfRefs ret = new AnyOfRefs();
                        ret.setActualInstance(adapterA.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }

                    // deserialize B
                    try {
                        // validate the JSON object to see if any exception is thrown
                        B.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'B'");
                        AnyOfRefs ret = new AnyOfRefs();
                        ret.setActualInstance(adapterB.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'B'", e);
                    }

                    // deserialize C
                    try {
                        // validate the JSON object to see if any exception is thrown
                        C.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'C'");
                        AnyOfRefs ret = new AnyOfRefs();
                        ret.setActualInstance(adapterC.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'C'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for AnyOfRefs: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public AnyOfRefs() {
        super("anyOf", Boolean.FALSE);
    }

    public AnyOfRefs(A o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfRefs(B o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AnyOfRefs(C o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("A", new GenericType<A>() {
        });
        schemas.put("B", new GenericType<B>() {
        });
        schemas.put("C", new GenericType<C>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return AnyOfRefs.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * A, B, C
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof B) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof C) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be A, B, C");
    }

    /**
     * Get the actual instance, which can be the following:
     * A, B, C
     *
     * @return The actual instance (A, B, C)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`B\`. If the actual instance is not \`B\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`B\`
     * @throws ClassCastException if the instance is not \`B\`
     */
    public B getB() throws ClassCastException {
        return (B)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`C\`. If the actual instance is not \`C\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`C\`
     * @throws ClassCastException if the instance is not \`C\`
     */
    public C getC() throws ClassCastException {
        return (C)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AnyOfRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with B
    try {
      B.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with C
    try {
      C.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for AnyOfRefs with anyOf schemas: A, B, C. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of AnyOfRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AnyOfRefs
  * @throws IOException if the JSON string is invalid with respect to AnyOfRefs
  */
  public static AnyOfRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnyOfRefs.class);
  }

 /**
  * Convert an instance of AnyOfRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/B.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * B
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class B {
  public static final String SERIALIZED_NAME_B = "b";
  @SerializedName(SERIALIZED_NAME_B)
  private String b;

  public B() {
  }

  public B b(String b) {

    this.b = b;
    return this;
  }

   /**
   * Get b
   * @return b
  **/
  @javax.annotation.Nonnull
  public String getB() {
    return b;
  }


  public void setB(String b) {
    this.b = b;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    B b = (B) o;
    return Objects.equals(this.b, b.b);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(b);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class B {\\n");
    sb.append("    b: ").append(toIndentedString(b)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("b");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("b");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to B
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!B.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in B is not found in the empty JSON string", B.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!B.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`B\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : B.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("b").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`b\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("b").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!B.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'B' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<B> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(B.class));

       return (TypeAdapter<T>) new TypeAdapter<B>() {
           @Override
           public void write(JsonWriter out, B value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public B read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of B given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of B
  * @throws IOException if the JSON string is invalid with respect to B
  */
  public static B fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, B.class);
  }

 /**
  * Convert an instance of B to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/C.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * C
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class C {
  public static final String SERIALIZED_NAME_C = "c";
  @SerializedName(SERIALIZED_NAME_C)
  private String c;

  public C() {
  }

  public C c(String c) {

    this.c = c;
    return this;
  }

   /**
   * Get c
   * @return c
  **/
  @javax.annotation.Nonnull
  public String getC() {
    return c;
  }


  public void setC(String c) {
    this.c = c;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    C c = (C) o;
    return Objects.equals(this.c, c.c);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(c);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class C {\\n");
    sb.append("    c: ").append(toIndentedString(c)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("c");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("c");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to C
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!C.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in C is not found in the empty JSON string", C.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!C.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`C\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : C.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("c").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`c\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("c").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!C.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'C' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<C> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(C.class));

       return (TypeAdapter<T>) new TypeAdapter<C>() {
           @Override
           public void write(JsonWriter out, C value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public C read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of C given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of C
  * @throws IOException if the JSON string is invalid with respect to C
  */
  public static C fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, C.class);
  }

 /**
  * Convert an instance of C to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/OneOfInlineAndRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import test.test.runtime.model.B;
import test.test.runtime.model.C;
import test.test.runtime.model.OneOfInlineAndRefsOneOf;
import test.test.runtime.model.OneOfInlineAndRefsOneOf1;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class OneOfInlineAndRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(OneOfInlineAndRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!OneOfInlineAndRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'OneOfInlineAndRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<OneOfInlineAndRefsOneOf> adapterOneOfInlineAndRefsOneOf = gson.getDelegateAdapter(this, TypeToken.get(OneOfInlineAndRefsOneOf.class));
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));
            final TypeAdapter<B> adapterB = gson.getDelegateAdapter(this, TypeToken.get(B.class));
            final TypeAdapter<C> adapterC = gson.getDelegateAdapter(this, TypeToken.get(C.class));
            final TypeAdapter<OneOfInlineAndRefsOneOf1> adapterOneOfInlineAndRefsOneOf1 = gson.getDelegateAdapter(this, TypeToken.get(OneOfInlineAndRefsOneOf1.class));

            return (TypeAdapter<T>) new TypeAdapter<OneOfInlineAndRefs>() {
                @Override
                public void write(JsonWriter out, OneOfInlineAndRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`OneOfInlineAndRefsOneOf\`
                    if (value.getActualInstance() instanceof OneOfInlineAndRefsOneOf) {
                        JsonObject obj = adapterOneOfInlineAndRefsOneOf.toJsonTree((OneOfInlineAndRefsOneOf)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`B\`
                    if (value.getActualInstance() instanceof B) {
                        JsonObject obj = adapterB.toJsonTree((B)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`C\`
                    if (value.getActualInstance() instanceof C) {
                        JsonObject obj = adapterC.toJsonTree((C)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`OneOfInlineAndRefsOneOf1\`
                    if (value.getActualInstance() instanceof OneOfInlineAndRefsOneOf1) {
                        JsonObject obj = adapterOneOfInlineAndRefsOneOf1.toJsonTree((OneOfInlineAndRefsOneOf1)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1");
                }

                @Override
                public OneOfInlineAndRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize OneOfInlineAndRefsOneOf
                    try {
                        // validate the JSON object to see if any exception is thrown
                        OneOfInlineAndRefsOneOf.validateJsonObject(jsonObject);
                        actualAdapter = adapterOneOfInlineAndRefsOneOf;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'OneOfInlineAndRefsOneOf'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for OneOfInlineAndRefsOneOf failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'OneOfInlineAndRefsOneOf'", e);
                    }

                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        actualAdapter = adapterA;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'A'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }

                    // deserialize B
                    try {
                        // validate the JSON object to see if any exception is thrown
                        B.validateJsonObject(jsonObject);
                        actualAdapter = adapterB;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'B'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for B failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'B'", e);
                    }

                    // deserialize C
                    try {
                        // validate the JSON object to see if any exception is thrown
                        C.validateJsonObject(jsonObject);
                        actualAdapter = adapterC;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'C'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for C failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'C'", e);
                    }

                    // deserialize OneOfInlineAndRefsOneOf1
                    try {
                        // validate the JSON object to see if any exception is thrown
                        OneOfInlineAndRefsOneOf1.validateJsonObject(jsonObject);
                        actualAdapter = adapterOneOfInlineAndRefsOneOf1;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'OneOfInlineAndRefsOneOf1'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for OneOfInlineAndRefsOneOf1 failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'OneOfInlineAndRefsOneOf1'", e);
                    }

                    if (match == 1) {
                        OneOfInlineAndRefs ret = new OneOfInlineAndRefs();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for OneOfInlineAndRefs: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public OneOfInlineAndRefs() {
        super("oneOf", Boolean.FALSE);
    }

    public OneOfInlineAndRefs(OneOfInlineAndRefsOneOf o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfInlineAndRefs(A o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfInlineAndRefs(B o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfInlineAndRefs(C o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfInlineAndRefs(OneOfInlineAndRefsOneOf1 o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("OneOfInlineAndRefsOneOf", new GenericType<OneOfInlineAndRefsOneOf>() {
        });
        schemas.put("A", new GenericType<A>() {
        });
        schemas.put("B", new GenericType<B>() {
        });
        schemas.put("C", new GenericType<C>() {
        });
        schemas.put("OneOfInlineAndRefsOneOf1", new GenericType<OneOfInlineAndRefsOneOf1>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return OneOfInlineAndRefs.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof OneOfInlineAndRefsOneOf) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof B) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof C) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof OneOfInlineAndRefsOneOf1) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1");
    }

    /**
     * Get the actual instance, which can be the following:
     * OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1
     *
     * @return The actual instance (OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`OneOfInlineAndRefsOneOf\`. If the actual instance is not \`OneOfInlineAndRefsOneOf\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`OneOfInlineAndRefsOneOf\`
     * @throws ClassCastException if the instance is not \`OneOfInlineAndRefsOneOf\`
     */
    public OneOfInlineAndRefsOneOf getOneOfInlineAndRefsOneOf() throws ClassCastException {
        return (OneOfInlineAndRefsOneOf)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`B\`. If the actual instance is not \`B\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`B\`
     * @throws ClassCastException if the instance is not \`B\`
     */
    public B getB() throws ClassCastException {
        return (B)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`C\`. If the actual instance is not \`C\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`C\`
     * @throws ClassCastException if the instance is not \`C\`
     */
    public C getC() throws ClassCastException {
        return (C)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`OneOfInlineAndRefsOneOf1\`. If the actual instance is not \`OneOfInlineAndRefsOneOf1\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`OneOfInlineAndRefsOneOf1\`
     * @throws ClassCastException if the instance is not \`OneOfInlineAndRefsOneOf1\`
     */
    public OneOfInlineAndRefsOneOf1 getOneOfInlineAndRefsOneOf1() throws ClassCastException {
        return (OneOfInlineAndRefsOneOf1)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfInlineAndRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with OneOfInlineAndRefsOneOf
    try {
      OneOfInlineAndRefsOneOf.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for OneOfInlineAndRefsOneOf failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with B
    try {
      B.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for B failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with C
    try {
      C.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for C failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with OneOfInlineAndRefsOneOf1
    try {
      OneOfInlineAndRefsOneOf1.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for OneOfInlineAndRefsOneOf1 failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for OneOfInlineAndRefs with oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of OneOfInlineAndRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfInlineAndRefs
  * @throws IOException if the JSON string is invalid with respect to OneOfInlineAndRefs
  */
  public static OneOfInlineAndRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfInlineAndRefs.class);
  }

 /**
  * Convert an instance of OneOfInlineAndRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/OneOfInlineAndRefsOneOf.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * OneOfInlineAndRefsOneOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class OneOfInlineAndRefsOneOf {
  public static final String SERIALIZED_NAME_D = "d";
  @SerializedName(SERIALIZED_NAME_D)
  private String d;

  public OneOfInlineAndRefsOneOf() {
  }

  public OneOfInlineAndRefsOneOf d(String d) {

    this.d = d;
    return this;
  }

   /**
   * Get d
   * @return d
  **/
  @javax.annotation.Nonnull
  public String getD() {
    return d;
  }


  public void setD(String d) {
    this.d = d;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OneOfInlineAndRefsOneOf oneOfInlineAndRefsOneOf = (OneOfInlineAndRefsOneOf) o;
    return Objects.equals(this.d, oneOfInlineAndRefsOneOf.d);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(d);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OneOfInlineAndRefsOneOf {\\n");
    sb.append("    d: ").append(toIndentedString(d)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("d");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("d");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfInlineAndRefsOneOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!OneOfInlineAndRefsOneOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OneOfInlineAndRefsOneOf is not found in the empty JSON string", OneOfInlineAndRefsOneOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!OneOfInlineAndRefsOneOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`OneOfInlineAndRefsOneOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : OneOfInlineAndRefsOneOf.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("d").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`d\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("d").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OneOfInlineAndRefsOneOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OneOfInlineAndRefsOneOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OneOfInlineAndRefsOneOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OneOfInlineAndRefsOneOf.class));

       return (TypeAdapter<T>) new TypeAdapter<OneOfInlineAndRefsOneOf>() {
           @Override
           public void write(JsonWriter out, OneOfInlineAndRefsOneOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OneOfInlineAndRefsOneOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of OneOfInlineAndRefsOneOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfInlineAndRefsOneOf
  * @throws IOException if the JSON string is invalid with respect to OneOfInlineAndRefsOneOf
  */
  public static OneOfInlineAndRefsOneOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfInlineAndRefsOneOf.class);
  }

 /**
  * Convert an instance of OneOfInlineAndRefsOneOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/OneOfInlineAndRefsOneOf1.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * OneOfInlineAndRefsOneOf1
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class OneOfInlineAndRefsOneOf1 {
  public static final String SERIALIZED_NAME_E = "e";
  @SerializedName(SERIALIZED_NAME_E)
  private String e;

  public OneOfInlineAndRefsOneOf1() {
  }

  public OneOfInlineAndRefsOneOf1 e(String e) {

    this.e = e;
    return this;
  }

   /**
   * Get e
   * @return e
  **/
  @javax.annotation.Nullable
  public String getE() {
    return e;
  }


  public void setE(String e) {
    this.e = e;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OneOfInlineAndRefsOneOf1 oneOfInlineAndRefsOneOf1 = (OneOfInlineAndRefsOneOf1) o;
    return Objects.equals(this.e, oneOfInlineAndRefsOneOf1.e);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(e);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OneOfInlineAndRefsOneOf1 {\\n");
    sb.append("    e: ").append(toIndentedString(e)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("e");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfInlineAndRefsOneOf1
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!OneOfInlineAndRefsOneOf1.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OneOfInlineAndRefsOneOf1 is not found in the empty JSON string", OneOfInlineAndRefsOneOf1.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!OneOfInlineAndRefsOneOf1.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`OneOfInlineAndRefsOneOf1\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("e") != null && !jsonObj.get("e").isJsonNull()) && !jsonObj.get("e").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`e\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("e").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OneOfInlineAndRefsOneOf1.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OneOfInlineAndRefsOneOf1' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OneOfInlineAndRefsOneOf1> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OneOfInlineAndRefsOneOf1.class));

       return (TypeAdapter<T>) new TypeAdapter<OneOfInlineAndRefsOneOf1>() {
           @Override
           public void write(JsonWriter out, OneOfInlineAndRefsOneOf1 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OneOfInlineAndRefsOneOf1 read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of OneOfInlineAndRefsOneOf1 given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfInlineAndRefsOneOf1
  * @throws IOException if the JSON string is invalid with respect to OneOfInlineAndRefsOneOf1
  */
  public static OneOfInlineAndRefsOneOf1 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfInlineAndRefsOneOf1.class);
  }

 /**
  * Convert an instance of OneOfInlineAndRefsOneOf1 to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/OneOfPrimitives.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class OneOfPrimitives extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(OneOfPrimitives.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!OneOfPrimitives.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'OneOfPrimitives' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<Integer> adapterInteger = gson.getDelegateAdapter(this, TypeToken.get(Integer.class));

            return (TypeAdapter<T>) new TypeAdapter<OneOfPrimitives>() {
                @Override
                public void write(JsonWriter out, OneOfPrimitives value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`Integer\`
                    if (value.getActualInstance() instanceof Integer) {
                        JsonObject obj = adapterInteger.toJsonTree((Integer)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, Integer");
                }

                @Override
                public OneOfPrimitives read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        actualAdapter = adapterString;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'String'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize Integer
                    try {
                        // validate the JSON object to see if any exception is thrown
                        Integer.validateJsonObject(jsonObject);
                        actualAdapter = adapterInteger;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'Integer'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for Integer failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'Integer'", e);
                    }

                    if (match == 1) {
                        OneOfPrimitives ret = new OneOfPrimitives();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for OneOfPrimitives: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public OneOfPrimitives() {
        super("oneOf", Boolean.FALSE);
    }

    public OneOfPrimitives(String o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfPrimitives(Integer o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("Integer", new GenericType<Integer>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return OneOfPrimitives.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * String, Integer
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof Integer) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, Integer");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, Integer
     *
     * @return The actual instance (String, Integer)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`Integer\`. If the actual instance is not \`Integer\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`Integer\`
     * @throws ClassCastException if the instance is not \`Integer\`
     */
    public Integer getInteger() throws ClassCastException {
        return (Integer)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfPrimitives
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with Integer
    try {
      Integer.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for Integer failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for OneOfPrimitives with oneOf schemas: String, Integer. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of OneOfPrimitives given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfPrimitives
  * @throws IOException if the JSON string is invalid with respect to OneOfPrimitives
  */
  public static OneOfPrimitives fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfPrimitives.class);
  }

 /**
  * Convert an instance of OneOfPrimitives to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/OneOfPrimitivesAndRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class OneOfPrimitivesAndRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(OneOfPrimitivesAndRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!OneOfPrimitivesAndRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'OneOfPrimitivesAndRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));

            return (TypeAdapter<T>) new TypeAdapter<OneOfPrimitivesAndRefs>() {
                @Override
                public void write(JsonWriter out, OneOfPrimitivesAndRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, A");
                }

                @Override
                public OneOfPrimitivesAndRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        actualAdapter = adapterString;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'String'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        actualAdapter = adapterA;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'A'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }

                    if (match == 1) {
                        OneOfPrimitivesAndRefs ret = new OneOfPrimitivesAndRefs();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for OneOfPrimitivesAndRefs: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public OneOfPrimitivesAndRefs() {
        super("oneOf", Boolean.FALSE);
    }

    public OneOfPrimitivesAndRefs(String o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfPrimitivesAndRefs(A o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("A", new GenericType<A>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return OneOfPrimitivesAndRefs.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * String, A
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, A");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, A
     *
     * @return The actual instance (String, A)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfPrimitivesAndRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for OneOfPrimitivesAndRefs with oneOf schemas: String, A. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of OneOfPrimitivesAndRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfPrimitivesAndRefs
  * @throws IOException if the JSON string is invalid with respect to OneOfPrimitivesAndRefs
  */
  public static OneOfPrimitivesAndRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfPrimitivesAndRefs.class);
  }

 /**
  * Convert an instance of OneOfPrimitivesAndRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/OneOfRefs.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.A;
import test.test.runtime.model.B;
import test.test.runtime.model.C;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class OneOfRefs extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(OneOfRefs.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!OneOfRefs.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'OneOfRefs' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<A> adapterA = gson.getDelegateAdapter(this, TypeToken.get(A.class));
            final TypeAdapter<B> adapterB = gson.getDelegateAdapter(this, TypeToken.get(B.class));
            final TypeAdapter<C> adapterC = gson.getDelegateAdapter(this, TypeToken.get(C.class));

            return (TypeAdapter<T>) new TypeAdapter<OneOfRefs>() {
                @Override
                public void write(JsonWriter out, OneOfRefs value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`A\`
                    if (value.getActualInstance() instanceof A) {
                        JsonObject obj = adapterA.toJsonTree((A)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`B\`
                    if (value.getActualInstance() instanceof B) {
                        JsonObject obj = adapterB.toJsonTree((B)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`C\`
                    if (value.getActualInstance() instanceof C) {
                        JsonObject obj = adapterC.toJsonTree((C)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: A, B, C");
                }

                @Override
                public OneOfRefs read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize A
                    try {
                        // validate the JSON object to see if any exception is thrown
                        A.validateJsonObject(jsonObject);
                        actualAdapter = adapterA;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'A'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'A'", e);
                    }

                    // deserialize B
                    try {
                        // validate the JSON object to see if any exception is thrown
                        B.validateJsonObject(jsonObject);
                        actualAdapter = adapterB;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'B'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for B failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'B'", e);
                    }

                    // deserialize C
                    try {
                        // validate the JSON object to see if any exception is thrown
                        C.validateJsonObject(jsonObject);
                        actualAdapter = adapterC;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'C'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for C failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'C'", e);
                    }

                    if (match == 1) {
                        OneOfRefs ret = new OneOfRefs();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for OneOfRefs: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public OneOfRefs() {
        super("oneOf", Boolean.FALSE);
    }

    public OneOfRefs(A o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfRefs(B o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public OneOfRefs(C o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("A", new GenericType<A>() {
        });
        schemas.put("B", new GenericType<B>() {
        });
        schemas.put("C", new GenericType<C>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return OneOfRefs.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * A, B, C
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof A) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof B) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof C) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be A, B, C");
    }

    /**
     * Get the actual instance, which can be the following:
     * A, B, C
     *
     * @return The actual instance (A, B, C)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`A\`. If the actual instance is not \`A\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`A\`
     * @throws ClassCastException if the instance is not \`A\`
     */
    public A getA() throws ClassCastException {
        return (A)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`B\`. If the actual instance is not \`B\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`B\`
     * @throws ClassCastException if the instance is not \`B\`
     */
    public B getB() throws ClassCastException {
        return (B)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`C\`. If the actual instance is not \`C\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`C\`
     * @throws ClassCastException if the instance is not \`C\`
     */
    public C getC() throws ClassCastException {
        return (C)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OneOfRefs
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with A
    try {
      A.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for A failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with B
    try {
      B.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for B failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with C
    try {
      C.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for C failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for OneOfRefs with oneOf schemas: A, B, C. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of OneOfRefs given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OneOfRefs
  * @throws IOException if the JSON string is invalid with respect to OneOfRefs
  */
  public static OneOfRefs fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OneOfRefs.class);
  }

 /**
  * Convert an instance of OneOfRefs to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/Wrapper.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.WrapperAllOf;
import test.test.runtime.model.WrapperAnyOf;
import test.test.runtime.model.WrapperOneOf;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Wrapper
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class Wrapper {
  public static final String SERIALIZED_NAME_ALL_OF = "allOf";
  @SerializedName(SERIALIZED_NAME_ALL_OF)
  private WrapperAllOf allOf;

  public static final String SERIALIZED_NAME_ANY_OF = "anyOf";
  @SerializedName(SERIALIZED_NAME_ANY_OF)
  private WrapperAnyOf anyOf;

  public static final String SERIALIZED_NAME_ONE_OF = "oneOf";
  @SerializedName(SERIALIZED_NAME_ONE_OF)
  private WrapperOneOf oneOf;

  public Wrapper() {
  }

  public Wrapper allOf(WrapperAllOf allOf) {

    this.allOf = allOf;
    return this;
  }

   /**
   * Get allOf
   * @return allOf
  **/
  @javax.annotation.Nullable
  public WrapperAllOf getAllOf() {
    return allOf;
  }


  public void setAllOf(WrapperAllOf allOf) {
    this.allOf = allOf;
  }

  public Wrapper anyOf(WrapperAnyOf anyOf) {

    this.anyOf = anyOf;
    return this;
  }

   /**
   * Get anyOf
   * @return anyOf
  **/
  @javax.annotation.Nullable
  public WrapperAnyOf getAnyOf() {
    return anyOf;
  }


  public void setAnyOf(WrapperAnyOf anyOf) {
    this.anyOf = anyOf;
  }

  public Wrapper oneOf(WrapperOneOf oneOf) {

    this.oneOf = oneOf;
    return this;
  }

   /**
   * Get oneOf
   * @return oneOf
  **/
  @javax.annotation.Nullable
  public WrapperOneOf getOneOf() {
    return oneOf;
  }


  public void setOneOf(WrapperOneOf oneOf) {
    this.oneOf = oneOf;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Wrapper wrapper = (Wrapper) o;
    return Objects.equals(this.allOf, wrapper.allOf) &&
        Objects.equals(this.anyOf, wrapper.anyOf) &&
        Objects.equals(this.oneOf, wrapper.oneOf);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(allOf, anyOf, oneOf);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Wrapper {\\n");
    sb.append("    allOf: ").append(toIndentedString(allOf)).append("\\n");
    sb.append("    anyOf: ").append(toIndentedString(anyOf)).append("\\n");
    sb.append("    oneOf: ").append(toIndentedString(oneOf)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allOf");
    openapiFields.add("anyOf");
    openapiFields.add("oneOf");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Wrapper
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Wrapper.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Wrapper is not found in the empty JSON string", Wrapper.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!Wrapper.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`Wrapper\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`allOf\`
      if (jsonObj.get("allOf") != null && !jsonObj.get("allOf").isJsonNull()) {
        WrapperAllOf.validateJsonObject(jsonObj.getAsJsonObject("allOf"));
      }
      // validate the optional field \`anyOf\`
      if (jsonObj.get("anyOf") != null && !jsonObj.get("anyOf").isJsonNull()) {
        WrapperAnyOf.validateJsonObject(jsonObj.getAsJsonObject("anyOf"));
      }
      // validate the optional field \`oneOf\`
      if (jsonObj.get("oneOf") != null && !jsonObj.get("oneOf").isJsonNull()) {
        WrapperOneOf.validateJsonObject(jsonObj.getAsJsonObject("oneOf"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Wrapper.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Wrapper' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Wrapper> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Wrapper.class));

       return (TypeAdapter<T>) new TypeAdapter<Wrapper>() {
           @Override
           public void write(JsonWriter out, Wrapper value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Wrapper read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Wrapper given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Wrapper
  * @throws IOException if the JSON string is invalid with respect to Wrapper
  */
  public static Wrapper fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Wrapper.class);
  }

 /**
  * Convert an instance of Wrapper to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/WrapperAllOf.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.AllOfInlineAndRefs;
import test.test.runtime.model.AllOfRefs;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * WrapperAllOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class WrapperAllOf {
  public static final String SERIALIZED_NAME_REFS = "refs";
  @SerializedName(SERIALIZED_NAME_REFS)
  private AllOfRefs refs;

  public static final String SERIALIZED_NAME_INLINE_AND_REFS = "inlineAndRefs";
  @SerializedName(SERIALIZED_NAME_INLINE_AND_REFS)
  private AllOfInlineAndRefs inlineAndRefs;

  public WrapperAllOf() {
  }

  public WrapperAllOf refs(AllOfRefs refs) {

    this.refs = refs;
    return this;
  }

   /**
   * Get refs
   * @return refs
  **/
  @javax.annotation.Nullable
  public AllOfRefs getRefs() {
    return refs;
  }


  public void setRefs(AllOfRefs refs) {
    this.refs = refs;
  }

  public WrapperAllOf inlineAndRefs(AllOfInlineAndRefs inlineAndRefs) {

    this.inlineAndRefs = inlineAndRefs;
    return this;
  }

   /**
   * Get inlineAndRefs
   * @return inlineAndRefs
  **/
  @javax.annotation.Nullable
  public AllOfInlineAndRefs getInlineAndRefs() {
    return inlineAndRefs;
  }


  public void setInlineAndRefs(AllOfInlineAndRefs inlineAndRefs) {
    this.inlineAndRefs = inlineAndRefs;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WrapperAllOf wrapperAllOf = (WrapperAllOf) o;
    return Objects.equals(this.refs, wrapperAllOf.refs) &&
        Objects.equals(this.inlineAndRefs, wrapperAllOf.inlineAndRefs);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(refs, inlineAndRefs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WrapperAllOf {\\n");
    sb.append("    refs: ").append(toIndentedString(refs)).append("\\n");
    sb.append("    inlineAndRefs: ").append(toIndentedString(inlineAndRefs)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("refs");
    openapiFields.add("inlineAndRefs");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to WrapperAllOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!WrapperAllOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WrapperAllOf is not found in the empty JSON string", WrapperAllOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!WrapperAllOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`WrapperAllOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`refs\`
      if (jsonObj.get("refs") != null && !jsonObj.get("refs").isJsonNull()) {
        AllOfRefs.validateJsonObject(jsonObj.getAsJsonObject("refs"));
      }
      // validate the optional field \`inlineAndRefs\`
      if (jsonObj.get("inlineAndRefs") != null && !jsonObj.get("inlineAndRefs").isJsonNull()) {
        AllOfInlineAndRefs.validateJsonObject(jsonObj.getAsJsonObject("inlineAndRefs"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WrapperAllOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WrapperAllOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WrapperAllOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WrapperAllOf.class));

       return (TypeAdapter<T>) new TypeAdapter<WrapperAllOf>() {
           @Override
           public void write(JsonWriter out, WrapperAllOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WrapperAllOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of WrapperAllOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of WrapperAllOf
  * @throws IOException if the JSON string is invalid with respect to WrapperAllOf
  */
  public static WrapperAllOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WrapperAllOf.class);
  }

 /**
  * Convert an instance of WrapperAllOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/WrapperAnyOf.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.AnyOfInlineAndRefs;
import test.test.runtime.model.AnyOfPrimitives;
import test.test.runtime.model.AnyOfPrimitivesAndRefs;
import test.test.runtime.model.AnyOfRefs;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * WrapperAnyOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class WrapperAnyOf {
  public static final String SERIALIZED_NAME_REFS = "refs";
  @SerializedName(SERIALIZED_NAME_REFS)
  private AnyOfRefs refs;

  public static final String SERIALIZED_NAME_INLINE_AND_REFS = "inlineAndRefs";
  @SerializedName(SERIALIZED_NAME_INLINE_AND_REFS)
  private AnyOfInlineAndRefs inlineAndRefs;

  public static final String SERIALIZED_NAME_PRIMITIVES = "primitives";
  @SerializedName(SERIALIZED_NAME_PRIMITIVES)
  private AnyOfPrimitives primitives;

  public static final String SERIALIZED_NAME_PRIMITIVES_AND_REFS = "primitivesAndRefs";
  @SerializedName(SERIALIZED_NAME_PRIMITIVES_AND_REFS)
  private AnyOfPrimitivesAndRefs primitivesAndRefs;

  public WrapperAnyOf() {
  }

  public WrapperAnyOf refs(AnyOfRefs refs) {

    this.refs = refs;
    return this;
  }

   /**
   * Get refs
   * @return refs
  **/
  @javax.annotation.Nullable
  public AnyOfRefs getRefs() {
    return refs;
  }


  public void setRefs(AnyOfRefs refs) {
    this.refs = refs;
  }

  public WrapperAnyOf inlineAndRefs(AnyOfInlineAndRefs inlineAndRefs) {

    this.inlineAndRefs = inlineAndRefs;
    return this;
  }

   /**
   * Get inlineAndRefs
   * @return inlineAndRefs
  **/
  @javax.annotation.Nullable
  public AnyOfInlineAndRefs getInlineAndRefs() {
    return inlineAndRefs;
  }


  public void setInlineAndRefs(AnyOfInlineAndRefs inlineAndRefs) {
    this.inlineAndRefs = inlineAndRefs;
  }

  public WrapperAnyOf primitives(AnyOfPrimitives primitives) {

    this.primitives = primitives;
    return this;
  }

   /**
   * Get primitives
   * @return primitives
  **/
  @javax.annotation.Nullable
  public AnyOfPrimitives getPrimitives() {
    return primitives;
  }


  public void setPrimitives(AnyOfPrimitives primitives) {
    this.primitives = primitives;
  }

  public WrapperAnyOf primitivesAndRefs(AnyOfPrimitivesAndRefs primitivesAndRefs) {

    this.primitivesAndRefs = primitivesAndRefs;
    return this;
  }

   /**
   * Get primitivesAndRefs
   * @return primitivesAndRefs
  **/
  @javax.annotation.Nullable
  public AnyOfPrimitivesAndRefs getPrimitivesAndRefs() {
    return primitivesAndRefs;
  }


  public void setPrimitivesAndRefs(AnyOfPrimitivesAndRefs primitivesAndRefs) {
    this.primitivesAndRefs = primitivesAndRefs;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WrapperAnyOf wrapperAnyOf = (WrapperAnyOf) o;
    return Objects.equals(this.refs, wrapperAnyOf.refs) &&
        Objects.equals(this.inlineAndRefs, wrapperAnyOf.inlineAndRefs) &&
        Objects.equals(this.primitives, wrapperAnyOf.primitives) &&
        Objects.equals(this.primitivesAndRefs, wrapperAnyOf.primitivesAndRefs);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(refs, inlineAndRefs, primitives, primitivesAndRefs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WrapperAnyOf {\\n");
    sb.append("    refs: ").append(toIndentedString(refs)).append("\\n");
    sb.append("    inlineAndRefs: ").append(toIndentedString(inlineAndRefs)).append("\\n");
    sb.append("    primitives: ").append(toIndentedString(primitives)).append("\\n");
    sb.append("    primitivesAndRefs: ").append(toIndentedString(primitivesAndRefs)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("refs");
    openapiFields.add("inlineAndRefs");
    openapiFields.add("primitives");
    openapiFields.add("primitivesAndRefs");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to WrapperAnyOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!WrapperAnyOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WrapperAnyOf is not found in the empty JSON string", WrapperAnyOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!WrapperAnyOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`WrapperAnyOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`refs\`
      if (jsonObj.get("refs") != null && !jsonObj.get("refs").isJsonNull()) {
        AnyOfRefs.validateJsonObject(jsonObj.getAsJsonObject("refs"));
      }
      // validate the optional field \`inlineAndRefs\`
      if (jsonObj.get("inlineAndRefs") != null && !jsonObj.get("inlineAndRefs").isJsonNull()) {
        AnyOfInlineAndRefs.validateJsonObject(jsonObj.getAsJsonObject("inlineAndRefs"));
      }
      // validate the optional field \`primitives\`
      if (jsonObj.get("primitives") != null && !jsonObj.get("primitives").isJsonNull()) {
        AnyOfPrimitives.validateJsonObject(jsonObj.getAsJsonObject("primitives"));
      }
      // validate the optional field \`primitivesAndRefs\`
      if (jsonObj.get("primitivesAndRefs") != null && !jsonObj.get("primitivesAndRefs").isJsonNull()) {
        AnyOfPrimitivesAndRefs.validateJsonObject(jsonObj.getAsJsonObject("primitivesAndRefs"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WrapperAnyOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WrapperAnyOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WrapperAnyOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WrapperAnyOf.class));

       return (TypeAdapter<T>) new TypeAdapter<WrapperAnyOf>() {
           @Override
           public void write(JsonWriter out, WrapperAnyOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WrapperAnyOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of WrapperAnyOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of WrapperAnyOf
  * @throws IOException if the JSON string is invalid with respect to WrapperAnyOf
  */
  public static WrapperAnyOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WrapperAnyOf.class);
  }

 /**
  * Convert an instance of WrapperAnyOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/WrapperOneOf.java": "/*
 * composite models
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.OneOfInlineAndRefs;
import test.test.runtime.model.OneOfPrimitives;
import test.test.runtime.model.OneOfPrimitivesAndRefs;
import test.test.runtime.model.OneOfRefs;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * WrapperOneOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class WrapperOneOf {
  public static final String SERIALIZED_NAME_REFS = "refs";
  @SerializedName(SERIALIZED_NAME_REFS)
  private OneOfRefs refs;

  public static final String SERIALIZED_NAME_INLINE_AND_REFS = "inlineAndRefs";
  @SerializedName(SERIALIZED_NAME_INLINE_AND_REFS)
  private OneOfInlineAndRefs inlineAndRefs;

  public static final String SERIALIZED_NAME_PRIMITIVES = "primitives";
  @SerializedName(SERIALIZED_NAME_PRIMITIVES)
  private OneOfPrimitives primitives;

  public static final String SERIALIZED_NAME_PRIMITIVES_AND_REFS = "primitivesAndRefs";
  @SerializedName(SERIALIZED_NAME_PRIMITIVES_AND_REFS)
  private OneOfPrimitivesAndRefs primitivesAndRefs;

  public WrapperOneOf() {
  }

  public WrapperOneOf refs(OneOfRefs refs) {

    this.refs = refs;
    return this;
  }

   /**
   * Get refs
   * @return refs
  **/
  @javax.annotation.Nullable
  public OneOfRefs getRefs() {
    return refs;
  }


  public void setRefs(OneOfRefs refs) {
    this.refs = refs;
  }

  public WrapperOneOf inlineAndRefs(OneOfInlineAndRefs inlineAndRefs) {

    this.inlineAndRefs = inlineAndRefs;
    return this;
  }

   /**
   * Get inlineAndRefs
   * @return inlineAndRefs
  **/
  @javax.annotation.Nullable
  public OneOfInlineAndRefs getInlineAndRefs() {
    return inlineAndRefs;
  }


  public void setInlineAndRefs(OneOfInlineAndRefs inlineAndRefs) {
    this.inlineAndRefs = inlineAndRefs;
  }

  public WrapperOneOf primitives(OneOfPrimitives primitives) {

    this.primitives = primitives;
    return this;
  }

   /**
   * Get primitives
   * @return primitives
  **/
  @javax.annotation.Nullable
  public OneOfPrimitives getPrimitives() {
    return primitives;
  }


  public void setPrimitives(OneOfPrimitives primitives) {
    this.primitives = primitives;
  }

  public WrapperOneOf primitivesAndRefs(OneOfPrimitivesAndRefs primitivesAndRefs) {

    this.primitivesAndRefs = primitivesAndRefs;
    return this;
  }

   /**
   * Get primitivesAndRefs
   * @return primitivesAndRefs
  **/
  @javax.annotation.Nullable
  public OneOfPrimitivesAndRefs getPrimitivesAndRefs() {
    return primitivesAndRefs;
  }


  public void setPrimitivesAndRefs(OneOfPrimitivesAndRefs primitivesAndRefs) {
    this.primitivesAndRefs = primitivesAndRefs;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WrapperOneOf wrapperOneOf = (WrapperOneOf) o;
    return Objects.equals(this.refs, wrapperOneOf.refs) &&
        Objects.equals(this.inlineAndRefs, wrapperOneOf.inlineAndRefs) &&
        Objects.equals(this.primitives, wrapperOneOf.primitives) &&
        Objects.equals(this.primitivesAndRefs, wrapperOneOf.primitivesAndRefs);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(refs, inlineAndRefs, primitives, primitivesAndRefs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WrapperOneOf {\\n");
    sb.append("    refs: ").append(toIndentedString(refs)).append("\\n");
    sb.append("    inlineAndRefs: ").append(toIndentedString(inlineAndRefs)).append("\\n");
    sb.append("    primitives: ").append(toIndentedString(primitives)).append("\\n");
    sb.append("    primitivesAndRefs: ").append(toIndentedString(primitivesAndRefs)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("refs");
    openapiFields.add("inlineAndRefs");
    openapiFields.add("primitives");
    openapiFields.add("primitivesAndRefs");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to WrapperOneOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!WrapperOneOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WrapperOneOf is not found in the empty JSON string", WrapperOneOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!WrapperOneOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`WrapperOneOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`refs\`
      if (jsonObj.get("refs") != null && !jsonObj.get("refs").isJsonNull()) {
        OneOfRefs.validateJsonObject(jsonObj.getAsJsonObject("refs"));
      }
      // validate the optional field \`inlineAndRefs\`
      if (jsonObj.get("inlineAndRefs") != null && !jsonObj.get("inlineAndRefs").isJsonNull()) {
        OneOfInlineAndRefs.validateJsonObject(jsonObj.getAsJsonObject("inlineAndRefs"));
      }
      // validate the optional field \`primitives\`
      if (jsonObj.get("primitives") != null && !jsonObj.get("primitives").isJsonNull()) {
        OneOfPrimitives.validateJsonObject(jsonObj.getAsJsonObject("primitives"));
      }
      // validate the optional field \`primitivesAndRefs\`
      if (jsonObj.get("primitivesAndRefs") != null && !jsonObj.get("primitivesAndRefs").isJsonNull()) {
        OneOfPrimitivesAndRefs.validateJsonObject(jsonObj.getAsJsonObject("primitivesAndRefs"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WrapperOneOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WrapperOneOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WrapperOneOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WrapperOneOf.class));

       return (TypeAdapter<T>) new TypeAdapter<WrapperOneOf>() {
           @Override
           public void write(JsonWriter out, WrapperOneOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WrapperOneOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of WrapperOneOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of WrapperOneOf
  * @throws IOException if the JSON string is invalid with respect to WrapperOneOf
  */
  public static WrapperOneOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WrapperOneOf.class);
  }

 /**
  * Convert an instance of WrapperOneOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With data-types.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypesResponse.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypes200Response.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypesRequestParameters.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypesInput.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypesRequestInput.java
src/main/java/test/test/runtime/api/handlers/data_types/DataTypes.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/DataTypes200Response.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyAllOf.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyAnyOf.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyNotNot.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyObject.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyObjectOne.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyObjectOneTwo.java
src/main/java/test/test/runtime/model/DataTypes200ResponseMyOneOf.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200Response.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyAllOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyAllOfAllOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyAllOfAllOf1.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyAnyOf.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyNotNot.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyObject.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyObjectOne.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyObjectOneTwo.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.DataTypes200ResponseMyOneOf.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.DataTypes200Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call dataTypesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/types";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call dataTypesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return dataTypesCall(_callback);

    }

    private ApiResponse<DataTypes200Response> dataTypesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = dataTypesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<DataTypes200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call dataTypesAsync(final ApiCallback<DataTypes200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = dataTypesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<DataTypes200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIdataTypesRequest {

        private APIdataTypesRequest() {
        }

        /**
         * Build call for dataTypes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return dataTypesCall(_callback);
        }

        /**
         * Execute dataTypes request
         * @return DataTypes200Response
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public DataTypes200Response execute() throws ApiException {
            ApiResponse<DataTypes200Response> localVarResp = dataTypesWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute dataTypes request with HTTP info returned
         * @return ApiResponse&lt;DataTypes200Response&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DataTypes200Response> executeWithHttpInfo() throws ApiException {
            return dataTypesWithHttpInfo();
        }

        /**
         * Execute dataTypes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DataTypes200Response> _callback) throws ApiException {
            return dataTypesAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIdataTypesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIdataTypesRequest dataTypes() {
        return new APIdataTypesRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.data_types.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String dataTypesMethodAndPath = Handlers.concatMethodAndPath("GET", "/types");

    private final DataTypes constructedDataTypes;

    /**
     * This method must return your implementation of the DataTypes operation
     */
    public abstract DataTypes dataTypes();

    private static enum Route {
        dataTypesRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(dataTypesMethodAndPath, Route.dataTypesRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedDataTypes = this.dataTypes();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case dataTypesRoute:
                List<Interceptor<DataTypesInput>> dataTypesInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                dataTypesInterceptors.addAll(this.getInterceptors());
                return this.constructedDataTypes.handleRequestWithAdditionalInterceptors(event, context, dataTypesInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypes.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the dataTypes operation
 */
public abstract class DataTypes implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the dataTypes operation
     */
    public abstract DataTypesResponse handle(final DataTypesRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<DataTypesInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(DataTypes.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<DataTypesInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<DataTypesInput>> getHandlerInterceptors() {
        List<Interceptor<DataTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<DataTypesInput> buildChain(List<Interceptor<DataTypesInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<DataTypesInput>() {
            @Override
            public Response next(ChainedRequestInput<DataTypesInput> input) {
                return handle(new DataTypesRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<DataTypesInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final DataTypesInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<DataTypesInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public DataTypesInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new DataTypesInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<DataTypesInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "dataTypes");

        List<Interceptor<DataTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        DataTypesInput input;

        try {
            input = new DataTypesInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypes200Response.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the dataTypes operation
 */
public class DataTypes200Response extends RuntimeException implements DataTypesResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final DataTypes200Response typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private DataTypes200Response(final DataTypes200Response body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public DataTypes200Response getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a DataTypes200Response with a body
     */
    public static DataTypes200Response of(final DataTypes200Response body) {
        return new DataTypes200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a DataTypes200Response with a body and headers
     */
    public static DataTypes200Response of(final DataTypes200Response body, final Map<String, String> headers) {
        return new DataTypes200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a DataTypes200Response with a body, headers and multi-value headers
     */
    public static DataTypes200Response of(final DataTypes200Response body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new DataTypes200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypesInput.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the dataTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class DataTypesInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final DataTypesRequestParameters requestParameters;

    public DataTypesInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new DataTypesRequestParameters(event);
    }

    public DataTypesRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypesRequestInput.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the dataTypes operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class DataTypesRequestInput implements RequestInput<DataTypesInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final DataTypesInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public DataTypesInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypesRequestParameters.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the DataTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class DataTypesRequestParameters {

    public DataTypesRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/data_types/DataTypesResponse.java": "
package test.test.runtime.api.handlers.data_types;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the dataTypes operation
 */
public interface DataTypesResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T dataTypes;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("dataTypes", this.dataTypes);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("dataTypes", OperationLookupEntry.builder()
            .path("/types")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .dataTypes(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/DataTypes200Response.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.DataTypes200ResponseMyAllOf;
import test.test.runtime.model.DataTypes200ResponseMyAnyOf;
import test.test.runtime.model.DataTypes200ResponseMyObject;
import test.test.runtime.model.DataTypes200ResponseMyOneOf;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200Response
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200Response {
  public static final String SERIALIZED_NAME_MY_INT = "myInt";
  @SerializedName(SERIALIZED_NAME_MY_INT)
  private Integer myInt;

  public static final String SERIALIZED_NAME_MY_EXCLUSIVE_INT = "myExclusiveInt";
  @SerializedName(SERIALIZED_NAME_MY_EXCLUSIVE_INT)
  private Integer myExclusiveInt;

  public static final String SERIALIZED_NAME_MY_STRING = "myString";
  @SerializedName(SERIALIZED_NAME_MY_STRING)
  private String myString;

  public static final String SERIALIZED_NAME_MY_STRING_LENGTH = "myStringLength";
  @SerializedName(SERIALIZED_NAME_MY_STRING_LENGTH)
  private String myStringLength;

  public static final String SERIALIZED_NAME_MY_LONG_MIN_STRING_LENGTH = "myLongMinStringLength";
  @SerializedName(SERIALIZED_NAME_MY_LONG_MIN_STRING_LENGTH)
  private String myLongMinStringLength;

  public static final String SERIALIZED_NAME_MY_BOOL = "myBool";
  @SerializedName(SERIALIZED_NAME_MY_BOOL)
  private Boolean myBool;

  public static final String SERIALIZED_NAME_MY_NUMBER = "myNumber";
  @SerializedName(SERIALIZED_NAME_MY_NUMBER)
  private BigDecimal myNumber;

  public static final String SERIALIZED_NAME_MY_DATE_ARRAY = "myDateArray";
  @SerializedName(SERIALIZED_NAME_MY_DATE_ARRAY)
  private List<LocalDate> myDateArray = null;

  public static final String SERIALIZED_NAME_MY_EMAIL = "myEmail";
  @SerializedName(SERIALIZED_NAME_MY_EMAIL)
  private String myEmail;

  public static final String SERIALIZED_NAME_MY_URL = "myUrl";
  @SerializedName(SERIALIZED_NAME_MY_URL)
  private URI myUrl;

  public static final String SERIALIZED_NAME_MY_HOSTNAME = "myHostname";
  @SerializedName(SERIALIZED_NAME_MY_HOSTNAME)
  private String myHostname;

  public static final String SERIALIZED_NAME_MY_IPV4 = "myIpv4";
  @SerializedName(SERIALIZED_NAME_MY_IPV4)
  private String myIpv4;

  public static final String SERIALIZED_NAME_MY_IPV6 = "myIpv6";
  @SerializedName(SERIALIZED_NAME_MY_IPV6)
  private String myIpv6;

  public static final String SERIALIZED_NAME_MY_UUID = "myUuid";
  @SerializedName(SERIALIZED_NAME_MY_UUID)
  private UUID myUuid;

  public static final String SERIALIZED_NAME_MY_BYTE = "myByte";
  @SerializedName(SERIALIZED_NAME_MY_BYTE)
  private byte[] myByte;

  public static final String SERIALIZED_NAME_MY_CONSTRAINED_BYTE = "myConstrainedByte";
  @SerializedName(SERIALIZED_NAME_MY_CONSTRAINED_BYTE)
  private byte[] myConstrainedByte;

  public static final String SERIALIZED_NAME_MY_DATE_TIME = "myDateTime";
  @SerializedName(SERIALIZED_NAME_MY_DATE_TIME)
  private OffsetDateTime myDateTime;

  public static final String SERIALIZED_NAME_MY_REGEX_PATTERN = "myRegexPattern";
  @SerializedName(SERIALIZED_NAME_MY_REGEX_PATTERN)
  private String myRegexPattern;

  public static final String SERIALIZED_NAME_MY_ONE_OF = "myOneOf";
  @SerializedName(SERIALIZED_NAME_MY_ONE_OF)
  private DataTypes200ResponseMyOneOf myOneOf;

  public static final String SERIALIZED_NAME_MY_ANY_OF = "myAnyOf";
  @SerializedName(SERIALIZED_NAME_MY_ANY_OF)
  private DataTypes200ResponseMyAnyOf myAnyOf;

  public static final String SERIALIZED_NAME_MY_ALL_OF = "myAllOf";
  @SerializedName(SERIALIZED_NAME_MY_ALL_OF)
  private DataTypes200ResponseMyAllOf myAllOf;

  public static final String SERIALIZED_NAME_MY_NOT = "myNot";
  @SerializedName(SERIALIZED_NAME_MY_NOT)
  private Object myNot = null;

  public static final String SERIALIZED_NAME_MY_NOT_STRING = "myNotString";
  @SerializedName(SERIALIZED_NAME_MY_NOT_STRING)
  private Object myNotString = null;

  public static final String SERIALIZED_NAME_MY_ADDITIONAL_PROPERTIES = "myAdditionalProperties";
  @SerializedName(SERIALIZED_NAME_MY_ADDITIONAL_PROPERTIES)
  private Map<String, List<Integer>> myAdditionalProperties = null;

  public static final String SERIALIZED_NAME_MY_OBJECT = "myObject";
  @SerializedName(SERIALIZED_NAME_MY_OBJECT)
  private DataTypes200ResponseMyObject myObject;

  public DataTypes200Response() {
  }

  public DataTypes200Response myInt(Integer myInt) {

    this.myInt = myInt;
    return this;
  }

   /**
   * Get myInt
   * @return myInt
  **/
  @javax.annotation.Nullable
  public Integer getMyInt() {
    return myInt;
  }


  public void setMyInt(Integer myInt) {
    this.myInt = myInt;
  }

  public DataTypes200Response myExclusiveInt(Integer myExclusiveInt) {

    this.myExclusiveInt = myExclusiveInt;
    return this;
  }

   /**
   * Get myExclusiveInt
   * @return myExclusiveInt
  **/
  @javax.annotation.Nullable
  public Integer getMyExclusiveInt() {
    return myExclusiveInt;
  }


  public void setMyExclusiveInt(Integer myExclusiveInt) {
    this.myExclusiveInt = myExclusiveInt;
  }

  public DataTypes200Response myString(String myString) {

    this.myString = myString;
    return this;
  }

   /**
   * Get myString
   * @return myString
  **/
  @javax.annotation.Nullable
  public String getMyString() {
    return myString;
  }


  public void setMyString(String myString) {
    this.myString = myString;
  }

  public DataTypes200Response myStringLength(String myStringLength) {

    this.myStringLength = myStringLength;
    return this;
  }

   /**
   * Get myStringLength
   * @return myStringLength
  **/
  @javax.annotation.Nullable
  public String getMyStringLength() {
    return myStringLength;
  }


  public void setMyStringLength(String myStringLength) {
    this.myStringLength = myStringLength;
  }

  public DataTypes200Response myLongMinStringLength(String myLongMinStringLength) {

    this.myLongMinStringLength = myLongMinStringLength;
    return this;
  }

   /**
   * Get myLongMinStringLength
   * @return myLongMinStringLength
  **/
  @javax.annotation.Nullable
  public String getMyLongMinStringLength() {
    return myLongMinStringLength;
  }


  public void setMyLongMinStringLength(String myLongMinStringLength) {
    this.myLongMinStringLength = myLongMinStringLength;
  }

  public DataTypes200Response myBool(Boolean myBool) {

    this.myBool = myBool;
    return this;
  }

   /**
   * Get myBool
   * @return myBool
  **/
  @javax.annotation.Nullable
  public Boolean getMyBool() {
    return myBool;
  }


  public void setMyBool(Boolean myBool) {
    this.myBool = myBool;
  }

  public DataTypes200Response myNumber(BigDecimal myNumber) {

    this.myNumber = myNumber;
    return this;
  }

   /**
   * Get myNumber
   * @return myNumber
  **/
  @javax.annotation.Nullable
  public BigDecimal getMyNumber() {
    return myNumber;
  }


  public void setMyNumber(BigDecimal myNumber) {
    this.myNumber = myNumber;
  }

  public DataTypes200Response myDateArray(List<LocalDate> myDateArray) {

    this.myDateArray = myDateArray;
    return this;
  }

  public DataTypes200Response addMyDateArrayItem(LocalDate myDateArrayItem) {
    if (this.myDateArray == null) {
      this.myDateArray = new ArrayList<>();
    }
    this.myDateArray.add(myDateArrayItem);
    return this;
  }

   /**
   * Get myDateArray
   * @return myDateArray
  **/
  @javax.annotation.Nullable
  public List<LocalDate> getMyDateArray() {
    return myDateArray;
  }


  public void setMyDateArray(List<LocalDate> myDateArray) {
    this.myDateArray = myDateArray;
  }

  public DataTypes200Response myEmail(String myEmail) {

    this.myEmail = myEmail;
    return this;
  }

   /**
   * Get myEmail
   * @return myEmail
  **/
  @javax.annotation.Nullable
  public String getMyEmail() {
    return myEmail;
  }


  public void setMyEmail(String myEmail) {
    this.myEmail = myEmail;
  }

  public DataTypes200Response myUrl(URI myUrl) {

    this.myUrl = myUrl;
    return this;
  }

   /**
   * Get myUrl
   * @return myUrl
  **/
  @javax.annotation.Nullable
  public URI getMyUrl() {
    return myUrl;
  }


  public void setMyUrl(URI myUrl) {
    this.myUrl = myUrl;
  }

  public DataTypes200Response myHostname(String myHostname) {

    this.myHostname = myHostname;
    return this;
  }

   /**
   * Get myHostname
   * @return myHostname
  **/
  @javax.annotation.Nullable
  public String getMyHostname() {
    return myHostname;
  }


  public void setMyHostname(String myHostname) {
    this.myHostname = myHostname;
  }

  public DataTypes200Response myIpv4(String myIpv4) {

    this.myIpv4 = myIpv4;
    return this;
  }

   /**
   * Get myIpv4
   * @return myIpv4
  **/
  @javax.annotation.Nullable
  public String getMyIpv4() {
    return myIpv4;
  }


  public void setMyIpv4(String myIpv4) {
    this.myIpv4 = myIpv4;
  }

  public DataTypes200Response myIpv6(String myIpv6) {

    this.myIpv6 = myIpv6;
    return this;
  }

   /**
   * Get myIpv6
   * @return myIpv6
  **/
  @javax.annotation.Nullable
  public String getMyIpv6() {
    return myIpv6;
  }


  public void setMyIpv6(String myIpv6) {
    this.myIpv6 = myIpv6;
  }

  public DataTypes200Response myUuid(UUID myUuid) {

    this.myUuid = myUuid;
    return this;
  }

   /**
   * Get myUuid
   * @return myUuid
  **/
  @javax.annotation.Nullable
  public UUID getMyUuid() {
    return myUuid;
  }


  public void setMyUuid(UUID myUuid) {
    this.myUuid = myUuid;
  }

  public DataTypes200Response myByte(byte[] myByte) {

    this.myByte = myByte;
    return this;
  }

   /**
   * Get myByte
   * @return myByte
  **/
  @javax.annotation.Nullable
  public byte[] getMyByte() {
    return myByte;
  }


  public void setMyByte(byte[] myByte) {
    this.myByte = myByte;
  }

  public DataTypes200Response myConstrainedByte(byte[] myConstrainedByte) {

    this.myConstrainedByte = myConstrainedByte;
    return this;
  }

   /**
   * Get myConstrainedByte
   * @return myConstrainedByte
  **/
  @javax.annotation.Nullable
  public byte[] getMyConstrainedByte() {
    return myConstrainedByte;
  }


  public void setMyConstrainedByte(byte[] myConstrainedByte) {
    this.myConstrainedByte = myConstrainedByte;
  }

  public DataTypes200Response myDateTime(OffsetDateTime myDateTime) {

    this.myDateTime = myDateTime;
    return this;
  }

   /**
   * Get myDateTime
   * @return myDateTime
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getMyDateTime() {
    return myDateTime;
  }


  public void setMyDateTime(OffsetDateTime myDateTime) {
    this.myDateTime = myDateTime;
  }

  public DataTypes200Response myRegexPattern(String myRegexPattern) {

    this.myRegexPattern = myRegexPattern;
    return this;
  }

   /**
   * Get myRegexPattern
   * @return myRegexPattern
  **/
  @javax.annotation.Nullable
  public String getMyRegexPattern() {
    return myRegexPattern;
  }


  public void setMyRegexPattern(String myRegexPattern) {
    this.myRegexPattern = myRegexPattern;
  }

  public DataTypes200Response myOneOf(DataTypes200ResponseMyOneOf myOneOf) {

    this.myOneOf = myOneOf;
    return this;
  }

   /**
   * Get myOneOf
   * @return myOneOf
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyOneOf getMyOneOf() {
    return myOneOf;
  }


  public void setMyOneOf(DataTypes200ResponseMyOneOf myOneOf) {
    this.myOneOf = myOneOf;
  }

  public DataTypes200Response myAnyOf(DataTypes200ResponseMyAnyOf myAnyOf) {

    this.myAnyOf = myAnyOf;
    return this;
  }

   /**
   * Get myAnyOf
   * @return myAnyOf
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyAnyOf getMyAnyOf() {
    return myAnyOf;
  }


  public void setMyAnyOf(DataTypes200ResponseMyAnyOf myAnyOf) {
    this.myAnyOf = myAnyOf;
  }

  public DataTypes200Response myAllOf(DataTypes200ResponseMyAllOf myAllOf) {

    this.myAllOf = myAllOf;
    return this;
  }

   /**
   * Get myAllOf
   * @return myAllOf
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyAllOf getMyAllOf() {
    return myAllOf;
  }


  public void setMyAllOf(DataTypes200ResponseMyAllOf myAllOf) {
    this.myAllOf = myAllOf;
  }

  public DataTypes200Response myNot(Object myNot) {

    this.myNot = myNot;
    return this;
  }

   /**
   * Get myNot
   * @return myNot
  **/
  @javax.annotation.Nullable
  public Object getMyNot() {
    return myNot;
  }


  public void setMyNot(Object myNot) {
    this.myNot = myNot;
  }

  public DataTypes200Response myNotString(Object myNotString) {

    this.myNotString = myNotString;
    return this;
  }

   /**
   * Get myNotString
   * @return myNotString
  **/
  @javax.annotation.Nullable
  public Object getMyNotString() {
    return myNotString;
  }


  public void setMyNotString(Object myNotString) {
    this.myNotString = myNotString;
  }

  public DataTypes200Response myAdditionalProperties(Map<String, List<Integer>> myAdditionalProperties) {

    this.myAdditionalProperties = myAdditionalProperties;
    return this;
  }

  public DataTypes200Response putMyAdditionalPropertiesItem(String key, List<Integer> myAdditionalPropertiesItem) {
    if (this.myAdditionalProperties == null) {
      this.myAdditionalProperties = new HashMap<>();
    }
    this.myAdditionalProperties.put(key, myAdditionalPropertiesItem);
    return this;
  }

   /**
   * Get myAdditionalProperties
   * @return myAdditionalProperties
  **/
  @javax.annotation.Nullable
  public Map<String, List<Integer>> getMyAdditionalProperties() {
    return myAdditionalProperties;
  }


  public void setMyAdditionalProperties(Map<String, List<Integer>> myAdditionalProperties) {
    this.myAdditionalProperties = myAdditionalProperties;
  }

  public DataTypes200Response myObject(DataTypes200ResponseMyObject myObject) {

    this.myObject = myObject;
    return this;
  }

   /**
   * Get myObject
   * @return myObject
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyObject getMyObject() {
    return myObject;
  }


  public void setMyObject(DataTypes200ResponseMyObject myObject) {
    this.myObject = myObject;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200Response dataTypes200Response = (DataTypes200Response) o;
    return Objects.equals(this.myInt, dataTypes200Response.myInt) &&
        Objects.equals(this.myExclusiveInt, dataTypes200Response.myExclusiveInt) &&
        Objects.equals(this.myString, dataTypes200Response.myString) &&
        Objects.equals(this.myStringLength, dataTypes200Response.myStringLength) &&
        Objects.equals(this.myLongMinStringLength, dataTypes200Response.myLongMinStringLength) &&
        Objects.equals(this.myBool, dataTypes200Response.myBool) &&
        Objects.equals(this.myNumber, dataTypes200Response.myNumber) &&
        Objects.equals(this.myDateArray, dataTypes200Response.myDateArray) &&
        Objects.equals(this.myEmail, dataTypes200Response.myEmail) &&
        Objects.equals(this.myUrl, dataTypes200Response.myUrl) &&
        Objects.equals(this.myHostname, dataTypes200Response.myHostname) &&
        Objects.equals(this.myIpv4, dataTypes200Response.myIpv4) &&
        Objects.equals(this.myIpv6, dataTypes200Response.myIpv6) &&
        Objects.equals(this.myUuid, dataTypes200Response.myUuid) &&
        Objects.equals(this.myByte, dataTypes200Response.myByte) &&
        Objects.equals(this.myConstrainedByte, dataTypes200Response.myConstrainedByte) &&
        Objects.equals(this.myDateTime, dataTypes200Response.myDateTime) &&
        Objects.equals(this.myRegexPattern, dataTypes200Response.myRegexPattern) &&
        Objects.equals(this.myOneOf, dataTypes200Response.myOneOf) &&
        Objects.equals(this.myAnyOf, dataTypes200Response.myAnyOf) &&
        Objects.equals(this.myAllOf, dataTypes200Response.myAllOf) &&
        Objects.equals(this.myNot, dataTypes200Response.myNot) &&
        Objects.equals(this.myNotString, dataTypes200Response.myNotString) &&
        Objects.equals(this.myAdditionalProperties, dataTypes200Response.myAdditionalProperties) &&
        Objects.equals(this.myObject, dataTypes200Response.myObject);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(myInt, myExclusiveInt, myString, myStringLength, myLongMinStringLength, myBool, myNumber, myDateArray, myEmail, myUrl, myHostname, myIpv4, myIpv6, myUuid, myByte, myConstrainedByte, myDateTime, myRegexPattern, myOneOf, myAnyOf, myAllOf, myNot, myNotString, myAdditionalProperties, myObject);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200Response {\\n");
    sb.append("    myInt: ").append(toIndentedString(myInt)).append("\\n");
    sb.append("    myExclusiveInt: ").append(toIndentedString(myExclusiveInt)).append("\\n");
    sb.append("    myString: ").append(toIndentedString(myString)).append("\\n");
    sb.append("    myStringLength: ").append(toIndentedString(myStringLength)).append("\\n");
    sb.append("    myLongMinStringLength: ").append(toIndentedString(myLongMinStringLength)).append("\\n");
    sb.append("    myBool: ").append(toIndentedString(myBool)).append("\\n");
    sb.append("    myNumber: ").append(toIndentedString(myNumber)).append("\\n");
    sb.append("    myDateArray: ").append(toIndentedString(myDateArray)).append("\\n");
    sb.append("    myEmail: ").append(toIndentedString(myEmail)).append("\\n");
    sb.append("    myUrl: ").append(toIndentedString(myUrl)).append("\\n");
    sb.append("    myHostname: ").append(toIndentedString(myHostname)).append("\\n");
    sb.append("    myIpv4: ").append(toIndentedString(myIpv4)).append("\\n");
    sb.append("    myIpv6: ").append(toIndentedString(myIpv6)).append("\\n");
    sb.append("    myUuid: ").append(toIndentedString(myUuid)).append("\\n");
    sb.append("    myByte: ").append(toIndentedString(myByte)).append("\\n");
    sb.append("    myConstrainedByte: ").append(toIndentedString(myConstrainedByte)).append("\\n");
    sb.append("    myDateTime: ").append(toIndentedString(myDateTime)).append("\\n");
    sb.append("    myRegexPattern: ").append(toIndentedString(myRegexPattern)).append("\\n");
    sb.append("    myOneOf: ").append(toIndentedString(myOneOf)).append("\\n");
    sb.append("    myAnyOf: ").append(toIndentedString(myAnyOf)).append("\\n");
    sb.append("    myAllOf: ").append(toIndentedString(myAllOf)).append("\\n");
    sb.append("    myNot: ").append(toIndentedString(myNot)).append("\\n");
    sb.append("    myNotString: ").append(toIndentedString(myNotString)).append("\\n");
    sb.append("    myAdditionalProperties: ").append(toIndentedString(myAdditionalProperties)).append("\\n");
    sb.append("    myObject: ").append(toIndentedString(myObject)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("myInt");
    openapiFields.add("myExclusiveInt");
    openapiFields.add("myString");
    openapiFields.add("myStringLength");
    openapiFields.add("myLongMinStringLength");
    openapiFields.add("myBool");
    openapiFields.add("myNumber");
    openapiFields.add("myDateArray");
    openapiFields.add("myEmail");
    openapiFields.add("myUrl");
    openapiFields.add("myHostname");
    openapiFields.add("myIpv4");
    openapiFields.add("myIpv6");
    openapiFields.add("myUuid");
    openapiFields.add("myByte");
    openapiFields.add("myConstrainedByte");
    openapiFields.add("myDateTime");
    openapiFields.add("myRegexPattern");
    openapiFields.add("myOneOf");
    openapiFields.add("myAnyOf");
    openapiFields.add("myAllOf");
    openapiFields.add("myNot");
    openapiFields.add("myNotString");
    openapiFields.add("myAdditionalProperties");
    openapiFields.add("myObject");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200Response
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200Response.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200Response is not found in the empty JSON string", DataTypes200Response.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200Response.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200Response\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("myString") != null && !jsonObj.get("myString").isJsonNull()) && !jsonObj.get("myString").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myString\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myString").toString()));
      }
      if ((jsonObj.get("myStringLength") != null && !jsonObj.get("myStringLength").isJsonNull()) && !jsonObj.get("myStringLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myStringLength\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myStringLength").toString()));
      }
      if ((jsonObj.get("myLongMinStringLength") != null && !jsonObj.get("myLongMinStringLength").isJsonNull()) && !jsonObj.get("myLongMinStringLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myLongMinStringLength\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myLongMinStringLength").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("myDateArray") != null && !jsonObj.get("myDateArray").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myDateArray\` to be an array in the JSON string but got \`%s\`", jsonObj.get("myDateArray").toString()));
      }
      if ((jsonObj.get("myDateArray") != null && !jsonObj.get("myDateArray").isJsonNull()) && !jsonObj.get("myDateArray").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myDateArray\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myDateArray").toString()));
      }
      if ((jsonObj.get("myEmail") != null && !jsonObj.get("myEmail").isJsonNull()) && !jsonObj.get("myEmail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myEmail\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myEmail").toString()));
      }
      if ((jsonObj.get("myUrl") != null && !jsonObj.get("myUrl").isJsonNull()) && !jsonObj.get("myUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myUrl\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myUrl").toString()));
      }
      if ((jsonObj.get("myHostname") != null && !jsonObj.get("myHostname").isJsonNull()) && !jsonObj.get("myHostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myHostname\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myHostname").toString()));
      }
      if ((jsonObj.get("myIpv4") != null && !jsonObj.get("myIpv4").isJsonNull()) && !jsonObj.get("myIpv4").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myIpv4\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myIpv4").toString()));
      }
      if ((jsonObj.get("myIpv6") != null && !jsonObj.get("myIpv6").isJsonNull()) && !jsonObj.get("myIpv6").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myIpv6\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myIpv6").toString()));
      }
      if ((jsonObj.get("myUuid") != null && !jsonObj.get("myUuid").isJsonNull()) && !jsonObj.get("myUuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myUuid\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myUuid").toString()));
      }
      if ((jsonObj.get("myByte") != null && !jsonObj.get("myByte").isJsonNull()) && !jsonObj.get("myByte").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myByte\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myByte").toString()));
      }
      if ((jsonObj.get("myConstrainedByte") != null && !jsonObj.get("myConstrainedByte").isJsonNull()) && !jsonObj.get("myConstrainedByte").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myConstrainedByte\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myConstrainedByte").toString()));
      }
      if ((jsonObj.get("myDateTime") != null && !jsonObj.get("myDateTime").isJsonNull()) && !jsonObj.get("myDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myDateTime\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myDateTime").toString()));
      }
      if ((jsonObj.get("myRegexPattern") != null && !jsonObj.get("myRegexPattern").isJsonNull()) && !jsonObj.get("myRegexPattern").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`myRegexPattern\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("myRegexPattern").toString()));
      }
      // validate the optional field \`myOneOf\`
      if (jsonObj.get("myOneOf") != null && !jsonObj.get("myOneOf").isJsonNull()) {
        DataTypes200ResponseMyOneOf.validateJsonObject(jsonObj.getAsJsonObject("myOneOf"));
      }
      // validate the optional field \`myAnyOf\`
      if (jsonObj.get("myAnyOf") != null && !jsonObj.get("myAnyOf").isJsonNull()) {
        DataTypes200ResponseMyAnyOf.validateJsonObject(jsonObj.getAsJsonObject("myAnyOf"));
      }
      // validate the optional field \`myAllOf\`
      if (jsonObj.get("myAllOf") != null && !jsonObj.get("myAllOf").isJsonNull()) {
        DataTypes200ResponseMyAllOf.validateJsonObject(jsonObj.getAsJsonObject("myAllOf"));
      }
      // validate the optional field \`myObject\`
      if (jsonObj.get("myObject") != null && !jsonObj.get("myObject").isJsonNull()) {
        DataTypes200ResponseMyObject.validateJsonObject(jsonObj.getAsJsonObject("myObject"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200Response.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200Response' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200Response> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200Response.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200Response>() {
           @Override
           public void write(JsonWriter out, DataTypes200Response value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200Response read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200Response given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200Response
  * @throws IOException if the JSON string is invalid with respect to DataTypes200Response
  */
  public static DataTypes200Response fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200Response.class);
  }

 /**
  * Convert an instance of DataTypes200Response to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyAllOf.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200ResponseMyAllOf
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyAllOf {
  public static final String SERIALIZED_NAME_FIRST = "first";
  @SerializedName(SERIALIZED_NAME_FIRST)
  private String first;

  public static final String SERIALIZED_NAME_SECOND = "second";
  @SerializedName(SERIALIZED_NAME_SECOND)
  private String second;

  public DataTypes200ResponseMyAllOf() {
  }

  public DataTypes200ResponseMyAllOf first(String first) {

    this.first = first;
    return this;
  }

   /**
   * Get first
   * @return first
  **/
  @javax.annotation.Nullable
  public String getFirst() {
    return first;
  }


  public void setFirst(String first) {
    this.first = first;
  }

  public DataTypes200ResponseMyAllOf second(String second) {

    this.second = second;
    return this;
  }

   /**
   * Get second
   * @return second
  **/
  @javax.annotation.Nullable
  public String getSecond() {
    return second;
  }


  public void setSecond(String second) {
    this.second = second;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200ResponseMyAllOf dataTypes200ResponseMyAllOf = (DataTypes200ResponseMyAllOf) o;
    return Objects.equals(this.first, dataTypes200ResponseMyAllOf.first) &&
        Objects.equals(this.second, dataTypes200ResponseMyAllOf.second);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(first, second);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200ResponseMyAllOf {\\n");
    sb.append("    first: ").append(toIndentedString(first)).append("\\n");
    sb.append("    second: ").append(toIndentedString(second)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("first");
    openapiFields.add("second");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyAllOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200ResponseMyAllOf.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200ResponseMyAllOf is not found in the empty JSON string", DataTypes200ResponseMyAllOf.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200ResponseMyAllOf.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200ResponseMyAllOf\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("first") != null && !jsonObj.get("first").isJsonNull()) && !jsonObj.get("first").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`first\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("first").toString()));
      }
      if ((jsonObj.get("second") != null && !jsonObj.get("second").isJsonNull()) && !jsonObj.get("second").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`second\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("second").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200ResponseMyAllOf.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200ResponseMyAllOf' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200ResponseMyAllOf> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200ResponseMyAllOf.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyAllOf>() {
           @Override
           public void write(JsonWriter out, DataTypes200ResponseMyAllOf value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200ResponseMyAllOf read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyAllOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyAllOf
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyAllOf
  */
  public static DataTypes200ResponseMyAllOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyAllOf.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyAllOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyAnyOf.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyAnyOf extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(DataTypes200ResponseMyAnyOf.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!DataTypes200ResponseMyAnyOf.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'DataTypes200ResponseMyAnyOf' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<BigDecimal> adapterBigDecimal = gson.getDelegateAdapter(this, TypeToken.get(BigDecimal.class));

            return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyAnyOf>() {
                @Override
                public void write(JsonWriter out, DataTypes200ResponseMyAnyOf value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`BigDecimal\`
                    if (value.getActualInstance() instanceof BigDecimal) {
                        JsonObject obj = adapterBigDecimal.toJsonTree((BigDecimal)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, BigDecimal");
                }

                @Override
                public DataTypes200ResponseMyAnyOf read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();


                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'String'");
                        DataTypes200ResponseMyAnyOf ret = new DataTypes200ResponseMyAnyOf();
                        ret.setActualInstance(adapterString.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize BigDecimal
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BigDecimal.validateJsonObject(jsonObject);
                        log.log(Level.FINER, "Input data matches schema 'BigDecimal'");
                        DataTypes200ResponseMyAnyOf ret = new DataTypes200ResponseMyAnyOf();
                        ret.setActualInstance(adapterBigDecimal.fromJsonTree(jsonObject));
                        return ret;
                    } catch (Exception e) {
                        // deserialization failed, continue
                        log.log(Level.FINER, "Input data does not match schema 'BigDecimal'", e);
                    }


                    throw new IOException(String.format("Failed deserialization for DataTypes200ResponseMyAnyOf: no class matched. JSON: %s", jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public DataTypes200ResponseMyAnyOf() {
        super("anyOf", Boolean.FALSE);
    }

    public DataTypes200ResponseMyAnyOf(String o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public DataTypes200ResponseMyAnyOf(BigDecimal o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("BigDecimal", new GenericType<BigDecimal>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return DataTypes200ResponseMyAnyOf.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * String, BigDecimal
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BigDecimal) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, BigDecimal");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, BigDecimal
     *
     * @return The actual instance (String, BigDecimal)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`BigDecimal\`. If the actual instance is not \`BigDecimal\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`BigDecimal\`
     * @throws ClassCastException if the instance is not \`BigDecimal\`
     */
    public BigDecimal getBigDecimal() throws ClassCastException {
        return (BigDecimal)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyAnyOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate anyOf schemas one by one
    int validCount = 0;
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    // validate the json string with BigDecimal
    try {
      BigDecimal.validateJsonObject(jsonObj);
      return; // return earlier as at least one schema is valid with respect to the Json object
      //validCount++;
    } catch (Exception e) {
      // continue to the next one
    }
    if (validCount == 0) {
      throw new IOException(String.format("The JSON string is invalid for DataTypes200ResponseMyAnyOf with anyOf schemas: String, BigDecimal. JSON: %s", jsonObj.toString()));
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyAnyOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyAnyOf
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyAnyOf
  */
  public static DataTypes200ResponseMyAnyOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyAnyOf.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyAnyOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyNotNot.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200ResponseMyNotNot
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyNotNot {
  public static final String SERIALIZED_NAME_FOO = "foo";
  @SerializedName(SERIALIZED_NAME_FOO)
  private String foo;

  public DataTypes200ResponseMyNotNot() {
  }

  public DataTypes200ResponseMyNotNot foo(String foo) {

    this.foo = foo;
    return this;
  }

   /**
   * Get foo
   * @return foo
  **/
  @javax.annotation.Nullable
  public String getFoo() {
    return foo;
  }


  public void setFoo(String foo) {
    this.foo = foo;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200ResponseMyNotNot dataTypes200ResponseMyNotNot = (DataTypes200ResponseMyNotNot) o;
    return Objects.equals(this.foo, dataTypes200ResponseMyNotNot.foo);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(foo);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200ResponseMyNotNot {\\n");
    sb.append("    foo: ").append(toIndentedString(foo)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("foo");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyNotNot
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200ResponseMyNotNot.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200ResponseMyNotNot is not found in the empty JSON string", DataTypes200ResponseMyNotNot.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200ResponseMyNotNot.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200ResponseMyNotNot\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("foo") != null && !jsonObj.get("foo").isJsonNull()) && !jsonObj.get("foo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`foo\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("foo").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200ResponseMyNotNot.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200ResponseMyNotNot' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200ResponseMyNotNot> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200ResponseMyNotNot.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyNotNot>() {
           @Override
           public void write(JsonWriter out, DataTypes200ResponseMyNotNot value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200ResponseMyNotNot read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyNotNot given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyNotNot
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyNotNot
  */
  public static DataTypes200ResponseMyNotNot fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyNotNot.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyNotNot to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyObject.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.DataTypes200ResponseMyObjectOne;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200ResponseMyObject
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyObject {
  public static final String SERIALIZED_NAME_ONE = "one";
  @SerializedName(SERIALIZED_NAME_ONE)
  private DataTypes200ResponseMyObjectOne one;

  public static final String SERIALIZED_NAME_ONE_STRING = "oneString";
  @SerializedName(SERIALIZED_NAME_ONE_STRING)
  private String oneString;

  public DataTypes200ResponseMyObject() {
  }

  public DataTypes200ResponseMyObject one(DataTypes200ResponseMyObjectOne one) {

    this.one = one;
    return this;
  }

   /**
   * Get one
   * @return one
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyObjectOne getOne() {
    return one;
  }


  public void setOne(DataTypes200ResponseMyObjectOne one) {
    this.one = one;
  }

  public DataTypes200ResponseMyObject oneString(String oneString) {

    this.oneString = oneString;
    return this;
  }

   /**
   * Get oneString
   * @return oneString
  **/
  @javax.annotation.Nullable
  public String getOneString() {
    return oneString;
  }


  public void setOneString(String oneString) {
    this.oneString = oneString;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200ResponseMyObject dataTypes200ResponseMyObject = (DataTypes200ResponseMyObject) o;
    return Objects.equals(this.one, dataTypes200ResponseMyObject.one) &&
        Objects.equals(this.oneString, dataTypes200ResponseMyObject.oneString);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(one, oneString);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200ResponseMyObject {\\n");
    sb.append("    one: ").append(toIndentedString(one)).append("\\n");
    sb.append("    oneString: ").append(toIndentedString(oneString)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("one");
    openapiFields.add("oneString");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyObject
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200ResponseMyObject.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200ResponseMyObject is not found in the empty JSON string", DataTypes200ResponseMyObject.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200ResponseMyObject.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200ResponseMyObject\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`one\`
      if (jsonObj.get("one") != null && !jsonObj.get("one").isJsonNull()) {
        DataTypes200ResponseMyObjectOne.validateJsonObject(jsonObj.getAsJsonObject("one"));
      }
      if ((jsonObj.get("oneString") != null && !jsonObj.get("oneString").isJsonNull()) && !jsonObj.get("oneString").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`oneString\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("oneString").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200ResponseMyObject.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200ResponseMyObject' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200ResponseMyObject> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200ResponseMyObject.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyObject>() {
           @Override
           public void write(JsonWriter out, DataTypes200ResponseMyObject value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200ResponseMyObject read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyObject given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyObject
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyObject
  */
  public static DataTypes200ResponseMyObject fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyObject.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyObject to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyObjectOne.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.DataTypes200ResponseMyObjectOneTwo;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200ResponseMyObjectOne
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyObjectOne {
  public static final String SERIALIZED_NAME_TWO_STRING = "twoString";
  @SerializedName(SERIALIZED_NAME_TWO_STRING)
  private String twoString;

  public static final String SERIALIZED_NAME_TWO = "two";
  @SerializedName(SERIALIZED_NAME_TWO)
  private DataTypes200ResponseMyObjectOneTwo two;

  public DataTypes200ResponseMyObjectOne() {
  }

  public DataTypes200ResponseMyObjectOne twoString(String twoString) {

    this.twoString = twoString;
    return this;
  }

   /**
   * Get twoString
   * @return twoString
  **/
  @javax.annotation.Nullable
  public String getTwoString() {
    return twoString;
  }


  public void setTwoString(String twoString) {
    this.twoString = twoString;
  }

  public DataTypes200ResponseMyObjectOne two(DataTypes200ResponseMyObjectOneTwo two) {

    this.two = two;
    return this;
  }

   /**
   * Get two
   * @return two
  **/
  @javax.annotation.Nullable
  public DataTypes200ResponseMyObjectOneTwo getTwo() {
    return two;
  }


  public void setTwo(DataTypes200ResponseMyObjectOneTwo two) {
    this.two = two;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200ResponseMyObjectOne dataTypes200ResponseMyObjectOne = (DataTypes200ResponseMyObjectOne) o;
    return Objects.equals(this.twoString, dataTypes200ResponseMyObjectOne.twoString) &&
        Objects.equals(this.two, dataTypes200ResponseMyObjectOne.two);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(twoString, two);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200ResponseMyObjectOne {\\n");
    sb.append("    twoString: ").append(toIndentedString(twoString)).append("\\n");
    sb.append("    two: ").append(toIndentedString(two)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("twoString");
    openapiFields.add("two");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyObjectOne
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200ResponseMyObjectOne.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200ResponseMyObjectOne is not found in the empty JSON string", DataTypes200ResponseMyObjectOne.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200ResponseMyObjectOne.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200ResponseMyObjectOne\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("twoString") != null && !jsonObj.get("twoString").isJsonNull()) && !jsonObj.get("twoString").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`twoString\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("twoString").toString()));
      }
      // validate the optional field \`two\`
      if (jsonObj.get("two") != null && !jsonObj.get("two").isJsonNull()) {
        DataTypes200ResponseMyObjectOneTwo.validateJsonObject(jsonObj.getAsJsonObject("two"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200ResponseMyObjectOne.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200ResponseMyObjectOne' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200ResponseMyObjectOne> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200ResponseMyObjectOne.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyObjectOne>() {
           @Override
           public void write(JsonWriter out, DataTypes200ResponseMyObjectOne value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200ResponseMyObjectOne read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyObjectOne given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyObjectOne
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyObjectOne
  */
  public static DataTypes200ResponseMyObjectOne fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyObjectOne.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyObjectOne to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyObjectOneTwo.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * DataTypes200ResponseMyObjectOneTwo
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyObjectOneTwo {
  public static final String SERIALIZED_NAME_THREE_STRING = "threeString";
  @SerializedName(SERIALIZED_NAME_THREE_STRING)
  private String threeString;

  public DataTypes200ResponseMyObjectOneTwo() {
  }

  public DataTypes200ResponseMyObjectOneTwo threeString(String threeString) {

    this.threeString = threeString;
    return this;
  }

   /**
   * Get threeString
   * @return threeString
  **/
  @javax.annotation.Nullable
  public String getThreeString() {
    return threeString;
  }


  public void setThreeString(String threeString) {
    this.threeString = threeString;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataTypes200ResponseMyObjectOneTwo dataTypes200ResponseMyObjectOneTwo = (DataTypes200ResponseMyObjectOneTwo) o;
    return Objects.equals(this.threeString, dataTypes200ResponseMyObjectOneTwo.threeString);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(threeString);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataTypes200ResponseMyObjectOneTwo {\\n");
    sb.append("    threeString: ").append(toIndentedString(threeString)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("threeString");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyObjectOneTwo
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataTypes200ResponseMyObjectOneTwo.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataTypes200ResponseMyObjectOneTwo is not found in the empty JSON string", DataTypes200ResponseMyObjectOneTwo.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataTypes200ResponseMyObjectOneTwo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`DataTypes200ResponseMyObjectOneTwo\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("threeString") != null && !jsonObj.get("threeString").isJsonNull()) && !jsonObj.get("threeString").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`threeString\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("threeString").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataTypes200ResponseMyObjectOneTwo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataTypes200ResponseMyObjectOneTwo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataTypes200ResponseMyObjectOneTwo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataTypes200ResponseMyObjectOneTwo.class));

       return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyObjectOneTwo>() {
           @Override
           public void write(JsonWriter out, DataTypes200ResponseMyObjectOneTwo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataTypes200ResponseMyObjectOneTwo read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyObjectOneTwo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyObjectOneTwo
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyObjectOneTwo
  */
  public static DataTypes200ResponseMyObjectOneTwo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyObjectOneTwo.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyObjectOneTwo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/DataTypes200ResponseMyOneOf.java": "/*
 * Data Types
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

@lombok.experimental.SuperBuilder
public class DataTypes200ResponseMyOneOf extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(DataTypes200ResponseMyOneOf.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!DataTypes200ResponseMyOneOf.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'DataTypes200ResponseMyOneOf' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<String> adapterString = gson.getDelegateAdapter(this, TypeToken.get(String.class));
            final TypeAdapter<BigDecimal> adapterBigDecimal = gson.getDelegateAdapter(this, TypeToken.get(BigDecimal.class));

            return (TypeAdapter<T>) new TypeAdapter<DataTypes200ResponseMyOneOf>() {
                @Override
                public void write(JsonWriter out, DataTypes200ResponseMyOneOf value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type \`String\`
                    if (value.getActualInstance() instanceof String) {
                        JsonObject obj = adapterString.toJsonTree((String)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type \`BigDecimal\`
                    if (value.getActualInstance() instanceof BigDecimal) {
                        JsonObject obj = adapterBigDecimal.toJsonTree((BigDecimal)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: String, BigDecimal");
                }

                @Override
                public DataTypes200ResponseMyOneOf read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize String
                    try {
                        // validate the JSON object to see if any exception is thrown
                        String.validateJsonObject(jsonObject);
                        actualAdapter = adapterString;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'String'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'String'", e);
                    }

                    // deserialize BigDecimal
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BigDecimal.validateJsonObject(jsonObject);
                        actualAdapter = adapterBigDecimal;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BigDecimal'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BigDecimal failed with \`%s\`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BigDecimal'", e);
                    }

                    if (match == 1) {
                        DataTypes200ResponseMyOneOf ret = new DataTypes200ResponseMyOneOf();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for DataTypes200ResponseMyOneOf: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public DataTypes200ResponseMyOneOf() {
        super("oneOf", Boolean.FALSE);
    }

    public DataTypes200ResponseMyOneOf(String o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public DataTypes200ResponseMyOneOf(BigDecimal o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("String", new GenericType<String>() {
        });
        schemas.put("BigDecimal", new GenericType<BigDecimal>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return DataTypes200ResponseMyOneOf.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * String, BigDecimal
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof String) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BigDecimal) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be String, BigDecimal");
    }

    /**
     * Get the actual instance, which can be the following:
     * String, BigDecimal
     *
     * @return The actual instance (String, BigDecimal)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of \`String\`. If the actual instance is not \`String\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`String\`
     * @throws ClassCastException if the instance is not \`String\`
     */
    public String getString() throws ClassCastException {
        return (String)super.getActualInstance();
    }

    /**
     * Get the actual instance of \`BigDecimal\`. If the actual instance is not \`BigDecimal\`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of \`BigDecimal\`
     * @throws ClassCastException if the instance is not \`BigDecimal\`
     */
    public BigDecimal getBigDecimal() throws ClassCastException {
        return (BigDecimal)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataTypes200ResponseMyOneOf
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with String
    try {
      String.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for String failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with BigDecimal
    try {
      BigDecimal.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for BigDecimal failed with \`%s\`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for DataTypes200ResponseMyOneOf with oneOf schemas: String, BigDecimal. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of DataTypes200ResponseMyOneOf given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataTypes200ResponseMyOneOf
  * @throws IOException if the JSON string is invalid with respect to DataTypes200ResponseMyOneOf
  */
  public static DataTypes200ResponseMyOneOf fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataTypes200ResponseMyOneOf.class);
  }

 /**
  * Convert an instance of DataTypes200ResponseMyOneOf to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }

}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With default-response.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello0Response.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/SayHelloResponseContent.java
src/main/java/test/test/runtime/model/ServiceUnavailableErrorResponseContent.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.SayHelloResponseContent.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.ServiceUnavailableErrorResponseContent.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.SayHelloResponseContent;
import test.test.runtime.model.ServiceUnavailableErrorResponseContent;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call sayHelloCall(String name, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/hello";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call sayHelloValidateBeforeCall(String name, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'name' is set
        if (name == null) {
            throw new ApiException("Missing the required parameter 'name' when calling sayHello(Async)");
        }

        return sayHelloCall(name, _callback);

    }

    private ApiResponse<SayHelloResponseContent> sayHelloWithHttpInfo(String name) throws ApiException {
        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(name, null);
        Type localVarReturnType = new TypeToken<SayHelloResponseContent>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call sayHelloAsync(String name, final ApiCallback<SayHelloResponseContent> _callback) throws ApiException {

        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(name, _callback);
        Type localVarReturnType = new TypeToken<SayHelloResponseContent>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIsayHelloRequest {
        private final String name;

        private APIsayHelloRequest(String name) {
            this.name = name;
        }

        /**
         * Build call for sayHello
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An error due to the client not being authorized to access the resource </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return sayHelloCall(name, _callback);
        }

        /**
         * Execute sayHello request
         * @return SayHelloResponseContent
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An error due to the client not being authorized to access the resource </td><td>  -  </td></tr>
         </table>
         */
        public SayHelloResponseContent execute() throws ApiException {
            ApiResponse<SayHelloResponseContent> localVarResp = sayHelloWithHttpInfo(name);
            return localVarResp.getData();
        }

        /**
         * Execute sayHello request with HTTP info returned
         * @return ApiResponse&lt;SayHelloResponseContent&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An error due to the client not being authorized to access the resource </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SayHelloResponseContent> executeWithHttpInfo() throws ApiException {
            return sayHelloWithHttpInfo(name);
        }

        /**
         * Execute sayHello request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An error due to the client not being authorized to access the resource </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SayHelloResponseContent> _callback) throws ApiException {
            return sayHelloAsync(name, _callback);
        }
    }

    /**
     * 
     * 
     * @param name  (required)
     * @return APIsayHelloRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An error due to the client not being authorized to access the resource </td><td>  -  </td></tr>
     </table>
     */
    
    public APIsayHelloRequest sayHello(String name) {
        return new APIsayHelloRequest(name);
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.say_hello.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String sayHelloMethodAndPath = Handlers.concatMethodAndPath("GET", "/hello");

    private final SayHello constructedSayHello;

    /**
     * This method must return your implementation of the SayHello operation
     */
    public abstract SayHello sayHello();

    private static enum Route {
        sayHelloRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(sayHelloMethodAndPath, Route.sayHelloRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedSayHello = this.sayHello();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case sayHelloRoute:
                List<Interceptor<SayHelloInput>> sayHelloInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                sayHelloInterceptors.addAll(this.getInterceptors());
                return this.constructedSayHello.handleRequestWithAdditionalInterceptors(event, context, sayHelloInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the sayHello operation
 */
public abstract class SayHello implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the sayHello operation
     */
    public abstract SayHelloResponse handle(final SayHelloRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<SayHelloInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(SayHello.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<SayHelloInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<SayHelloInput>> getHandlerInterceptors() {
        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<SayHelloInput> buildChain(List<Interceptor<SayHelloInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<SayHelloInput>() {
            @Override
            public Response next(ChainedRequestInput<SayHelloInput> input) {
                return handle(new SayHelloRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<SayHelloInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final SayHelloInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<SayHelloInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public SayHelloInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new SayHelloInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        if (statusCode == 0 && "ServiceUnavailableErrorResponseContent".endsWith("ResponseContent")) {
            headers.put("x-amzn-errortype", "ServiceUnavailableErrorResponseContent".substring(0, "ServiceUnavailableErrorResponseContent".length() - "ResponseContent".length()));
        }
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<SayHelloInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "sayHello");

        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        SayHelloInput input;

        try {
            input = new SayHelloInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello0Response.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 0 for the sayHello operation
 */
public class SayHello0Response extends RuntimeException implements SayHelloResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final ServiceUnavailableErrorResponseContent typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private SayHello0Response(final ServiceUnavailableErrorResponseContent body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 0;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public ServiceUnavailableErrorResponseContent getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a SayHello0Response with a body
     */
    public static SayHello0Response of(final ServiceUnavailableErrorResponseContent body) {
        return new SayHello0Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a SayHello0Response with a body and headers
     */
    public static SayHello0Response of(final ServiceUnavailableErrorResponseContent body, final Map<String, String> headers) {
        return new SayHello0Response(body, headers, new HashMap<>());
    }

    /**
     * Create a SayHello0Response with a body, headers and multi-value headers
     */
    public static SayHello0Response of(final ServiceUnavailableErrorResponseContent body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new SayHello0Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the sayHello operation
 */
public class SayHello200Response extends RuntimeException implements SayHelloResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final SayHelloResponseContent typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private SayHello200Response(final SayHelloResponseContent body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public SayHelloResponseContent getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a SayHello200Response with a body
     */
    public static SayHello200Response of(final SayHelloResponseContent body) {
        return new SayHello200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body and headers
     */
    public static SayHello200Response of(final SayHelloResponseContent body, final Map<String, String> headers) {
        return new SayHello200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body, headers and multi-value headers
     */
    public static SayHello200Response of(final SayHelloResponseContent body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new SayHello200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the sayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final SayHelloRequestParameters requestParameters;

    public SayHelloInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new SayHelloRequestParameters(event);
    }

    public SayHelloRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the sayHello operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestInput implements RequestInput<SayHelloInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final SayHelloInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public SayHelloInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the SayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestParameters {
    private final String name;

    public SayHelloRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

        this.name = Handlers.coerceStringParameter("name", true, decodedStringParameters);
    }

    public String getName() {
        return this.name;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the sayHello operation
 */
public interface SayHelloResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T sayHello;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("sayHello", this.sayHello);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("sayHello", OperationLookupEntry.builder()
            .path("/hello")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .sayHello(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/SayHelloResponseContent.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * SayHelloResponseContent
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class SayHelloResponseContent {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public SayHelloResponseContent() {
  }

  public SayHelloResponseContent id(UUID id) {

    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nullable
  public UUID getId() {
    return id;
  }


  public void setId(UUID id) {
    this.id = id;
  }

  public SayHelloResponseContent message(String message) {

    this.message = message;
    return this;
  }

   /**
   * Get message
   * @return message
  **/
  @javax.annotation.Nonnull
  public String getMessage() {
    return message;
  }


  public void setMessage(String message) {
    this.message = message;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SayHelloResponseContent sayHelloResponseContent = (SayHelloResponseContent) o;
    return Objects.equals(this.id, sayHelloResponseContent.id) &&
        Objects.equals(this.message, sayHelloResponseContent.message);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, message);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SayHelloResponseContent {\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("message");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("message");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to SayHelloResponseContent
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!SayHelloResponseContent.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SayHelloResponseContent is not found in the empty JSON string", SayHelloResponseContent.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!SayHelloResponseContent.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`SayHelloResponseContent\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SayHelloResponseContent.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`message\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("message").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SayHelloResponseContent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SayHelloResponseContent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SayHelloResponseContent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SayHelloResponseContent.class));

       return (TypeAdapter<T>) new TypeAdapter<SayHelloResponseContent>() {
           @Override
           public void write(JsonWriter out, SayHelloResponseContent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SayHelloResponseContent read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of SayHelloResponseContent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of SayHelloResponseContent
  * @throws IOException if the JSON string is invalid with respect to SayHelloResponseContent
  */
  public static SayHelloResponseContent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SayHelloResponseContent.class);
  }

 /**
  * Convert an instance of SayHelloResponseContent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/ServiceUnavailableErrorResponseContent.java": "/*
 * My API
 * See https://github.com/aws/aws-pdk/issues/841
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * ServiceUnavailableErrorResponseContent
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class ServiceUnavailableErrorResponseContent {
  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public ServiceUnavailableErrorResponseContent() {
  }

  public ServiceUnavailableErrorResponseContent message(String message) {

    this.message = message;
    return this;
  }

   /**
   * Get message
   * @return message
  **/
  @javax.annotation.Nonnull
  public String getMessage() {
    return message;
  }


  public void setMessage(String message) {
    this.message = message;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServiceUnavailableErrorResponseContent serviceUnavailableErrorResponseContent = (ServiceUnavailableErrorResponseContent) o;
    return Objects.equals(this.message, serviceUnavailableErrorResponseContent.message);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(message);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServiceUnavailableErrorResponseContent {\\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("message");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("message");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ServiceUnavailableErrorResponseContent
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ServiceUnavailableErrorResponseContent.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServiceUnavailableErrorResponseContent is not found in the empty JSON string", ServiceUnavailableErrorResponseContent.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ServiceUnavailableErrorResponseContent.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`ServiceUnavailableErrorResponseContent\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ServiceUnavailableErrorResponseContent.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`message\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("message").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ServiceUnavailableErrorResponseContent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ServiceUnavailableErrorResponseContent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ServiceUnavailableErrorResponseContent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ServiceUnavailableErrorResponseContent.class));

       return (TypeAdapter<T>) new TypeAdapter<ServiceUnavailableErrorResponseContent>() {
           @Override
           public void write(JsonWriter out, ServiceUnavailableErrorResponseContent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ServiceUnavailableErrorResponseContent read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ServiceUnavailableErrorResponseContent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ServiceUnavailableErrorResponseContent
  * @throws IOException if the JSON string is invalid with respect to ServiceUnavailableErrorResponseContent
  */
  public static ServiceUnavailableErrorResponseContent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServiceUnavailableErrorResponseContent.class);
  }

 /**
  * Convert an instance of ServiceUnavailableErrorResponseContent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With edge-cases.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersResponse.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumResponse.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsResponse.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParameters200Response.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnum200Response.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywords200Response.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersRequestParameters.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumRequestParameters.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsRequestParameters.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersInput.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumInput.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsInput.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersRequestInput.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumRequestInput.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsRequestInput.java
src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParameters.java
src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnum.java
src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywords.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/InlineEnum200Response.java
src/main/java/test/test/runtime/model/InlineEnum200ResponseCategoryEnum.java
src/main/java/test/test/runtime/model/MyEnum.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.InlineEnum200Response.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.InlineEnum200Response;
import test.test.runtime.model.MyEnum;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call arrayRequestParametersCall(List<String> myStringArrayRequestParams, List<MyEnum> myEnumArrayRequestParams, List<Integer> myIntegerArrayRequestParams, List<Long> myLongArrayRequestParams, List<Integer> myInt32ArrayRequestParams, List<BigDecimal> myNumberArrayRequestParams, List<Float> myFloatArrayRequestParams, List<Double> myDoubleArrayRequestParams, MyEnum myEnumRequestParam, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/array-request-parameters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (myStringArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-string-array-request-params", myStringArrayRequestParams));
        }

        if (myEnumArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-enum-array-request-params", myEnumArrayRequestParams));
        }

        if (myIntegerArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-integer-array-request-params", myIntegerArrayRequestParams));
        }

        if (myLongArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-long-array-request-params", myLongArrayRequestParams));
        }

        if (myInt32ArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-int32-array-request-params", myInt32ArrayRequestParams));
        }

        if (myNumberArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-number-array-request-params", myNumberArrayRequestParams));
        }

        if (myFloatArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-float-array-request-params", myFloatArrayRequestParams));
        }

        if (myDoubleArrayRequestParams != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "my-double-array-request-params", myDoubleArrayRequestParams));
        }

        if (myEnumRequestParam != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("my-enum-request-param", myEnumRequestParam));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call arrayRequestParametersValidateBeforeCall(List<String> myStringArrayRequestParams, List<MyEnum> myEnumArrayRequestParams, List<Integer> myIntegerArrayRequestParams, List<Long> myLongArrayRequestParams, List<Integer> myInt32ArrayRequestParams, List<BigDecimal> myNumberArrayRequestParams, List<Float> myFloatArrayRequestParams, List<Double> myDoubleArrayRequestParams, MyEnum myEnumRequestParam, final ApiCallback _callback) throws ApiException {
        return arrayRequestParametersCall(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam, _callback);

    }

    private ApiResponse<Void> arrayRequestParametersWithHttpInfo(List<String> myStringArrayRequestParams, List<MyEnum> myEnumArrayRequestParams, List<Integer> myIntegerArrayRequestParams, List<Long> myLongArrayRequestParams, List<Integer> myInt32ArrayRequestParams, List<BigDecimal> myNumberArrayRequestParams, List<Float> myFloatArrayRequestParams, List<Double> myDoubleArrayRequestParams, MyEnum myEnumRequestParam) throws ApiException {
        okhttp3.Call localVarCall = arrayRequestParametersValidateBeforeCall(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam, null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call arrayRequestParametersAsync(List<String> myStringArrayRequestParams, List<MyEnum> myEnumArrayRequestParams, List<Integer> myIntegerArrayRequestParams, List<Long> myLongArrayRequestParams, List<Integer> myInt32ArrayRequestParams, List<BigDecimal> myNumberArrayRequestParams, List<Float> myFloatArrayRequestParams, List<Double> myDoubleArrayRequestParams, MyEnum myEnumRequestParam, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = arrayRequestParametersValidateBeforeCall(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIarrayRequestParametersRequest {
        private List<String> myStringArrayRequestParams;
        private List<MyEnum> myEnumArrayRequestParams;
        private List<Integer> myIntegerArrayRequestParams;
        private List<Long> myLongArrayRequestParams;
        private List<Integer> myInt32ArrayRequestParams;
        private List<BigDecimal> myNumberArrayRequestParams;
        private List<Float> myFloatArrayRequestParams;
        private List<Double> myDoubleArrayRequestParams;
        private MyEnum myEnumRequestParam;

        private APIarrayRequestParametersRequest() {
        }

        /**
         * Set myStringArrayRequestParams
         * @param myStringArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myStringArrayRequestParams(List<String> myStringArrayRequestParams) {
            this.myStringArrayRequestParams = myStringArrayRequestParams;
            return this;
        }

        /**
         * Set myEnumArrayRequestParams
         * @param myEnumArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myEnumArrayRequestParams(List<MyEnum> myEnumArrayRequestParams) {
            this.myEnumArrayRequestParams = myEnumArrayRequestParams;
            return this;
        }

        /**
         * Set myIntegerArrayRequestParams
         * @param myIntegerArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myIntegerArrayRequestParams(List<Integer> myIntegerArrayRequestParams) {
            this.myIntegerArrayRequestParams = myIntegerArrayRequestParams;
            return this;
        }

        /**
         * Set myLongArrayRequestParams
         * @param myLongArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myLongArrayRequestParams(List<Long> myLongArrayRequestParams) {
            this.myLongArrayRequestParams = myLongArrayRequestParams;
            return this;
        }

        /**
         * Set myInt32ArrayRequestParams
         * @param myInt32ArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myInt32ArrayRequestParams(List<Integer> myInt32ArrayRequestParams) {
            this.myInt32ArrayRequestParams = myInt32ArrayRequestParams;
            return this;
        }

        /**
         * Set myNumberArrayRequestParams
         * @param myNumberArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myNumberArrayRequestParams(List<BigDecimal> myNumberArrayRequestParams) {
            this.myNumberArrayRequestParams = myNumberArrayRequestParams;
            return this;
        }

        /**
         * Set myFloatArrayRequestParams
         * @param myFloatArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myFloatArrayRequestParams(List<Float> myFloatArrayRequestParams) {
            this.myFloatArrayRequestParams = myFloatArrayRequestParams;
            return this;
        }

        /**
         * Set myDoubleArrayRequestParams
         * @param myDoubleArrayRequestParams  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myDoubleArrayRequestParams(List<Double> myDoubleArrayRequestParams) {
            this.myDoubleArrayRequestParams = myDoubleArrayRequestParams;
            return this;
        }

        /**
         * Set myEnumRequestParam
         * @param myEnumRequestParam  (optional)
         * @return APIarrayRequestParametersRequest
         */
        public APIarrayRequestParametersRequest myEnumRequestParam(MyEnum myEnumRequestParam) {
            this.myEnumRequestParam = myEnumRequestParam;
            return this;
        }

        /**
         * Build call for arrayRequestParameters
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return arrayRequestParametersCall(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam, _callback);
        }

        /**
         * Execute arrayRequestParameters request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            arrayRequestParametersWithHttpInfo(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam);
        }

        /**
         * Execute arrayRequestParameters request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return arrayRequestParametersWithHttpInfo(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam);
        }

        /**
         * Execute arrayRequestParameters request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return arrayRequestParametersAsync(myStringArrayRequestParams, myEnumArrayRequestParams, myIntegerArrayRequestParams, myLongArrayRequestParams, myInt32ArrayRequestParams, myNumberArrayRequestParams, myFloatArrayRequestParams, myDoubleArrayRequestParams, myEnumRequestParam, _callback);
        }
    }

    /**
     * 
     * 
     * @return APIarrayRequestParametersRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIarrayRequestParametersRequest arrayRequestParameters() {
        return new APIarrayRequestParametersRequest();
    }
    private okhttp3.Call inlineEnumCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/inline-enum";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call inlineEnumValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return inlineEnumCall(_callback);

    }

    private ApiResponse<InlineEnum200Response> inlineEnumWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = inlineEnumValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<InlineEnum200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call inlineEnumAsync(final ApiCallback<InlineEnum200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = inlineEnumValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<InlineEnum200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIinlineEnumRequest {

        private APIinlineEnumRequest() {
        }

        /**
         * Build call for inlineEnum
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return inlineEnumCall(_callback);
        }

        /**
         * Execute inlineEnum request
         * @return InlineEnum200Response
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public InlineEnum200Response execute() throws ApiException {
            ApiResponse<InlineEnum200Response> localVarResp = inlineEnumWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute inlineEnum request with HTTP info returned
         * @return ApiResponse&lt;InlineEnum200Response&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<InlineEnum200Response> executeWithHttpInfo() throws ApiException {
            return inlineEnumWithHttpInfo();
        }

        /**
         * Execute inlineEnum request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<InlineEnum200Response> _callback) throws ApiException {
            return inlineEnumAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIinlineEnumRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIinlineEnumRequest inlineEnum() {
        return new APIinlineEnumRequest();
    }
    private okhttp3.Call reservedKeywordsCall(String with, String _if, String propertyClass, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/reserved-keywords";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (with != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with", with));
        }

        if (_if != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("if", _if));
        }

        if (propertyClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("class", propertyClass));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call reservedKeywordsValidateBeforeCall(String with, String _if, String propertyClass, final ApiCallback _callback) throws ApiException {
        return reservedKeywordsCall(with, _if, propertyClass, _callback);

    }

    private ApiResponse<Void> reservedKeywordsWithHttpInfo(String with, String _if, String propertyClass) throws ApiException {
        okhttp3.Call localVarCall = reservedKeywordsValidateBeforeCall(with, _if, propertyClass, null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call reservedKeywordsAsync(String with, String _if, String propertyClass, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = reservedKeywordsValidateBeforeCall(with, _if, propertyClass, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIreservedKeywordsRequest {
        private String with;
        private String _if;
        private String propertyClass;

        private APIreservedKeywordsRequest() {
        }

        /**
         * Set with
         * @param with  (optional)
         * @return APIreservedKeywordsRequest
         */
        public APIreservedKeywordsRequest with(String with) {
            this.with = with;
            return this;
        }

        /**
         * Set _if
         * @param _if  (optional)
         * @return APIreservedKeywordsRequest
         */
        public APIreservedKeywordsRequest _if(String _if) {
            this._if = _if;
            return this;
        }

        /**
         * Set propertyClass
         * @param propertyClass  (optional)
         * @return APIreservedKeywordsRequest
         */
        public APIreservedKeywordsRequest propertyClass(String propertyClass) {
            this.propertyClass = propertyClass;
            return this;
        }

        /**
         * Build call for reservedKeywords
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return reservedKeywordsCall(with, _if, propertyClass, _callback);
        }

        /**
         * Execute reservedKeywords request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            reservedKeywordsWithHttpInfo(with, _if, propertyClass);
        }

        /**
         * Execute reservedKeywords request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return reservedKeywordsWithHttpInfo(with, _if, propertyClass);
        }

        /**
         * Execute reservedKeywords request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return reservedKeywordsAsync(with, _if, propertyClass, _callback);
        }
    }

    /**
     * 
     * 
     * @return APIreservedKeywordsRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIreservedKeywordsRequest reservedKeywords() {
        return new APIreservedKeywordsRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.array_request_parameters.*;
import test.test.runtime.api.handlers.inline_enum.*;
import test.test.runtime.api.handlers.reserved_keywords.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String arrayRequestParametersMethodAndPath = Handlers.concatMethodAndPath("GET", "/array-request-parameters");
    private static final String inlineEnumMethodAndPath = Handlers.concatMethodAndPath("GET", "/inline-enum");
    private static final String reservedKeywordsMethodAndPath = Handlers.concatMethodAndPath("GET", "/reserved-keywords");

    private final ArrayRequestParameters constructedArrayRequestParameters;
    private final InlineEnum constructedInlineEnum;
    private final ReservedKeywords constructedReservedKeywords;

    /**
     * This method must return your implementation of the ArrayRequestParameters operation
     */
    public abstract ArrayRequestParameters arrayRequestParameters();
    /**
     * This method must return your implementation of the InlineEnum operation
     */
    public abstract InlineEnum inlineEnum();
    /**
     * This method must return your implementation of the ReservedKeywords operation
     */
    public abstract ReservedKeywords reservedKeywords();

    private static enum Route {
        arrayRequestParametersRoute,
        inlineEnumRoute,
        reservedKeywordsRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(arrayRequestParametersMethodAndPath, Route.arrayRequestParametersRoute);
        this.routes.put(inlineEnumMethodAndPath, Route.inlineEnumRoute);
        this.routes.put(reservedKeywordsMethodAndPath, Route.reservedKeywordsRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedArrayRequestParameters = this.arrayRequestParameters();
        this.constructedInlineEnum = this.inlineEnum();
        this.constructedReservedKeywords = this.reservedKeywords();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case arrayRequestParametersRoute:
                List<Interceptor<ArrayRequestParametersInput>> arrayRequestParametersInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                arrayRequestParametersInterceptors.addAll(this.getInterceptors());
                return this.constructedArrayRequestParameters.handleRequestWithAdditionalInterceptors(event, context, arrayRequestParametersInterceptors);
            case inlineEnumRoute:
                List<Interceptor<InlineEnumInput>> inlineEnumInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                inlineEnumInterceptors.addAll(this.getInterceptors());
                return this.constructedInlineEnum.handleRequestWithAdditionalInterceptors(event, context, inlineEnumInterceptors);
            case reservedKeywordsRoute:
                List<Interceptor<ReservedKeywordsInput>> reservedKeywordsInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                reservedKeywordsInterceptors.addAll(this.getInterceptors());
                return this.constructedReservedKeywords.handleRequestWithAdditionalInterceptors(event, context, reservedKeywordsInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParameters.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the arrayRequestParameters operation
 */
public abstract class ArrayRequestParameters implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the arrayRequestParameters operation
     */
    public abstract ArrayRequestParametersResponse handle(final ArrayRequestParametersRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<ArrayRequestParametersInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(ArrayRequestParameters.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<ArrayRequestParametersInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<ArrayRequestParametersInput>> getHandlerInterceptors() {
        List<Interceptor<ArrayRequestParametersInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<ArrayRequestParametersInput> buildChain(List<Interceptor<ArrayRequestParametersInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<ArrayRequestParametersInput>() {
            @Override
            public Response next(ChainedRequestInput<ArrayRequestParametersInput> input) {
                return handle(new ArrayRequestParametersRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<ArrayRequestParametersInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final ArrayRequestParametersInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<ArrayRequestParametersInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public ArrayRequestParametersInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new ArrayRequestParametersInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<ArrayRequestParametersInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "arrayRequestParameters");

        List<Interceptor<ArrayRequestParametersInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        ArrayRequestParametersInput input;

        try {
            input = new ArrayRequestParametersInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParameters200Response.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the arrayRequestParameters operation
 */
public class ArrayRequestParameters200Response extends RuntimeException implements ArrayRequestParametersResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private ArrayRequestParameters200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a ArrayRequestParameters200Response without a body
     */
    public static ArrayRequestParameters200Response of() {
        return new ArrayRequestParameters200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a ArrayRequestParameters200Response without a body and headers
     */
    public static ArrayRequestParameters200Response of(final Map<String, String> headers) {
        return new ArrayRequestParameters200Response(headers, new HashMap<>());
    }

    /**
     * Create a ArrayRequestParameters200Response without a body, headers and multi-value headers
     */
    public static ArrayRequestParameters200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new ArrayRequestParameters200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersInput.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the arrayRequestParameters operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ArrayRequestParametersInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final ArrayRequestParametersRequestParameters requestParameters;

    public ArrayRequestParametersInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new ArrayRequestParametersRequestParameters(event);
    }

    public ArrayRequestParametersRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersRequestInput.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the arrayRequestParameters operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ArrayRequestParametersRequestInput implements RequestInput<ArrayRequestParametersInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final ArrayRequestParametersInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public ArrayRequestParametersInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersRequestParameters.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the ArrayRequestParameters operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ArrayRequestParametersRequestParameters {
    private final Optional<List<String>> myStringArrayRequestParams;
    private final Optional<List<MyEnum>> myEnumArrayRequestParams;
    private final Optional<List<Integer>> myIntegerArrayRequestParams;
    private final Optional<List<Long>> myLongArrayRequestParams;
    private final Optional<List<Integer>> myInt32ArrayRequestParams;
    private final Optional<List<BigDecimal>> myNumberArrayRequestParams;
    private final Optional<List<Float>> myFloatArrayRequestParams;
    private final Optional<List<Double>> myDoubleArrayRequestParams;
    private final Optional<MyEnum> myEnumRequestParam;

    public ArrayRequestParametersRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

        this.myStringArrayRequestParams = Optional.ofNullable(Handlers.coerceStringArrayParameter("my-string-array-request-params", false, decodedStringArrayParameters));
        this.myEnumArrayRequestParams = Optional.ofNullable(Handlers.coerceStringArrayParameter("my-enum-array-request-params", false, decodedStringArrayParameters).stream().map(MyEnum::fromValue).collect(Collectors.toList()));
        this.myIntegerArrayRequestParams = Optional.ofNullable(Handlers.coerceIntegerArrayParameter("my-integer-array-request-params", false, decodedStringArrayParameters));
        this.myLongArrayRequestParams = Optional.ofNullable(Handlers.coerceLongArrayParameter("my-long-array-request-params", false, decodedStringArrayParameters));
        this.myInt32ArrayRequestParams = Optional.ofNullable(Handlers.coerceIntegerArrayParameter("my-int32-array-request-params", false, decodedStringArrayParameters));
        this.myNumberArrayRequestParams = Optional.ofNullable(Handlers.coerceBigDecimalArrayParameter("my-number-array-request-params", false, decodedStringArrayParameters));
        this.myFloatArrayRequestParams = Optional.ofNullable(Handlers.coerceFloatArrayParameter("my-float-array-request-params", false, decodedStringArrayParameters));
        this.myDoubleArrayRequestParams = Optional.ofNullable(Handlers.coerceDoubleArrayParameter("my-double-array-request-params", false, decodedStringArrayParameters));
        this.myEnumRequestParam = Optional.ofNullable(MyEnum.fromValue(Handlers.coerceStringParameter("my-enum-request-param", false, decodedStringParameters)));
    }

    public Optional<List<String>> getMyStringArrayRequestParams() {
        return this.myStringArrayRequestParams;
    }
    public Optional<List<MyEnum>> getMyEnumArrayRequestParams() {
        return this.myEnumArrayRequestParams;
    }
    public Optional<List<Integer>> getMyIntegerArrayRequestParams() {
        return this.myIntegerArrayRequestParams;
    }
    public Optional<List<Long>> getMyLongArrayRequestParams() {
        return this.myLongArrayRequestParams;
    }
    public Optional<List<Integer>> getMyInt32ArrayRequestParams() {
        return this.myInt32ArrayRequestParams;
    }
    public Optional<List<BigDecimal>> getMyNumberArrayRequestParams() {
        return this.myNumberArrayRequestParams;
    }
    public Optional<List<Float>> getMyFloatArrayRequestParams() {
        return this.myFloatArrayRequestParams;
    }
    public Optional<List<Double>> getMyDoubleArrayRequestParams() {
        return this.myDoubleArrayRequestParams;
    }
    public Optional<MyEnum> getMyEnumRequestParam() {
        return this.myEnumRequestParam;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/array_request_parameters/ArrayRequestParametersResponse.java": "
package test.test.runtime.api.handlers.array_request_parameters;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the arrayRequestParameters operation
 */
public interface ArrayRequestParametersResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnum.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the inlineEnum operation
 */
public abstract class InlineEnum implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the inlineEnum operation
     */
    public abstract InlineEnumResponse handle(final InlineEnumRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<InlineEnumInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(InlineEnum.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<InlineEnumInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<InlineEnumInput>> getHandlerInterceptors() {
        List<Interceptor<InlineEnumInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<InlineEnumInput> buildChain(List<Interceptor<InlineEnumInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<InlineEnumInput>() {
            @Override
            public Response next(ChainedRequestInput<InlineEnumInput> input) {
                return handle(new InlineEnumRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<InlineEnumInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final InlineEnumInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<InlineEnumInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public InlineEnumInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new InlineEnumInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<InlineEnumInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "inlineEnum");

        List<Interceptor<InlineEnumInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        InlineEnumInput input;

        try {
            input = new InlineEnumInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnum200Response.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the inlineEnum operation
 */
public class InlineEnum200Response extends RuntimeException implements InlineEnumResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final InlineEnum200Response typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private InlineEnum200Response(final InlineEnum200Response body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public InlineEnum200Response getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a InlineEnum200Response with a body
     */
    public static InlineEnum200Response of(final InlineEnum200Response body) {
        return new InlineEnum200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a InlineEnum200Response with a body and headers
     */
    public static InlineEnum200Response of(final InlineEnum200Response body, final Map<String, String> headers) {
        return new InlineEnum200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a InlineEnum200Response with a body, headers and multi-value headers
     */
    public static InlineEnum200Response of(final InlineEnum200Response body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new InlineEnum200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumInput.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the inlineEnum operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class InlineEnumInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final InlineEnumRequestParameters requestParameters;

    public InlineEnumInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new InlineEnumRequestParameters(event);
    }

    public InlineEnumRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumRequestInput.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the inlineEnum operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class InlineEnumRequestInput implements RequestInput<InlineEnumInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final InlineEnumInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public InlineEnumInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumRequestParameters.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the InlineEnum operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class InlineEnumRequestParameters {

    public InlineEnumRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/inline_enum/InlineEnumResponse.java": "
package test.test.runtime.api.handlers.inline_enum;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the inlineEnum operation
 */
public interface InlineEnumResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywords.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the reservedKeywords operation
 */
public abstract class ReservedKeywords implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the reservedKeywords operation
     */
    public abstract ReservedKeywordsResponse handle(final ReservedKeywordsRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<ReservedKeywordsInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(ReservedKeywords.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<ReservedKeywordsInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<ReservedKeywordsInput>> getHandlerInterceptors() {
        List<Interceptor<ReservedKeywordsInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<ReservedKeywordsInput> buildChain(List<Interceptor<ReservedKeywordsInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<ReservedKeywordsInput>() {
            @Override
            public Response next(ChainedRequestInput<ReservedKeywordsInput> input) {
                return handle(new ReservedKeywordsRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<ReservedKeywordsInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final ReservedKeywordsInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<ReservedKeywordsInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public ReservedKeywordsInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new ReservedKeywordsInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<ReservedKeywordsInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "reservedKeywords");

        List<Interceptor<ReservedKeywordsInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        ReservedKeywordsInput input;

        try {
            input = new ReservedKeywordsInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywords200Response.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the reservedKeywords operation
 */
public class ReservedKeywords200Response extends RuntimeException implements ReservedKeywordsResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private ReservedKeywords200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a ReservedKeywords200Response without a body
     */
    public static ReservedKeywords200Response of() {
        return new ReservedKeywords200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a ReservedKeywords200Response without a body and headers
     */
    public static ReservedKeywords200Response of(final Map<String, String> headers) {
        return new ReservedKeywords200Response(headers, new HashMap<>());
    }

    /**
     * Create a ReservedKeywords200Response without a body, headers and multi-value headers
     */
    public static ReservedKeywords200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new ReservedKeywords200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsInput.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the reservedKeywords operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ReservedKeywordsInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final ReservedKeywordsRequestParameters requestParameters;

    public ReservedKeywordsInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new ReservedKeywordsRequestParameters(event);
    }

    public ReservedKeywordsRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsRequestInput.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the reservedKeywords operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ReservedKeywordsRequestInput implements RequestInput<ReservedKeywordsInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final ReservedKeywordsInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public ReservedKeywordsInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsRequestParameters.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the ReservedKeywords operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class ReservedKeywordsRequestParameters {
    private final Optional<String> with;
    private final Optional<String> _if;
    private final Optional<String> propertyClass;

    public ReservedKeywordsRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

        this.with = Optional.ofNullable(Handlers.coerceStringParameter("with", false, decodedStringParameters));
        this._if = Optional.ofNullable(Handlers.coerceStringParameter("if", false, decodedStringParameters));
        this.propertyClass = Optional.ofNullable(Handlers.coerceStringParameter("class", false, decodedStringParameters));
    }

    public Optional<String> getWith() {
        return this.with;
    }
    public Optional<String> getIf() {
        return this._if;
    }
    public Optional<String> getPropertyClass() {
        return this.propertyClass;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/reserved_keywords/ReservedKeywordsResponse.java": "
package test.test.runtime.api.handlers.reserved_keywords;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the reservedKeywords operation
 */
public interface ReservedKeywordsResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T arrayRequestParameters;
    private T inlineEnum;
    private T reservedKeywords;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("arrayRequestParameters", this.arrayRequestParameters);
        map.put("inlineEnum", this.inlineEnum);
        map.put("reservedKeywords", this.reservedKeywords);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("arrayRequestParameters", OperationLookupEntry.builder()
            .path("/array-request-parameters")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("inlineEnum", OperationLookupEntry.builder()
            .path("/inline-enum")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("reservedKeywords", OperationLookupEntry.builder()
            .path("/reserved-keywords")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .arrayRequestParameters(value)
                .inlineEnum(value)
                .reservedKeywords(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/InlineEnum200Response.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.InlineEnum200ResponseCategoryEnum;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * InlineEnum200Response
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class InlineEnum200Response {
  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private InlineEnum200ResponseCategoryEnum category;

  public InlineEnum200Response() {
  }

  public InlineEnum200Response category(InlineEnum200ResponseCategoryEnum category) {

    this.category = category;
    return this;
  }

   /**
   * Get category
   * @return category
  **/
  @javax.annotation.Nullable
  public InlineEnum200ResponseCategoryEnum getCategory() {
    return category;
  }


  public void setCategory(InlineEnum200ResponseCategoryEnum category) {
    this.category = category;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineEnum200Response inlineEnum200Response = (InlineEnum200Response) o;
    return Objects.equals(this.category, inlineEnum200Response.category);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(category);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineEnum200Response {\\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("category");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to InlineEnum200Response
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!InlineEnum200Response.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InlineEnum200Response is not found in the empty JSON string", InlineEnum200Response.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!InlineEnum200Response.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`InlineEnum200Response\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field \`category\`
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) {
        InlineEnum200ResponseCategoryEnum.validateJsonObject(jsonObj.getAsJsonObject("category"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InlineEnum200Response.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InlineEnum200Response' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InlineEnum200Response> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InlineEnum200Response.class));

       return (TypeAdapter<T>) new TypeAdapter<InlineEnum200Response>() {
           @Override
           public void write(JsonWriter out, InlineEnum200Response value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InlineEnum200Response read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of InlineEnum200Response given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of InlineEnum200Response
  * @throws IOException if the JSON string is invalid with respect to InlineEnum200Response
  */
  public static InlineEnum200Response fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InlineEnum200Response.class);
  }

 /**
  * Convert an instance of InlineEnum200Response to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/InlineEnum200ResponseCategoryEnum.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Gets or Sets InlineEnum200ResponseCategoryEnum
 */
@JsonAdapter(InlineEnum200ResponseCategoryEnum.Adapter.class)
public enum InlineEnum200ResponseCategoryEnum {

  FRUIT("fruit"),

  VEGETABLE("vegetable");

  private String value;

  InlineEnum200ResponseCategoryEnum(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static InlineEnum200ResponseCategoryEnum fromValue(String value) {
    for (InlineEnum200ResponseCategoryEnum b : InlineEnum200ResponseCategoryEnum.values()) {
      if (b.value.equals(value)) {
        return b;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }

  public static class Adapter extends TypeAdapter<InlineEnum200ResponseCategoryEnum> {
    @Override
    public void write(final JsonWriter jsonWriter, final InlineEnum200ResponseCategoryEnum enumeration) throws IOException {
      jsonWriter.value(enumeration.getValue());
    }

    @Override
    public InlineEnum200ResponseCategoryEnum read(final JsonReader jsonReader) throws IOException {
      String value = jsonReader.nextString();
      return InlineEnum200ResponseCategoryEnum.fromValue(value);
    }
  }
}
",
  "src/main/java/test/test/runtime/model/MyEnum.java": "/*
 * Edge Cases
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * Gets or Sets MyEnum
 */
@JsonAdapter(MyEnum.Adapter.class)
public enum MyEnum {

  ONE("one"),

  TWO("two"),

  THREE("three");

  private String value;

  MyEnum(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  public static MyEnum fromValue(String value) {
    for (MyEnum b : MyEnum.values()) {
      if (b.value.equals(value)) {
        return b;
      }
    }
    throw new IllegalArgumentException("Unexpected value '" + value + "'");
  }

  public static class Adapter extends TypeAdapter<MyEnum> {
    @Override
    public void write(final JsonWriter jsonWriter, final MyEnum enumeration) throws IOException {
      jsonWriter.value(enumeration.getValue());
    }

    @Override
    public MyEnum read(final JsonReader jsonReader) throws IOException {
      String value = jsonReader.nextString();
      return MyEnum.fromValue(value);
    }
  }
}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With multiple-tags.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/neither/NeitherResponse.java
src/main/java/test/test/runtime/api/handlers/both/BothResponse.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1Response.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2Response.java
src/main/java/test/test/runtime/api/handlers/neither/Neither200Response.java
src/main/java/test/test/runtime/api/handlers/both/Both200Response.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1200Response.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2200Response.java
src/main/java/test/test/runtime/api/handlers/neither/NeitherRequestParameters.java
src/main/java/test/test/runtime/api/handlers/both/BothRequestParameters.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1RequestParameters.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2RequestParameters.java
src/main/java/test/test/runtime/api/handlers/neither/NeitherInput.java
src/main/java/test/test/runtime/api/handlers/both/BothInput.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1Input.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2Input.java
src/main/java/test/test/runtime/api/handlers/neither/NeitherRequestInput.java
src/main/java/test/test/runtime/api/handlers/both/BothRequestInput.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1RequestInput.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2RequestInput.java
src/main/java/test/test/runtime/api/handlers/neither/Neither.java
src/main/java/test/test/runtime/api/handlers/both/Both.java
src/main/java/test/test/runtime/api/handlers/tag1/Tag1.java
src/main/java/test/test/runtime/api/handlers/tag2/Tag2.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/api/Tag1Api.java
src/main/java/test/test/runtime/api/Tag2Api.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call neitherCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/neither";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call neitherValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return neitherCall(_callback);

    }

    private ApiResponse<Void> neitherWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = neitherValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call neitherAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = neitherValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIneitherRequest {

        private APIneitherRequest() {
        }

        /**
         * Build call for neither
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return neitherCall(_callback);
        }

        /**
         * Execute neither request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            neitherWithHttpInfo();
        }

        /**
         * Execute neither request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return neitherWithHttpInfo();
        }

        /**
         * Execute neither request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return neitherAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIneitherRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIneitherRequest neither() {
        return new APIneitherRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/Tag1Api.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class Tag1Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public Tag1Api() {
        this(Configuration.getDefaultApiClient());
    }

    public Tag1Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call bothCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/both";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call bothValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return bothCall(_callback);

    }

    private ApiResponse<Void> bothWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = bothValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call bothAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = bothValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIbothRequest {

        private APIbothRequest() {
        }

        /**
         * Build call for both
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return bothCall(_callback);
        }

        /**
         * Execute both request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            bothWithHttpInfo();
        }

        /**
         * Execute both request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return bothWithHttpInfo();
        }

        /**
         * Execute both request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return bothAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIbothRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APIbothRequest both() {
        return new APIbothRequest();
    }
    private okhttp3.Call tag1Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tag1";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call tag1ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return tag1Call(_callback);

    }

    private ApiResponse<Void> tag1WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = tag1ValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call tag1Async(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = tag1ValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APItag1Request {

        private APItag1Request() {
        }

        /**
         * Build call for tag1
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return tag1Call(_callback);
        }

        /**
         * Execute tag1 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            tag1WithHttpInfo();
        }

        /**
         * Execute tag1 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return tag1WithHttpInfo();
        }

        /**
         * Execute tag1 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return tag1Async(_callback);
        }
    }

    /**
     * 
     * 
     * @return APItag1Request
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APItag1Request tag1() {
        return new APItag1Request();
    }
}

",
  "src/main/java/test/test/runtime/api/Tag2Api.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class Tag2Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public Tag2Api() {
        this(Configuration.getDefaultApiClient());
    }

    public Tag2Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call tag2Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tag2";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call tag2ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return tag2Call(_callback);

    }

    private ApiResponse<Void> tag2WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = tag2ValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call tag2Async(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = tag2ValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APItag2Request {

        private APItag2Request() {
        }

        /**
         * Build call for tag2
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return tag2Call(_callback);
        }

        /**
         * Execute tag2 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            tag2WithHttpInfo();
        }

        /**
         * Execute tag2 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return tag2WithHttpInfo();
        }

        /**
         * Execute tag2 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return tag2Async(_callback);
        }
    }

    /**
     * 
     * 
     * @return APItag2Request
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    
    public APItag2Request tag2() {
        return new APItag2Request();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.neither.*;
import test.test.runtime.api.handlers.both.*;
import test.test.runtime.api.handlers.tag1.*;
import test.test.runtime.api.handlers.tag2.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String neitherMethodAndPath = Handlers.concatMethodAndPath("GET", "/neither");
    private static final String bothMethodAndPath = Handlers.concatMethodAndPath("GET", "/both");
    private static final String tag1MethodAndPath = Handlers.concatMethodAndPath("GET", "/tag1");
    private static final String tag2MethodAndPath = Handlers.concatMethodAndPath("GET", "/tag2");

    private final Neither constructedNeither;
    private final Both constructedBoth;
    private final Tag1 constructedTag1;
    private final Tag2 constructedTag2;

    /**
     * This method must return your implementation of the Neither operation
     */
    public abstract Neither neither();
    /**
     * This method must return your implementation of the Both operation
     */
    public abstract Both both();
    /**
     * This method must return your implementation of the Tag1 operation
     */
    public abstract Tag1 tag1();
    /**
     * This method must return your implementation of the Tag2 operation
     */
    public abstract Tag2 tag2();

    private static enum Route {
        neitherRoute,
        bothRoute,
        tag1Route,
        tag2Route,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(neitherMethodAndPath, Route.neitherRoute);
        this.routes.put(bothMethodAndPath, Route.bothRoute);
        this.routes.put(tag1MethodAndPath, Route.tag1Route);
        this.routes.put(tag2MethodAndPath, Route.tag2Route);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedNeither = this.neither();
        this.constructedBoth = this.both();
        this.constructedTag1 = this.tag1();
        this.constructedTag2 = this.tag2();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case neitherRoute:
                List<Interceptor<NeitherInput>> neitherInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                neitherInterceptors.addAll(this.getInterceptors());
                return this.constructedNeither.handleRequestWithAdditionalInterceptors(event, context, neitherInterceptors);
            case bothRoute:
                List<Interceptor<BothInput>> bothInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                bothInterceptors.addAll(this.getInterceptors());
                return this.constructedBoth.handleRequestWithAdditionalInterceptors(event, context, bothInterceptors);
            case tag1Route:
                List<Interceptor<Tag1Input>> tag1Interceptors = Handlers.getAnnotationInterceptors(this.getClass());
                tag1Interceptors.addAll(this.getInterceptors());
                return this.constructedTag1.handleRequestWithAdditionalInterceptors(event, context, tag1Interceptors);
            case tag2Route:
                List<Interceptor<Tag2Input>> tag2Interceptors = Handlers.getAnnotationInterceptors(this.getClass());
                tag2Interceptors.addAll(this.getInterceptors());
                return this.constructedTag2.handleRequestWithAdditionalInterceptors(event, context, tag2Interceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/both/Both.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the both operation
 */
public abstract class Both implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the both operation
     */
    public abstract BothResponse handle(final BothRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<BothInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(Both.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<BothInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<BothInput>> getHandlerInterceptors() {
        List<Interceptor<BothInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<BothInput> buildChain(List<Interceptor<BothInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<BothInput>() {
            @Override
            public Response next(ChainedRequestInput<BothInput> input) {
                return handle(new BothRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<BothInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final BothInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<BothInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public BothInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new BothInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<BothInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "both");

        List<Interceptor<BothInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        BothInput input;

        try {
            input = new BothInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/both/Both200Response.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the both operation
 */
public class Both200Response extends RuntimeException implements BothResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private Both200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a Both200Response without a body
     */
    public static Both200Response of() {
        return new Both200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a Both200Response without a body and headers
     */
    public static Both200Response of(final Map<String, String> headers) {
        return new Both200Response(headers, new HashMap<>());
    }

    /**
     * Create a Both200Response without a body, headers and multi-value headers
     */
    public static Both200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new Both200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/both/BothInput.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the both operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class BothInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final BothRequestParameters requestParameters;

    public BothInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new BothRequestParameters(event);
    }

    public BothRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/both/BothRequestInput.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the both operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class BothRequestInput implements RequestInput<BothInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final BothInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public BothInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/both/BothRequestParameters.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the Both operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class BothRequestParameters {

    public BothRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/both/BothResponse.java": "
package test.test.runtime.api.handlers.both;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the both operation
 */
public interface BothResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/neither/Neither.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the neither operation
 */
public abstract class Neither implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the neither operation
     */
    public abstract NeitherResponse handle(final NeitherRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<NeitherInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(Neither.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<NeitherInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<NeitherInput>> getHandlerInterceptors() {
        List<Interceptor<NeitherInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<NeitherInput> buildChain(List<Interceptor<NeitherInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<NeitherInput>() {
            @Override
            public Response next(ChainedRequestInput<NeitherInput> input) {
                return handle(new NeitherRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<NeitherInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final NeitherInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<NeitherInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public NeitherInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new NeitherInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<NeitherInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "neither");

        List<Interceptor<NeitherInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        NeitherInput input;

        try {
            input = new NeitherInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/neither/Neither200Response.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the neither operation
 */
public class Neither200Response extends RuntimeException implements NeitherResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private Neither200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a Neither200Response without a body
     */
    public static Neither200Response of() {
        return new Neither200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a Neither200Response without a body and headers
     */
    public static Neither200Response of(final Map<String, String> headers) {
        return new Neither200Response(headers, new HashMap<>());
    }

    /**
     * Create a Neither200Response without a body, headers and multi-value headers
     */
    public static Neither200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new Neither200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/neither/NeitherInput.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the neither operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class NeitherInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final NeitherRequestParameters requestParameters;

    public NeitherInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new NeitherRequestParameters(event);
    }

    public NeitherRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/neither/NeitherRequestInput.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the neither operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class NeitherRequestInput implements RequestInput<NeitherInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final NeitherInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public NeitherInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/neither/NeitherRequestParameters.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the Neither operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class NeitherRequestParameters {

    public NeitherRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/neither/NeitherResponse.java": "
package test.test.runtime.api.handlers.neither;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the neither operation
 */
public interface NeitherResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the tag1 operation
 */
public abstract class Tag1 implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the tag1 operation
     */
    public abstract Tag1Response handle(final Tag1RequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<Tag1Input>> annotationInterceptors = Handlers.getAnnotationInterceptors(Tag1.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<Tag1Input>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<Tag1Input>> getHandlerInterceptors() {
        List<Interceptor<Tag1Input>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<Tag1Input> buildChain(List<Interceptor<Tag1Input>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<Tag1Input>() {
            @Override
            public Response next(ChainedRequestInput<Tag1Input> input) {
                return handle(new Tag1RequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<Tag1Input> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Tag1Input input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<Tag1Input>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public Tag1Input getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new Tag1Input(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<Tag1Input>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "tag1");

        List<Interceptor<Tag1Input>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        Tag1Input input;

        try {
            input = new Tag1Input(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1200Response.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the tag1 operation
 */
public class Tag1200Response extends RuntimeException implements Tag1Response {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private Tag1200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a Tag1200Response without a body
     */
    public static Tag1200Response of() {
        return new Tag1200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a Tag1200Response without a body and headers
     */
    public static Tag1200Response of(final Map<String, String> headers) {
        return new Tag1200Response(headers, new HashMap<>());
    }

    /**
     * Create a Tag1200Response without a body, headers and multi-value headers
     */
    public static Tag1200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new Tag1200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1Input.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the tag1 operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag1Input {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final Tag1RequestParameters requestParameters;

    public Tag1Input(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new Tag1RequestParameters(event);
    }

    public Tag1RequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1RequestInput.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the tag1 operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag1RequestInput implements RequestInput<Tag1Input> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final Tag1Input input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public Tag1Input getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1RequestParameters.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the Tag1 operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag1RequestParameters {

    public Tag1RequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/tag1/Tag1Response.java": "
package test.test.runtime.api.handlers.tag1;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the tag1 operation
 */
public interface Tag1Response extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the tag2 operation
 */
public abstract class Tag2 implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the tag2 operation
     */
    public abstract Tag2Response handle(final Tag2RequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<Tag2Input>> annotationInterceptors = Handlers.getAnnotationInterceptors(Tag2.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<Tag2Input>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<Tag2Input>> getHandlerInterceptors() {
        List<Interceptor<Tag2Input>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<Tag2Input> buildChain(List<Interceptor<Tag2Input>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<Tag2Input>() {
            @Override
            public Response next(ChainedRequestInput<Tag2Input> input) {
                return handle(new Tag2RequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<Tag2Input> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final Tag2Input input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<Tag2Input>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public Tag2Input getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new Tag2Input(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<Tag2Input>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "tag2");

        List<Interceptor<Tag2Input>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        Tag2Input input;

        try {
            input = new Tag2Input(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2200Response.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the tag2 operation
 */
public class Tag2200Response extends RuntimeException implements Tag2Response {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private Tag2200Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a Tag2200Response without a body
     */
    public static Tag2200Response of() {
        return new Tag2200Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a Tag2200Response without a body and headers
     */
    public static Tag2200Response of(final Map<String, String> headers) {
        return new Tag2200Response(headers, new HashMap<>());
    }

    /**
     * Create a Tag2200Response without a body, headers and multi-value headers
     */
    public static Tag2200Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new Tag2200Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2Input.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the tag2 operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag2Input {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final Tag2RequestParameters requestParameters;

    public Tag2Input(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new Tag2RequestParameters(event);
    }

    public Tag2RequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2RequestInput.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the tag2 operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag2RequestInput implements RequestInput<Tag2Input> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final Tag2Input input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public Tag2Input getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2RequestParameters.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the Tag2 operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class Tag2RequestParameters {

    public Tag2RequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/tag2/Tag2Response.java": "
package test.test.runtime.api.handlers.tag2;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the tag2 operation
 */
public interface Tag2Response extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T neither;
    private T both;
    private T tag1;
    private T tag2;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("neither", this.neither);
        map.put("both", this.both);
        map.put("tag1", this.tag1);
        map.put("tag2", this.tag2);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("neither", OperationLookupEntry.builder()
            .path("/neither")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("both", OperationLookupEntry.builder()
            .path("/both")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("tag1", OperationLookupEntry.builder()
            .path("/tag1")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("tag2", OperationLookupEntry.builder()
            .path("/tag2")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .neither(value)
                .both(value)
                .tag1(value)
                .tag2(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Multiple Tags Test
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With parameter-refs.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java
src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/HelloResponse.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.HelloResponse.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.HelloResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call sayHelloCall(String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/hello";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id", id));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call sayHelloValidateBeforeCall(String id, final ApiCallback _callback) throws ApiException {
        return sayHelloCall(id, _callback);

    }

    private ApiResponse<HelloResponse> sayHelloWithHttpInfo(String id) throws ApiException {
        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call sayHelloAsync(String id, final ApiCallback<HelloResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = sayHelloValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIsayHelloRequest {
        private String id;

        private APIsayHelloRequest() {
        }

        /**
         * Set id
         * @param id  (optional)
         * @return APIsayHelloRequest
         */
        public APIsayHelloRequest id(String id) {
            this.id = id;
            return this;
        }

        /**
         * Build call for sayHello
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return sayHelloCall(id, _callback);
        }

        /**
         * Execute sayHello request
         * @return HelloResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public HelloResponse execute() throws ApiException {
            ApiResponse<HelloResponse> localVarResp = sayHelloWithHttpInfo(id);
            return localVarResp.getData();
        }

        /**
         * Execute sayHello request with HTTP info returned
         * @return ApiResponse&lt;HelloResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<HelloResponse> executeWithHttpInfo() throws ApiException {
            return sayHelloWithHttpInfo(id);
        }

        /**
         * Execute sayHello request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<HelloResponse> _callback) throws ApiException {
            return sayHelloAsync(id, _callback);
        }
    }

    /**
     * 
     * 
     * @return APIsayHelloRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIsayHelloRequest sayHello() {
        return new APIsayHelloRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.say_hello.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String sayHelloMethodAndPath = Handlers.concatMethodAndPath("GET", "/hello");

    private final SayHello constructedSayHello;

    /**
     * This method must return your implementation of the SayHello operation
     */
    public abstract SayHello sayHello();

    private static enum Route {
        sayHelloRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(sayHelloMethodAndPath, Route.sayHelloRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedSayHello = this.sayHello();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case sayHelloRoute:
                List<Interceptor<SayHelloInput>> sayHelloInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                sayHelloInterceptors.addAll(this.getInterceptors());
                return this.constructedSayHello.handleRequestWithAdditionalInterceptors(event, context, sayHelloInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the sayHello operation
 */
public abstract class SayHello implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the sayHello operation
     */
    public abstract SayHelloResponse handle(final SayHelloRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<SayHelloInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(SayHello.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<SayHelloInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<SayHelloInput>> getHandlerInterceptors() {
        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<SayHelloInput> buildChain(List<Interceptor<SayHelloInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<SayHelloInput>() {
            @Override
            public Response next(ChainedRequestInput<SayHelloInput> input) {
                return handle(new SayHelloRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<SayHelloInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final SayHelloInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<SayHelloInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public SayHelloInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new SayHelloInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<SayHelloInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "sayHello");

        List<Interceptor<SayHelloInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        SayHelloInput input;

        try {
            input = new SayHelloInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHello200Response.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the sayHello operation
 */
public class SayHello200Response extends RuntimeException implements SayHelloResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final HelloResponse typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private SayHello200Response(final HelloResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public HelloResponse getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a SayHello200Response with a body
     */
    public static SayHello200Response of(final HelloResponse body) {
        return new SayHello200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body and headers
     */
    public static SayHello200Response of(final HelloResponse body, final Map<String, String> headers) {
        return new SayHello200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a SayHello200Response with a body, headers and multi-value headers
     */
    public static SayHello200Response of(final HelloResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new SayHello200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the sayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final SayHelloRequestParameters requestParameters;

    public SayHelloInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new SayHelloRequestParameters(event);
    }

    public SayHelloRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestInput.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the sayHello operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestInput implements RequestInput<SayHelloInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final SayHelloInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public SayHelloInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloRequestParameters.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the SayHello operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class SayHelloRequestParameters {
    private final Optional<String> id;

    public SayHelloRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

        this.id = Optional.ofNullable(Handlers.coerceStringParameter("id", false, decodedStringParameters));
    }

    public Optional<String> getId() {
        return this.id;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/say_hello/SayHelloResponse.java": "
package test.test.runtime.api.handlers.say_hello;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the sayHello operation
 */
public interface SayHelloResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T sayHello;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("sayHello", this.sayHello);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("sayHello", OperationLookupEntry.builder()
            .path("/hello")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .sayHello(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/HelloResponse.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.HelloResponse;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * HelloResponse
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class HelloResponse {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private HelloResponse message;

  public HelloResponse() {
  }

  public HelloResponse id(String id) {

    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }

  public HelloResponse message(HelloResponse message) {

    this.message = message;
    return this;
  }

   /**
   * Get message
   * @return message
  **/
  @javax.annotation.Nullable
  public HelloResponse getMessage() {
    return message;
  }


  public void setMessage(HelloResponse message) {
    this.message = message;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HelloResponse helloResponse = (HelloResponse) o;
    return Objects.equals(this.id, helloResponse.id) &&
        Objects.equals(this.message, helloResponse.message);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, message);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HelloResponse {\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("message");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to HelloResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!HelloResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HelloResponse is not found in the empty JSON string", HelloResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!HelloResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`HelloResponse\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : HelloResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`id\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("id").toString()));
      }
      // validate the optional field \`message\`
      if (jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) {
        HelloResponse.validateJsonObject(jsonObj.getAsJsonObject("message"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HelloResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HelloResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HelloResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HelloResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<HelloResponse>() {
           @Override
           public void write(JsonWriter out, HelloResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HelloResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of HelloResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of HelloResponse
  * @throws IOException if the JSON string is invalid with respect to HelloResponse
  */
  public static HelloResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HelloResponse.class);
  }

 /**
  * Convert an instance of HelloResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
}
`;

exports[`Java Client Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".tsapi-manifest": "src/main/java/test/test/runtime/api/handlers/Handlers.java
src/main/java/test/test/runtime/api/handlers/Response.java
src/main/java/test/test/runtime/api/handlers/ApiResponse.java
src/main/java/test/test/runtime/api/handlers/Interceptor.java
src/main/java/test/test/runtime/api/handlers/Interceptors.java
src/main/java/test/test/runtime/api/handlers/HandlerChain.java
src/main/java/test/test/runtime/api/handlers/RequestInput.java
src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java
src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseResponse.java
src/main/java/test/test/runtime/api/handlers/empty/EmptyResponse.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponseResponse.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesResponse.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesResponse.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneResponse.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteResponse.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponse200Response.java
src/main/java/test/test/runtime/api/handlers/empty/Empty204Response.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponse200Response.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypes200Response.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypes200Response.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne200Response.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne400Response.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDelete200Response.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseRequestParameters.java
src/main/java/test/test/runtime/api/handlers/empty/EmptyRequestParameters.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponseRequestParameters.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesRequestParameters.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesRequestParameters.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneRequestParameters.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteRequestParameters.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseInput.java
src/main/java/test/test/runtime/api/handlers/empty/EmptyInput.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponseInput.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesInput.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesInput.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneInput.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteInput.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseRequestInput.java
src/main/java/test/test/runtime/api/handlers/empty/EmptyRequestInput.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponseRequestInput.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesRequestInput.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesRequestInput.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneRequestInput.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteRequestInput.java
src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponse.java
src/main/java/test/test/runtime/api/handlers/empty/Empty.java
src/main/java/test/test/runtime/api/handlers/map_response/MapResponse.java
src/main/java/test/test/runtime/api/handlers/media_types/MediaTypes.java
src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypes.java
src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne.java
src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDelete.java
src/main/java/test/test/runtime/api/handlers/HandlerRouter.java
src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java
src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java
src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java
src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java
src/main/java/test/test/runtime/api/operation_config/OperationConfig.java
src/main/java/test/test/runtime/api/operation_config/OperationLookup.java
src/main/java/test/test/runtime/api/operation_config/Operations.java
src/main/java/test/test/runtime/api/DefaultApi.java
src/main/java/test/test/runtime/auth/ApiKeyAuth.java
src/main/java/test/test/runtime/auth/Authentication.java
src/main/java/test/test/runtime/auth/HttpBasicAuth.java
src/main/java/test/test/runtime/auth/HttpBearerAuth.java
src/main/java/test/test/runtime/ApiCallback.java
src/main/java/test/test/runtime/ApiClient.java
src/main/java/test/test/runtime/ApiException.java
src/main/java/test/test/runtime/ApiResponse.java
src/main/java/test/test/runtime/Configuration.java
src/main/java/test/test/runtime/GzipRequestInterceptor.java
src/main/java/test/test/runtime/JSON.java
src/main/java/test/test/runtime/Pair.java
src/main/java/test/test/runtime/ProgressRequestBody.java
src/main/java/test/test/runtime/ProgressResponseBody.java
src/main/java/test/test/runtime/ServerConfiguration.java
src/main/java/test/test/runtime/ServerVariable.java
src/main/java/test/test/runtime/StringUtil.java
src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java
src/main/java/test/test/runtime/model/ApiError.java
src/main/java/test/test/runtime/model/MapResponse.java
src/main/java/test/test/runtime/model/MapResponseMapPropertyValue.java
src/main/java/test/test/runtime/model/TestRequest.java
src/main/java/test/test/runtime/model/TestResponse.java
src/main/java/test/test/runtime/model/TestResponseMessagesInner.java",
  "src/main/java/test/test/runtime/ApiCallback.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.io.IOException;

import java.util.Map;
import java.util.List;

/**
 * Callback for asynchronous API call.
 *
 * @param <T> The return type
 */
public interface ApiCallback<T> {
    /**
     * This is called when the API call fails.
     *
     * @param e The exception causing the failure
     * @param statusCode Status code of the response if available, otherwise it would be 0
     * @param responseHeaders Headers of the response if available, otherwise it would be null
     */
    void onFailure(ApiException e, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API call succeeded.
     *
     * @param result The result deserialized from response
     * @param statusCode Status code of the response
     * @param responseHeaders Headers of the response
     */
    void onSuccess(T result, int statusCode, Map<String, List<String>> responseHeaders);

    /**
     * This is called when the API upload processing.
     *
     * @param bytesWritten bytes Written
     * @param contentLength content length of request body
     * @param done write end
     */
    void onUploadProgress(long bytesWritten, long contentLength, boolean done);

    /**
     * This is called when the API download processing.
     *
     * @param bytesRead bytes Read
     * @param contentLength content length of the response
     * @param done Read end
     */
    void onDownloadProgress(long bytesRead, long contentLength, boolean done);
}
",
  "src/main/java/test/test/runtime/ApiClient.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.logging.HttpLoggingInterceptor;
import okhttp3.logging.HttpLoggingInterceptor.Level;
import okio.Buffer;
import okio.BufferedSink;
import okio.Okio;

import javax.net.ssl.*;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import test.test.runtime.auth.Authentication;
import test.test.runtime.auth.HttpBasicAuth;
import test.test.runtime.auth.HttpBearerAuth;
import test.test.runtime.auth.ApiKeyAuth;

/**
 * <p>ApiClient class.</p>
 */
public class ApiClient {

    private String basePath = "http://localhost";
    protected List<ServerConfiguration> servers = new ArrayList<ServerConfiguration>(Arrays.asList(
    new ServerConfiguration(
      "",
      "No description provided",
      new HashMap<String, ServerVariable>()
    )
  ));
    protected Integer serverIndex = 0;
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private Map<String, String> defaultHeaderMap = new HashMap<String, String>();
    private Map<String, String> defaultCookieMap = new HashMap<String, String>();
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private OkHttpClient httpClient;
    private JSON json;

    private HttpLoggingInterceptor loggingInterceptor;

    /**
     * Basic constructor for ApiClient
     */
    public ApiClient() {
        init();
        initHttpClient();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a {@link okhttp3.OkHttpClient} object
     */
    public ApiClient(OkHttpClient client) {
        init();

        httpClient = client;

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void initHttpClient() {
        initHttpClient(Collections.<Interceptor>emptyList());
    }

    private void initHttpClient(List<Interceptor> interceptors) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        for (Interceptor interceptor: interceptors) {
            builder.addInterceptor(interceptor);
        }

        httpClient = builder.build();
    }

    private void init() {
        verifyingSsl = true;

        json = new JSON();

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/0.0.0/java");

        authentications = new HashMap<String, Authentication>();
    }

    /**
     * Get base path
     *
     * @return Base path
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public List<ServerConfiguration> getServers() {
        return servers;
    }

    public ApiClient setServers(List<ServerConfiguration> servers) {
        this.servers = servers;
        return this;
    }

    public Integer getServerIndex() {
        return serverIndex;
    }

    public ApiClient setServerIndex(Integer serverIndex) {
        this.serverIndex = serverIndex;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public OkHttpClient getHttpClient() {
        return httpClient;
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    public ApiClient setHttpClient(OkHttpClient newHttpClient) {
        this.httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!");
        return this;
    }

    /**
     * Get JSON
     *
     * @return JSON object
     */
    public JSON getJSON() {
        return json;
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    public ApiClient setJSON(JSON json) {
        this.json = json;
        return this;
    }

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    public ApiClient setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    public ApiClient setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>keyManagers</code>.</p>
     *
     * @return an array of {@link javax.net.ssl.KeyManager} objects
     */
    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    public ApiClient setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    /**
     * <p>Getter for the field <code>dateFormat</code>.</p>
     *
     * @return a {@link java.text.DateFormat} object
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * <p>Setter for the field <code>dateFormat</code>.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        JSON.setDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set SqlDateFormat.</p>
     *
     * @param dateFormat a {@link java.text.DateFormat} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setSqlDateFormat(DateFormat dateFormat) {
        JSON.setSqlDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set OffsetDateTimeFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        JSON.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LocalDateFormat.</p>
     *
     * @param dateFormat a {@link java.time.format.DateTimeFormatter} object
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLocalDateFormat(DateTimeFormatter dateFormat) {
        JSON.setLocalDateFormat(dateFormat);
        return this;
    }

    /**
     * <p>Set LenientOnJson.</p>
     *
     * @param lenientOnJson a boolean
     * @return a {@link test.test.runtime.ApiClient} object
     */
    public ApiClient setLenientOnJson(boolean lenientOnJson) {
        JSON.setLenientOnJson(lenientOnJson);
        return this;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }


    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    public void setUsername(String username) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setUsername(username);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    public void setPassword(String password) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof HttpBasicAuth) {
                ((HttpBasicAuth) auth).setPassword(password);
                return;
            }
        }
        throw new RuntimeException("No HTTP basic authentication configured!");
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    public void setApiKey(String apiKey) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey(apiKey);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    public void setApiKeyPrefix(String apiKeyPrefix) {
        for (Authentication auth : authentications.values()) {
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
                return;
            }
        }
        throw new RuntimeException("No API key authentication configured!");
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    public void setAWS4Configuration(String accessKey, String secretKey, String region, String service) {
        throw new RuntimeException("No AWS4 authentication configured!");
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    public ApiClient setUserAgent(String userAgent) {
        addDefaultHeader("User-Agent", userAgent);
        return this;
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    public ApiClient addDefaultHeader(String key, String value) {
        defaultHeaderMap.put(key, value);
        return this;
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    public ApiClient addDefaultCookie(String key, String value) {
        defaultCookieMap.put(key, value);
        return this;
    }

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    public ApiClient setDebugging(boolean debugging) {
        if (debugging != this.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                final OkHttpClient.Builder builder = httpClient.newBuilder();
                builder.interceptors().remove(loggingInterceptor);
                httpClient = builder.build();
                loggingInterceptor = null;
            }
        }
        this.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default temporary folder.
     *
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempFile(java.lang.String,%20java.lang.String,%20java.nio.file.attribute.FileAttribute...)">createTempFile</a>
     * @return Temporary folder path
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    public ApiClient setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public ApiClient setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link java.lang.Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public ApiClient setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date || param instanceof OffsetDateTime || param instanceof LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            String jsonStr = JSON.serialize(param);
            return jsonStr.substring(1, jsonStr.length() - 1);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     *
     * Note that {@code value} must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) {
            return params;
        }

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    public String collectionPathParameterToString(String collectionFormat, Collection value) {
        // create the value based on the collection format
        if ("multi".equals(collectionFormat)) {
            // not valid for path params
            return parameterToString(value);
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        if ("ssv".equals(collectionFormat)) {
            delimiter = " ";
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = "\\t";
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = "|";
        }

        StringBuilder sb = new StringBuilder() ;
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(parameterToString(item));
        }

        return sb.substring(delimiter.length());
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\\\\\]", "");
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     *   if JSON exists in the given array, use it;
     *   otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     *   null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     *   if JSON exists in the given array, use it;
     *   otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     *   returns null. If it matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0) {
            return null;
        }

        if (contentTypes[0].equals("*/*")) {
            return "application/json";
        }

        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }

        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws test.test.runtime.ApiException If fail to deserialize response body, i.e. cannot read response body
     *   or the Content-Type of the response is not supported.
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(Response response, Type returnType) throws ApiException {
        if (response == null || returnType == null) {
            return null;
        }

        if ("byte[]".equals(returnType.toString())) {
            // Handle binary response (byte array).
            try {
                return (T) response.body().bytes();
            } catch (IOException e) {
                throw new ApiException(e);
            }
        } else if (returnType.equals(File.class)) {
            // Handle file downloading.
            return (T) downloadFileFromResponse(response);
        }

        String respBody;
        try {
            if (response.body() != null)
                respBody = response.body().string();
            else
                respBody = null;
        } catch (IOException e) {
            throw new ApiException(e);
        }

        if (respBody == null || "".equals(respBody)) {
            return null;
        }

        String contentType = response.headers().get("Content-Type");
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json";
        }
        if (isJsonMime(contentType)) {
            return JSON.deserialize(respBody, returnType);
        } else if (returnType.equals(String.class)) {
            // Expecting string, return the raw response body.
            return (T) respBody;
        } else {
            throw new ApiException(
                    "Content type \\"" + contentType + "\\" is not supported for type: " + returnType,
                    response.code(),
                    response.headers().toMultimap(),
                    respBody);
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws test.test.runtime.ApiException If fail to serialize the given object
     */
    public RequestBody serialize(Object obj, String contentType) throws ApiException {
        if (obj instanceof byte[]) {
            // Binary (byte array) body parameter support.
            return RequestBody.create((byte[]) obj, MediaType.parse(contentType));
        } else if (obj instanceof File) {
            // File body parameter support.
            return RequestBody.create((File) obj, MediaType.parse(contentType));
        } else if ("text/plain".equals(contentType) && obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else if (isJsonMime(contentType)) {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            return RequestBody.create(content, MediaType.parse(contentType));
        } else if (obj instanceof String) {
            return RequestBody.create((String) obj, MediaType.parse(contentType));
        } else {
            throw new ApiException("Content type \\"" + contentType + "\\" is not supported");
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws test.test.runtime.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile("filename=['\\"]?([^'\\"\\\\s]+)['\\"]?");
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3)
                prefix = "download-";
        }

        if (tempFolderPath == null)
            return Files.createTempFile(prefix, suffix).toFile();
        else
            return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * {@link #execute(Call, Type)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call) throws ApiException {
        return execute(call, null);
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     *   data, which is a Java object deserialized from response body and would be null
     *   when returnType is null.
     * @throws test.test.runtime.ApiException If fail to execute the call
     */
    public <T> ApiResponse<T> execute(Call call, Type returnType) throws ApiException {
        try {
            Response response = call.execute();
            T data = handleResponse(response, returnType);
            return new ApiResponse<T>(response.code(), response.headers().toMultimap(), data);
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    /**
     * {@link #executeAsync(Call, Type, ApiCallback)}
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
     */
    public <T> void executeAsync(Call call, ApiCallback<T> callback) {
        executeAsync(call, null, callback);
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see #execute(Call, Type)
     */
    @SuppressWarnings("unchecked")
    public <T> void executeAsync(Call call, final Type returnType, final ApiCallback<T> callback) {
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.onFailure(new ApiException(e), 0, null);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                T result;
                try {
                    result = (T) handleResponse(response, returnType);
                } catch (ApiException e) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                } catch (Exception e) {
                    callback.onFailure(new ApiException(e), response.code(), response.headers().toMultimap());
                    return;
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }
        });
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws test.test.runtime.ApiException If the response has an unsuccessful status code or
     *                      fail to deserialize the response body
     */
    public <T> T handleResponse(Response response, Type returnType) throws ApiException {
        if (response.isSuccessful()) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body().close();
                    } catch (Exception e) {
                        throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    }
                }
                return null;
            } else {
                return deserialize(response, returnType);
            }
        } else {
            String respBody = null;
            if (response.body() != null) {
                try {
                    respBody = response.body().string();
                } catch (IOException e) {
                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                }
            }
            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Call buildCall(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        Request request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback);

        return httpClient.newCall(request);
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws test.test.runtime.ApiException If fail to serialize the request body object
     */
    public Request buildRequest(String baseUrl, String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        List<Pair> allQueryParams = new ArrayList<Pair>(queryParams);
        allQueryParams.addAll(collectionQueryParams);

        final String url = buildUrl(baseUrl, path, queryParams, collectionQueryParams);

        // prepare HTTP request body
        RequestBody reqBody;
        String contentType = headerParams.get("Content-Type");

        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if ("application/x-www-form-urlencoded".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if ("multipart/form-data".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if ("DELETE".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", contentType == null ? null : MediaType.parse(contentType));
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url));

        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);
        processCookieParams(cookieParams, reqBuilder);

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback);

        Request request = null;

        if (callback != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    public String buildUrl(String baseUrl, String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        final StringBuilder url = new StringBuilder();
        if (baseUrl != null) {
            url.append(baseUrl).append(path);
        } else {
            String baseURL;
            if (serverIndex != null) {
                if (serverIndex < 0 || serverIndex >= servers.size()) {
                    throw new ArrayIndexOutOfBoundsException(String.format(
                    "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size()
                    ));
                }
                baseURL = servers.get(serverIndex).URL(serverVariables);
            } else {
                baseURL = basePath;
            }
            url.append(baseURL).append(path);
        }

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in \`path\`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processHeaderParams(Map<String, String> headerParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : headerParams.entrySet()) {
            reqBuilder.header(param.getKey(), parameterToString(param.getValue()));
        }
        for (Entry<String, String> header : defaultHeaderMap.entrySet()) {
            if (!headerParams.containsKey(header.getKey())) {
                reqBuilder.header(header.getKey(), parameterToString(header.getValue()));
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    public void processCookieParams(Map<String, String> cookieParams, Request.Builder reqBuilder) {
        for (Entry<String, String> param : cookieParams.entrySet()) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
        }
        for (Entry<String, String> param : defaultCookieMap.entrySet()) {
            if (!cookieParams.containsKey(param.getKey())) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", param.getKey(), param.getValue()));
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws test.test.runtime.ApiException If fails to update the parameters
     */
    public void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                    Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) {
                throw new RuntimeException("Authentication undefined: " + authName);
            }
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyFormEncoding(Map<String, Object> formParams) {
        okhttp3.FormBody.Builder formBuilder = new okhttp3.FormBody.Builder();
        for (Entry<String, Object> param : formParams.entrySet()) {
            formBuilder.add(param.getKey(), parameterToString(param.getValue()));
        }
        return formBuilder.build();
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    public RequestBody buildRequestBodyMultipart(Map<String, Object> formParams) {
        MultipartBody.Builder mpBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        for (Entry<String, Object> param : formParams.entrySet()) {
            if (param.getValue() instanceof File) {
                File file = (File) param.getValue();
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), file);
            } else if (param.getValue() instanceof List) {
                List list = (List) param.getValue();
                for (Object item: list) {
                    if (item instanceof File) {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), (File) item);
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, param.getKey(), param.getValue());
            }
        }
        return mpBuilder.build();
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    public String guessContentTypeFromFile(File file) {
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        if (contentType == null) {
            return "application/octet-stream";
        } else {
            return contentType;
        }
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, File file) {
        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"; filename=\\"" + file.getName() + "\\"");
        MediaType mediaType = MediaType.parse(guessContentTypeFromFile(file));
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType));
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private void addPartToMultiPartBuilder(MultipartBody.Builder mpBuilder, String key, Object obj) {
        RequestBody requestBody;
        if (obj instanceof String) {
            requestBody = RequestBody.create((String) obj, MediaType.parse("text/plain"));
        } else {
            String content;
            if (obj != null) {
                content = JSON.serialize(obj);
            } else {
                content = null;
            }
            requestBody = RequestBody.create(content, MediaType.parse("application/json"));
        }

        Headers partHeaders = Headers.of("Content-Disposition", "form-data; name=\\"" + key + "\\"");
        mpBuilder.addPart(partHeaders, requestBody);
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Interceptor.Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                        .body(new ProgressResponseBody(originalResponse.body(), callback))
                        .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers;
            HostnameVerifier hostnameVerifier;
            if (!verifyingSsl) {
                trustManagers = new TrustManager[]{
                        new X509TrustManager() {
                            @Override
                            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                            }

                            @Override
                            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                                return new java.security.cert.X509Certificate[]{};
                            }
                        }
                };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

                if (sslCaCert == null) {
                    trustManagerFactory.init((KeyStore) null);
                } else {
                    char[] password = null; // Any password will work.
                    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                    if (certificates.isEmpty()) {
                        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                    }
                    KeyStore caKeyStore = newEmptyKeyStore(password);
                    int index = 0;
                    for (Certificate certificate : certificates) {
                        String certificateAlias = "ca" + (index++);
                        caKeyStore.setCertificateEntry(certificateAlias, certificate);
                    }
                    trustManagerFactory.init(caKeyStore);
                }
                trustManagers = trustManagerFactory.getTrustManagers();
                hostnameVerifier = OkHostnameVerifier.INSTANCE;
            }

            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagers, trustManagers, new SecureRandom());
            httpClient = httpClient.newBuilder()
                            .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier(hostnameVerifier)
                            .build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws test.test.runtime.ApiException If fail to serialize the request body object into a string
     */
    private String requestBodyToString(RequestBody requestBody) throws ApiException {
        if (requestBody != null) {
            try {
                final Buffer buffer = new Buffer();
                requestBody.writeTo(buffer);
                return buffer.readUtf8();
            } catch (final IOException e) {
                throw new ApiException(e);
            }
        }

        // empty http request body
        return "";
    }
}
",
  "src/main/java/test/test/runtime/ApiException.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Map;
import java.util.List;

import javax.ws.rs.core.GenericType;

/**
 * <p>ApiException class.</p>
 */
@SuppressWarnings("serial")
public class ApiException extends Exception {
    private int code = 0;
    private Map<String, List<String>> responseHeaders = null;
    private String responseBody = null;

    /**
     * <p>Constructor for ApiException.</p>
     */
    public ApiException() {}

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param throwable a {@link java.lang.Throwable} object
     */
    public ApiException(Throwable throwable) {
        super(throwable);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     */
    public ApiException(String message) {
        super(message);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        super(message, throwable);
        this.code = code;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(String message, int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this(message, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param message the error message
     * @param throwable a {@link java.lang.Throwable} object
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     */
    public ApiException(String message, Throwable throwable, int code, Map<String, List<String>> responseHeaders) {
        this(message, throwable, code, responseHeaders, null);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, Map<String, List<String>> responseHeaders, String responseBody) {
        this("Response Code: " + code + " Response Body: " + responseBody, (Throwable) null, code, responseHeaders, responseBody);
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message a {@link java.lang.String} object
     */
    public ApiException(int code, String message) {
        super(message);
        this.code = code;
    }

    /**
     * <p>Constructor for ApiException.</p>
     *
     * @param code HTTP status code
     * @param message the error message
     * @param responseHeaders a {@link java.util.Map} of HTTP response headers
     * @param responseBody the response body
     */
    public ApiException(int code, String message, Map<String, List<String>> responseHeaders, String responseBody) {
        this(code, message);
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
    }

    /**
     * Get the HTTP status code.
     *
     * @return HTTP status code
     */
    public int getCode() {
        return code;
    }

    /**
     * Get the HTTP response headers.
     *
     * @return A map of list of string
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get the HTTP response body.
     *
     * @return Response body in the form of string
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Get the exception message including HTTP response data.
     *
     * @return The exception message
     */
    public String getMessage() {
        return String.format("Message: %s%nHTTP response code: %s%nHTTP response body: %s%nHTTP response headers: %s",
                super.getMessage(), this.getCode(), this.getResponseBody(), this.getResponseHeaders());
    }
}
",
  "src/main/java/test/test/runtime/ApiResponse.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.List;
import java.util.Map;

/**
 * API response returned by API call.
 */
public class ApiResponse<T> {
    final private int statusCode;
    final private Map<String, List<String>> headers;
    final private T data;

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers) {
        this(statusCode, headers, null);
    }

    /**
     * <p>Constructor for ApiResponse.</p>
     *
     * @param statusCode The status code of HTTP response
     * @param headers The headers of HTTP response
     * @param data The object deserialized from response bod
     */
    public ApiResponse(int statusCode, Map<String, List<String>> headers, T data) {
        this.statusCode = statusCode;
        this.headers = headers;
        this.data = data;
    }

    /**
     * <p>Get the <code>status code</code>.</p>
     *
     * @return the status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * <p>Get the <code>headers</code>.</p>
     *
     * @return a {@link java.util.Map} of headers
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * <p>Get the <code>data</code>.</p>
     *
     * @return the data
     */
    public T getData() {
        return data;
    }
}
",
  "src/main/java/test/test/runtime/Configuration.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Configuration {
    private static ApiClient defaultApiClient = new ApiClient();

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
    }
}
",
  "src/main/java/test/test/runtime/GzipRequestInterceptor.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.*;
import okio.Buffer;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

import java.io.IOException;

/**
 * Encodes request bodies using gzip.
 *
 * Taken from https://github.com/square/okhttp/issues/350
 */
class GzipRequestInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                                                   .header("Content-Encoding", "gzip")
                                                   .method(originalRequest.method(), forceContentLength(gzip(originalRequest.body())))
                                                   .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody forceContentLength(final RequestBody requestBody) throws IOException {
        final Buffer buffer = new Buffer();
        requestBody.writeTo(buffer);
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return requestBody.contentType();
            }

            @Override
            public long contentLength() {
                return buffer.size();
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                sink.write(buffer.snapshot());
            }
        };
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override
            public MediaType contentType() {
                return body.contentType();
            }

            @Override
            public long contentLength() {
                return -1; // We don't know the compressed length in advance!
            }

            @Override
            public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/JSON.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonElement;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.TypeSelector;

import okio.ByteString;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
public class JSON {
    private static Gson gson;
    private static boolean isLenientOnJson = false;
    private static DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private static SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private static OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private static LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();
    private static ByteArrayAdapter byteArrayAdapter = new ByteArrayAdapter();

    @SuppressWarnings("unchecked")
    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
        ;
        GsonBuilder builder = fireBuilder.createGsonBuilder();
        return builder;
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if (null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private static Class getClassByDiscriminator(Map classByDiscriminatorValue, String discriminatorValue) {
        Class clazz = (Class) classByDiscriminatorValue.get(discriminatorValue);
        if (null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    {
        GsonBuilder gsonBuilder = createGson();
        gsonBuilder.registerTypeAdapter(Date.class, dateTypeAdapter);
        gsonBuilder.registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter);
        gsonBuilder.registerTypeAdapter(LocalDate.class, localDateTypeAdapter);
        gsonBuilder.registerTypeAdapter(byte[].class, byteArrayAdapter);
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.ApiError.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.MapResponse.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.MapResponseMapPropertyValue.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestRequest.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestResponse.CustomTypeAdapterFactory());
        gsonBuilder.registerTypeAdapterFactory(new test.test.runtime.model.TestResponseMessagesInner.CustomTypeAdapterFactory());
        gson = gsonBuilder.create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public static Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    public static void setGson(Gson gson) {
        JSON.gson = gson;
    }

    public static void setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public static String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public static <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class)) {
                return (T) body;
            } else {
                throw (e);
            }
        }
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    public static class ByteArrayAdapter extends TypeAdapter<byte[]> {

        @Override
        public void write(JsonWriter out, byte[] value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(ByteString.of(value).base64());
            }
        }

        @Override
        public byte[] read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String bytesAsBase64 = in.nextString();
                    ByteString byteString = ByteString.decodeBase64(bytesAsBase64);
                    return byteString.toByteArray();
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public static class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public static void setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
    }

    public static void setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {}

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {}

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public static void setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
    }

    public static void setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
    }
}
",
  "src/main/java/test/test/runtime/Pair.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

public class Pair {
    private String name = "";
    private String value = "";

    public Pair (String name, String value) {
        setName(name);
        setValue(value);
    }

    private void setName(String name) {
        if (!isValidString(name)) {
            return;
        }

        this.name = name;
    }

    private void setValue(String value) {
        if (!isValidString(value)) {
            return;
        }

        this.value = value;
    }

    public String getName() {
        return this.name;
    }

    public String getValue() {
        return this.value;
    }

    private boolean isValidString(String arg) {
        if (arg == null) {
            return false;
        }

        return true;
    }
}
",
  "src/main/java/test/test/runtime/ProgressRequestBody.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.RequestBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public class ProgressRequestBody extends RequestBody {

    private final RequestBody requestBody;

    private final ApiCallback callback;

    public ProgressRequestBody(RequestBody requestBody, ApiCallback callback) {
        this.requestBody = requestBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }

    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        BufferedSink bufferedSink = Okio.buffer(sink(sink));
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }

    private Sink sink(Sink sink) {
        return new ForwardingSink(sink) {

            long bytesWritten = 0L;
            long contentLength = 0L;

            @Override
            public void write(Buffer source, long byteCount) throws IOException {
                super.write(source, byteCount);
                if (contentLength == 0) {
                    contentLength = contentLength();
                }

                bytesWritten += byteCount;
                callback.onUploadProgress(bytesWritten, contentLength, bytesWritten == contentLength);
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ProgressResponseBody.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import okhttp3.MediaType;
import okhttp3.ResponseBody;

import java.io.IOException;

import okio.Buffer;
import okio.BufferedSource;
import okio.ForwardingSource;
import okio.Okio;
import okio.Source;

public class ProgressResponseBody extends ResponseBody {

    private final ResponseBody responseBody;
    private final ApiCallback callback;
    private BufferedSource bufferedSource;

    public ProgressResponseBody(ResponseBody responseBody, ApiCallback callback) {
        this.responseBody = responseBody;
        this.callback = callback;
    }

    @Override
    public MediaType contentType() {
        return responseBody.contentType();
    }

    @Override
    public long contentLength() {
        return responseBody.contentLength();
    }

    @Override
    public BufferedSource source() {
        if (bufferedSource == null) {
            bufferedSource = Okio.buffer(source(responseBody.source()));
        }
        return bufferedSource;
    }

    private Source source(Source source) {
        return new ForwardingSource(source) {
            long totalBytesRead = 0L;

            @Override
            public long read(Buffer sink, long byteCount) throws IOException {
                long bytesRead = super.read(sink, byteCount);
                // read() returns the number of bytes read, or -1 if this source is exhausted.
                totalBytesRead += bytesRead != -1 ? bytesRead : 0;
                callback.onDownloadProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1);
                return bytesRead;
            }
        };
    }
}
",
  "src/main/java/test/test/runtime/ServerConfiguration.java": "package test.test.runtime;

import java.util.Map;

/**
 * Representing a Server configuration.
 */
public class ServerConfiguration {
    public String URL;
    public String description;
    public Map<String, ServerVariable> variables;

    /**
     * @param URL A URL to the target host.
     * @param description A description of the host designated by the URL.
     * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
     */
    public ServerConfiguration(String URL, String description, Map<String, ServerVariable> variables) {
        this.URL = URL;
        this.description = description;
        this.variables = variables;
    }

    /**
     * Format URL template using given variables.
     *
     * @param variables A map between a variable name and its value.
     * @return Formatted URL.
     */
    public String URL(Map<String, String> variables) {
        String url = this.URL;

        // go through variables and replace placeholders
        for (Map.Entry<String, ServerVariable> variable: this.variables.entrySet()) {
            String name = variable.getKey();
            ServerVariable serverVariable = variable.getValue();
            String value = serverVariable.defaultValue;

            if (variables != null && variables.containsKey(name)) {
                value = variables.get(name);
                if (serverVariable.enumValues.size() > 0 && !serverVariable.enumValues.contains(value)) {
                    throw new IllegalArgumentException("The variable " + name + " in the server URL has invalid value " + value + ".");
                }
            }
            url = url.replace("{" + name + "}", value);
        }
        return url;
    }

    /**
     * Format URL template using default server variables.
     *
     * @return Formatted URL.
     */
    public String URL() {
        return URL(null);
    }
}
",
  "src/main/java/test/test/runtime/ServerVariable.java": "package test.test.runtime;

import java.util.HashSet;

/**
 * Representing a Server Variable for server URL template substitution.
 */
public class ServerVariable {
    public String description;
    public String defaultValue;
    public HashSet<String> enumValues = null;

    /**
     * @param description A description for the server variable.
     * @param defaultValue The default value to use for substitution.
     * @param enumValues An enumeration of string values to be used if the substitution options are from a limited set.
     */
    public ServerVariable(String description, String defaultValue, HashSet<String> enumValues) {
        this.description = description;
        this.defaultValue = defaultValue;
        this.enumValues = enumValues;
    }
}
",
  "src/main/java/test/test/runtime/StringUtil.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime;

import java.util.Collection;
import java.util.Iterator;

public class StringUtil {
  /**
   * Check if the given array contains the given value (with case-insensitive comparison).
   *
   * @param array The array
   * @param value The value to search
   * @return true if the array contains the value
   */
  public static boolean containsIgnoreCase(String[] array, String value) {
    for (String str : array) {
      if (value == null && str == null) {
        return true;
      }
      if (value != null && value.equalsIgnoreCase(str)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Join an array of strings with the given separator.
   * <p>
   * Note: This might be replaced by utility method from commons-lang or guava someday
   * if one of those libraries is added as dependency.
   * </p>
   *
   * @param array     The array of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(String[] array, String separator) {
    int len = array.length;
    if (len == 0) {
      return "";
    }

    StringBuilder out = new StringBuilder();
    out.append(array[0]);
    for (int i = 1; i < len; i++) {
      out.append(separator).append(array[i]);
    }
    return out.toString();
  }

  /**
   * Join a list of strings with the given separator.
   *
   * @param list      The list of strings
   * @param separator The separator
   * @return the resulting string
   */
  public static String join(Collection<String> list, String separator) {
    Iterator<String> iterator = list.iterator();
    StringBuilder out = new StringBuilder();
    if (iterator.hasNext()) {
      out.append(iterator.next());
    }
    while (iterator.hasNext()) {
      out.append(separator).append(iterator.next());
    }
    return out.toString();
  }
}
",
  "src/main/java/test/test/runtime/api/DefaultApi.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.api;

import test.test.runtime.ApiCallback;
import test.test.runtime.ApiClient;
import test.test.runtime.ApiException;
import test.test.runtime.ApiResponse;
import test.test.runtime.Configuration;
import test.test.runtime.Pair;
import test.test.runtime.ProgressRequestBody;
import test.test.runtime.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.io.File;
import test.test.runtime.model.ApiError;
import test.test.runtime.model.MapResponse;
import test.test.runtime.model.TestRequest;
import test.test.runtime.model.TestResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call anyRequestResponseCall(Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/any-request-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call anyRequestResponseValidateBeforeCall(Object body, final ApiCallback _callback) throws ApiException {
        return anyRequestResponseCall(body, _callback);

    }

    private ApiResponse<Object> anyRequestResponseWithHttpInfo(Object body) throws ApiException {
        okhttp3.Call localVarCall = anyRequestResponseValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call anyRequestResponseAsync(Object body, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = anyRequestResponseValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIanyRequestResponseRequest {
        private Object body;

        private APIanyRequestResponseRequest() {
        }

        /**
         * Set body
         * @param body  (optional)
         * @return APIanyRequestResponseRequest
         */
        public APIanyRequestResponseRequest body(Object body) {
            this.body = body;
            return this;
        }

        /**
         * Build call for anyRequestResponse
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return anyRequestResponseCall(body, _callback);
        }

        /**
         * Execute anyRequestResponse request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = anyRequestResponseWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute anyRequestResponse request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return anyRequestResponseWithHttpInfo(body);
        }

        /**
         * Execute anyRequestResponse request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return anyRequestResponseAsync(body, _callback);
        }
    }

    /**
     * 
     * 
     * @return APIanyRequestResponseRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Any response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIanyRequestResponseRequest anyRequestResponse() {
        return new APIanyRequestResponseRequest();
    }
    private okhttp3.Call emptyCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/empty-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call emptyValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return emptyCall(_callback);

    }

    private ApiResponse<Void> emptyWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = emptyValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }


    private okhttp3.Call emptyAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = emptyValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIemptyRequest {

        private APIemptyRequest() {
        }

        /**
         * Build call for empty
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return emptyCall(_callback);
        }

        /**
         * Execute empty request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            emptyWithHttpInfo();
        }

        /**
         * Execute empty request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return emptyWithHttpInfo();
        }

        /**
         * Execute empty request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return emptyAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIemptyRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No response body! </td><td>  -  </td></tr>
     </table>
     */
    
    public APIemptyRequest empty() {
        return new APIemptyRequest();
    }
    private okhttp3.Call mapResponseCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/map-response";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call mapResponseValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return mapResponseCall(_callback);

    }

    private ApiResponse<MapResponse> mapResponseWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = mapResponseValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<MapResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call mapResponseAsync(final ApiCallback<MapResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = mapResponseValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<MapResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImapResponseRequest {

        private APImapResponseRequest() {
        }

        /**
         * Build call for mapResponse
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return mapResponseCall(_callback);
        }

        /**
         * Execute mapResponse request
         * @return MapResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public MapResponse execute() throws ApiException {
            ApiResponse<MapResponse> localVarResp = mapResponseWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute mapResponse request with HTTP info returned
         * @return ApiResponse&lt;MapResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MapResponse> executeWithHttpInfo() throws ApiException {
            return mapResponseWithHttpInfo();
        }

        /**
         * Execute mapResponse request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MapResponse> _callback) throws ApiException {
            return mapResponseAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APImapResponseRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    
    public APImapResponseRequest mapResponse() {
        return new APImapResponseRequest();
    }
    private okhttp3.Call mediaTypesCall(File body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/different-media-type";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/x-mpegurl"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/pdf"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call mediaTypesValidateBeforeCall(File body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling mediaTypes(Async)");
        }

        return mediaTypesCall(body, _callback);

    }

    private ApiResponse<String> mediaTypesWithHttpInfo(File body) throws ApiException {
        okhttp3.Call localVarCall = mediaTypesValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call mediaTypesAsync(File body, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = mediaTypesValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImediaTypesRequest {
        private final File body;

        private APImediaTypesRequest(File body) {
            this.body = body;
        }

        /**
         * Build call for mediaTypes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return mediaTypesCall(body, _callback);
        }

        /**
         * Execute mediaTypes request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = mediaTypesWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute mediaTypes request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return mediaTypesWithHttpInfo(body);
        }

        /**
         * Execute mediaTypes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return mediaTypesAsync(body, _callback);
        }
    }

    /**
     * 
     * 
     * @param body  (required)
     * @return APImediaTypesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    
    public APImediaTypesRequest mediaTypes(File body) {
        return new APImediaTypesRequest(body);
    }
    private okhttp3.Call multipleContentTypesCall(TestRequest testRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = testRequest;

        // create path and map variables
        String localVarPath = "/multiple-content-types";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/pdf"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call multipleContentTypesValidateBeforeCall(TestRequest testRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'testRequest' is set
        if (testRequest == null) {
            throw new ApiException("Missing the required parameter 'testRequest' when calling multipleContentTypes(Async)");
        }

        return multipleContentTypesCall(testRequest, _callback);

    }

    private ApiResponse<String> multipleContentTypesWithHttpInfo(TestRequest testRequest) throws ApiException {
        okhttp3.Call localVarCall = multipleContentTypesValidateBeforeCall(testRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call multipleContentTypesAsync(TestRequest testRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = multipleContentTypesValidateBeforeCall(testRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APImultipleContentTypesRequest {
        private final TestRequest testRequest;

        private APImultipleContentTypesRequest(TestRequest testRequest) {
            this.testRequest = testRequest;
        }

        /**
         * Build call for multipleContentTypes
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return multipleContentTypesCall(testRequest, _callback);
        }

        /**
         * Execute multipleContentTypes request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = multipleContentTypesWithHttpInfo(testRequest);
            return localVarResp.getData();
        }

        /**
         * Execute multipleContentTypes request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return multipleContentTypesWithHttpInfo(testRequest);
        }

        /**
         * Execute multipleContentTypes request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return multipleContentTypesAsync(testRequest, _callback);
        }
    }

    /**
     * 
     * 
     * @param testRequest  (required)
     * @return APImultipleContentTypesRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    
    public APImultipleContentTypesRequest multipleContentTypes(TestRequest testRequest) {
        return new APImultipleContentTypesRequest(testRequest);
    }
    private okhttp3.Call operationOneCall(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = testRequest;

        // create path and map variables
        String localVarPath = "/path/{pathParam}"
            .replace("{" + "pathParam" + "}", localVarApiClient.escapeString(pathParam.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (param1 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param1", param1));
        }

        if (param2 != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "param2", param2));
        }

        if (param3 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param3", param3));
        }

        if (param4 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("param4", param4));
        }

        if (xHeaderParam != null) {
            localVarHeaderParams.put("x-header-param", localVarApiClient.parameterToString(xHeaderParam));
        }

        if (xMultiValueHeaderParam != null) {
            localVarHeaderParams.put("x-multi-value-header-param", localVarApiClient.parameterToString(xMultiValueHeaderParam));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call operationOneValidateBeforeCall(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'param1' is set
        if (param1 == null) {
            throw new ApiException("Missing the required parameter 'param1' when calling operationOne(Async)");
        }

        // verify the required parameter 'param2' is set
        if (param2 == null) {
            throw new ApiException("Missing the required parameter 'param2' when calling operationOne(Async)");
        }

        // verify the required parameter 'param3' is set
        if (param3 == null) {
            throw new ApiException("Missing the required parameter 'param3' when calling operationOne(Async)");
        }

        // verify the required parameter 'pathParam' is set
        if (pathParam == null) {
            throw new ApiException("Missing the required parameter 'pathParam' when calling operationOne(Async)");
        }

        // verify the required parameter 'xHeaderParam' is set
        if (xHeaderParam == null) {
            throw new ApiException("Missing the required parameter 'xHeaderParam' when calling operationOne(Async)");
        }

        // verify the required parameter 'testRequest' is set
        if (testRequest == null) {
            throw new ApiException("Missing the required parameter 'testRequest' when calling operationOne(Async)");
        }

        return operationOneCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);

    }

    private ApiResponse<TestResponse> operationOneWithHttpInfo(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam) throws ApiException {
        okhttp3.Call localVarCall = operationOneValidateBeforeCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, null);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call operationOneAsync(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest, String param4, List<String> xMultiValueHeaderParam, final ApiCallback<TestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = operationOneValidateBeforeCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIoperationOneRequest {
        private final String param1;
        private final List<String> param2;
        private final BigDecimal param3;
        private final String pathParam;
        private final String xHeaderParam;
        private final TestRequest testRequest;
        private String param4;
        private List<String> xMultiValueHeaderParam;

        private APIoperationOneRequest(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest) {
            this.param1 = param1;
            this.param2 = param2;
            this.param3 = param3;
            this.pathParam = pathParam;
            this.xHeaderParam = xHeaderParam;
            this.testRequest = testRequest;
        }

        /**
         * Set param4
         * @param param4  (optional)
         * @return APIoperationOneRequest
         */
        public APIoperationOneRequest param4(String param4) {
            this.param4 = param4;
            return this;
        }

        /**
         * Set xMultiValueHeaderParam
         * @param xMultiValueHeaderParam  (optional)
         * @return APIoperationOneRequest
         */
        public APIoperationOneRequest xMultiValueHeaderParam(List<String> xMultiValueHeaderParam) {
            this.xMultiValueHeaderParam = xMultiValueHeaderParam;
            return this;
        }

        /**
         * Build call for operationOne
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return operationOneCall(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        }

        /**
         * Execute operationOne request
         * @return TestResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public TestResponse execute() throws ApiException {
            ApiResponse<TestResponse> localVarResp = operationOneWithHttpInfo(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam);
            return localVarResp.getData();
        }

        /**
         * Execute operationOne request with HTTP info returned
         * @return ApiResponse&lt;TestResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TestResponse> executeWithHttpInfo() throws ApiException {
            return operationOneWithHttpInfo(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam);
        }

        /**
         * Execute operationOne request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TestResponse> _callback) throws ApiException {
            return operationOneAsync(param1, param2, param3, pathParam, xHeaderParam, testRequest, param4, xMultiValueHeaderParam, _callback);
        }
    }

    /**
     * 
     * 
     * @param param1 This is parameter 1 (required)
     * @param param2 This is parameter 2 (required)
     * @param param3  (required)
     * @param pathParam  (required)
     * @param xHeaderParam This is a header parameter (required)
     * @param testRequest  (required)
     * @return APIoperationOneRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIoperationOneRequest operationOne(String param1, List<String> param2, BigDecimal param3, String pathParam, String xHeaderParam, TestRequest testRequest) {
        return new APIoperationOneRequest(param1, param2, param3, pathParam, xHeaderParam, testRequest);
    }
    private okhttp3.Call withoutOperationIdDeleteCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/without-operation-id";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    
    @SuppressWarnings("rawtypes")
    private okhttp3.Call withoutOperationIdDeleteValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return withoutOperationIdDeleteCall(_callback);

    }

    private ApiResponse<TestResponse> withoutOperationIdDeleteWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = withoutOperationIdDeleteValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }


    private okhttp3.Call withoutOperationIdDeleteAsync(final ApiCallback<TestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = withoutOperationIdDeleteValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<TestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwithoutOperationIdDeleteRequest {

        private APIwithoutOperationIdDeleteRequest() {
        }

        /**
         * Build call for withoutOperationIdDelete
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return withoutOperationIdDeleteCall(_callback);
        }

        /**
         * Execute withoutOperationIdDelete request
         * @return TestResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public TestResponse execute() throws ApiException {
            ApiResponse<TestResponse> localVarResp = withoutOperationIdDeleteWithHttpInfo();
            return localVarResp.getData();
        }

        /**
         * Execute withoutOperationIdDelete request with HTTP info returned
         * @return ApiResponse&lt;TestResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TestResponse> executeWithHttpInfo() throws ApiException {
            return withoutOperationIdDeleteWithHttpInfo();
        }

        /**
         * Execute withoutOperationIdDelete request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TestResponse> _callback) throws ApiException {
            return withoutOperationIdDeleteAsync(_callback);
        }
    }

    /**
     * 
     * 
     * @return APIwithoutOperationIdDeleteRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    
    public APIwithoutOperationIdDeleteRequest withoutOperationIdDelete() {
        return new APIwithoutOperationIdDeleteRequest();
    }
}

",
  "src/main/java/test/test/runtime/api/handlers/ApiResponse.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

@lombok.experimental.SuperBuilder
@lombok.AllArgsConstructor
@lombok.Getter
public class ApiResponse implements Response {
    private String body;
    private int statusCode;
    private Map<String, String> headers;
    private Map<String, List<String>> multiValueHeaders;
}
",
  "src/main/java/test/test/runtime/api/handlers/ChainedRequestInput.java": "
package test.test.runtime.api.handlers;

/**
 * Reqeust input with a handler chain
 */
public interface ChainedRequestInput<TInput> extends RequestInput<TInput> {
    /**
     * The chain for handling requests
     */
    HandlerChain<TInput> getChain();
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerChain.java": "
package test.test.runtime.api.handlers;
/**
 * A handler chain represents a series of interceptors, which may or may not delegate to following interceptors.
 * The lambda handler is always the last method in the chain.
 */
public interface HandlerChain<TInput> {
    /**
     * Delegate to the remainder of the handler chain
     */
    Response next(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/HandlerRouter.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.api.handlers.any_request_response.*;
import test.test.runtime.api.handlers.empty.*;
import test.test.runtime.api.handlers.map_response.*;
import test.test.runtime.api.handlers.media_types.*;
import test.test.runtime.api.handlers.multiple_content_types.*;
import test.test.runtime.api.handlers.operation_one.*;
import test.test.runtime.api.handlers.without_operation_id_delete.*;

import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


public abstract class HandlerRouter implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {
    private static final String anyRequestResponseMethodAndPath = Handlers.concatMethodAndPath("PUT", "/any-request-response");
    private static final String emptyMethodAndPath = Handlers.concatMethodAndPath("PUT", "/empty-response");
    private static final String mapResponseMethodAndPath = Handlers.concatMethodAndPath("GET", "/map-response");
    private static final String mediaTypesMethodAndPath = Handlers.concatMethodAndPath("POST", "/different-media-type");
    private static final String multipleContentTypesMethodAndPath = Handlers.concatMethodAndPath("POST", "/multiple-content-types");
    private static final String operationOneMethodAndPath = Handlers.concatMethodAndPath("POST", "/path/{pathParam}");
    private static final String withoutOperationIdDeleteMethodAndPath = Handlers.concatMethodAndPath("DELETE", "/without-operation-id");

    private final AnyRequestResponse constructedAnyRequestResponse;
    private final Empty constructedEmpty;
    private final MapResponse constructedMapResponse;
    private final MediaTypes constructedMediaTypes;
    private final MultipleContentTypes constructedMultipleContentTypes;
    private final OperationOne constructedOperationOne;
    private final WithoutOperationIdDelete constructedWithoutOperationIdDelete;

    /**
     * This method must return your implementation of the AnyRequestResponse operation
     */
    public abstract AnyRequestResponse anyRequestResponse();
    /**
     * This method must return your implementation of the Empty operation
     */
    public abstract Empty empty();
    /**
     * This method must return your implementation of the MapResponse operation
     */
    public abstract MapResponse mapResponse();
    /**
     * This method must return your implementation of the MediaTypes operation
     */
    public abstract MediaTypes mediaTypes();
    /**
     * This method must return your implementation of the MultipleContentTypes operation
     */
    public abstract MultipleContentTypes multipleContentTypes();
    /**
     * This method must return your implementation of the OperationOne operation
     */
    public abstract OperationOne operationOne();
    /**
     * This method must return your implementation of the WithoutOperationIdDelete operation
     */
    public abstract WithoutOperationIdDelete withoutOperationIdDelete();

    private static enum Route {
        anyRequestResponseRoute,
        emptyRoute,
        mapResponseRoute,
        mediaTypesRoute,
        multipleContentTypesRoute,
        operationOneRoute,
        withoutOperationIdDeleteRoute,
    }

    /**
     * Map of method and path to the route to map to
     */
    private final Map<String, Route> routes = new HashMap<>();

    public HandlerRouter() {
        this.routes.put(anyRequestResponseMethodAndPath, Route.anyRequestResponseRoute);
        this.routes.put(emptyMethodAndPath, Route.emptyRoute);
        this.routes.put(mapResponseMethodAndPath, Route.mapResponseRoute);
        this.routes.put(mediaTypesMethodAndPath, Route.mediaTypesRoute);
        this.routes.put(multipleContentTypesMethodAndPath, Route.multipleContentTypesRoute);
        this.routes.put(operationOneMethodAndPath, Route.operationOneRoute);
        this.routes.put(withoutOperationIdDeleteMethodAndPath, Route.withoutOperationIdDeleteRoute);
        // Handlers are all constructed in the router's constructor such that lambda behaviour remains consistent;
        // ie resources created in the constructor remain in memory between invocations.
        // https://docs.aws.amazon.com/lambda/latest/dg/java-handler.html
        this.constructedAnyRequestResponse = this.anyRequestResponse();
        this.constructedEmpty = this.empty();
        this.constructedMapResponse = this.mapResponse();
        this.constructedMediaTypes = this.mediaTypes();
        this.constructedMultipleContentTypes = this.multipleContentTypes();
        this.constructedOperationOne = this.operationOne();
        this.constructedWithoutOperationIdDelete = this.withoutOperationIdDelete();
    }

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public <T> List<Interceptor<T>> getInterceptors() {
        return Collections.emptyList();
    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        String method = event.getRequestContext().getHttpMethod();
        String path = event.getRequestContext().getResourcePath();
        String methodAndPath = Handlers.concatMethodAndPath(method, path);
        Route route = this.routes.get(methodAndPath);

        switch (route) {
            case anyRequestResponseRoute:
                List<Interceptor<AnyRequestResponseInput>> anyRequestResponseInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                anyRequestResponseInterceptors.addAll(this.getInterceptors());
                return this.constructedAnyRequestResponse.handleRequestWithAdditionalInterceptors(event, context, anyRequestResponseInterceptors);
            case emptyRoute:
                List<Interceptor<EmptyInput>> emptyInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                emptyInterceptors.addAll(this.getInterceptors());
                return this.constructedEmpty.handleRequestWithAdditionalInterceptors(event, context, emptyInterceptors);
            case mapResponseRoute:
                List<Interceptor<MapResponseInput>> mapResponseInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                mapResponseInterceptors.addAll(this.getInterceptors());
                return this.constructedMapResponse.handleRequestWithAdditionalInterceptors(event, context, mapResponseInterceptors);
            case mediaTypesRoute:
                List<Interceptor<MediaTypesInput>> mediaTypesInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                mediaTypesInterceptors.addAll(this.getInterceptors());
                return this.constructedMediaTypes.handleRequestWithAdditionalInterceptors(event, context, mediaTypesInterceptors);
            case multipleContentTypesRoute:
                List<Interceptor<MultipleContentTypesInput>> multipleContentTypesInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                multipleContentTypesInterceptors.addAll(this.getInterceptors());
                return this.constructedMultipleContentTypes.handleRequestWithAdditionalInterceptors(event, context, multipleContentTypesInterceptors);
            case operationOneRoute:
                List<Interceptor<OperationOneInput>> operationOneInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                operationOneInterceptors.addAll(this.getInterceptors());
                return this.constructedOperationOne.handleRequestWithAdditionalInterceptors(event, context, operationOneInterceptors);
            case withoutOperationIdDeleteRoute:
                List<Interceptor<WithoutOperationIdDeleteInput>> withoutOperationIdDeleteInterceptors = Handlers.getAnnotationInterceptors(this.getClass());
                withoutOperationIdDeleteInterceptors.addAll(this.getInterceptors());
                return this.constructedWithoutOperationIdDelete.handleRequestWithAdditionalInterceptors(event, context, withoutOperationIdDeleteInterceptors);
            default:
                throw new RuntimeException(String.format("No registered handler for method {} and path {}", method, path));
        }
    }
}",
  "src/main/java/test/test/runtime/api/handlers/Handlers.java": "
package test.test.runtime.api.handlers;

import test.test.runtime.model.*;
import test.test.runtime.api.interceptors.ResponseHeadersInterceptor;

import java.util.Arrays;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.DateTimeException;
import java.math.BigDecimal;
import java.math.BigInteger;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;

import test.test.runtime.JSON;

public class Handlers {

    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private static String decodeParameter(final String parameter) {
        try {
            return URLDecoder.decode(parameter, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> decodeRequestParameters(Map<String, String> parameters) {
        Map<String, String> decodedParameters = new HashMap<>();
        for(Map.Entry<String, String> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), decodeParameter(parameter.getValue()));
        }
        return decodedParameters;
    }

    public static Map<String, List<String>> decodeRequestArrayParameters(Map<String, List<String>> parameters) {
        Map<String, List<String>> decodedParameters = new HashMap<>();
        for(Map.Entry<String, List<String>> parameter : parameters.entrySet()) {
            decodedParameters.put(parameter.getKey(), parameter.getValue().stream().map(Handlers::decodeParameter).collect(Collectors.toList()));
        }
        return decodedParameters;
    }

    public static <T> void assertRequired(final Boolean required, final String baseName, final Map<String, T> parameters) {
        if (required && parameters.get(baseName) == null) {
            throw new RuntimeException("Missing required request parameter '" + baseName + "'");
        }
    }

    public static String coerceStringParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static List<String> coerceStringArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        return parameters.get(baseName);
    }

    public static Double coerceDouble(final String baseName, final String s) {
        try {
            return Double.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static Double coerceDoubleParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceDouble(baseName, s);
    }

    public static List<Double> coerceDoubleArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Double> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceDouble(baseName, s));
        }
        return res;
    }

    public static BigDecimal coerceBigDecimal(final String baseName, final String s) {
        try {
            return new BigDecimal(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigDecimal coerceBigDecimalParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigDecimal(baseName, s);
    }

    public static List<BigDecimal> coerceBigDecimalArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigDecimal> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigDecimal(baseName, s));
        }
        return res;
    }

    public static BigInteger coerceBigInteger(final String baseName, final String s) {
        try {
            return new BigInteger(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a number for request parameter '" + baseName + "'");
        }
    }

    public static BigInteger coerceBigIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBigInteger(baseName, s);
    }

    public static List<BigInteger> coerceBigIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<BigInteger> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBigInteger(baseName, s));
        }
        return res;
    }

    public static Float coerceFloat(final String baseName, final String s) {
        try {
            return Float.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a float for request parameter '" + baseName + "'");
        }
    }

    public static Float coerceFloatParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceFloat(baseName, s);
    }

    public static List<Float> coerceFloatArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Float> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceFloat(baseName, s));
        }
        return res;
    }

    public static Integer coerceInteger(final String baseName, final String s) {
        try {
            return Integer.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected an integer for request parameter '" + baseName + "'");
        }
    }

    public static Integer coerceIntegerParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceInteger(baseName, s);
    }

    public static List<Integer> coerceIntegerArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Integer> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceInteger(baseName, s));
        }
        return res;
    }

    public static Long coerceLong(final String baseName, final String s) {
        try {
            return Long.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a long for request parameter '" + baseName + "'");
        }
    }

    public static Long coerceLongParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceLong(baseName, s);
    }

    public static List<Long> coerceLongArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Long> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceLong(baseName, s));
        }
        return res;
    }

    public static Short coerceShort(final String baseName, final String s) {
        try {
            return Short.valueOf(s);
        } catch (NumberFormatException e) {
            throw new RuntimeException("Expected a short for request parameter '" + baseName + "'");
        }
    }

    public static Short coerceShortParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceShort(baseName, s);
    }

    public static List<Short> coerceShortArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Short> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceShort(baseName, s));
        }
        return res;
    }

    public static Boolean coerceBoolean(final String baseName, final String s) {
        if ("true".equals(s)) {
            return true;
        } else if ("false".equals(s)) {
            return false;
        }
        throw new RuntimeException("Expected a boolean (true or false) for request parameter '" + baseName + "'");
    }

    public static Boolean coerceBooleanParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceBoolean(baseName, s);
    }

    public static List<Boolean> coerceBooleanArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<Boolean> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceBoolean(baseName, s));
        }
        return res;
    }

    public static OffsetDateTime coerceOffsetDateTime(final String baseName, final String s) {
        try {
            return OffsetDateTime.parse(s);
        } catch (DateTimeException e) {
            throw new RuntimeException("Expected a valid date (iso format) for request parameter '" + baseName + "'");
        }
    }

    public static OffsetDateTime coerceOffsetDateTimeParameter(final String baseName, final boolean required, final Map<String, String> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        String s = parameters.get(baseName);
        return s == null ? null : coerceOffsetDateTime(baseName, s);
    }

    public static List<OffsetDateTime> coerceOffsetDateTimeArrayParameter(final String baseName, final boolean required, final Map<String, List<String>> parameters) {
        Handlers.assertRequired(required, baseName, parameters);
        List<String> ss = parameters.get(baseName);
        if (ss == null) {
            return null;
        }
        List<OffsetDateTime> res = new ArrayList<>();
        for (String s : ss) {
            res.add(coerceOffsetDateTime(baseName, s));
        }
        return res;
    }

    public static <K, V> void putAllFromNullableMap(Map<K, V> source, Map<K, V> destination) {
        if (source != null) {
            destination.putAll(source);
        }
    }

    public static String concatMethodAndPath(final String method, final String path) {
        return String.format("%s||%s", method.toLowerCase(), path);
    }

    public static <T> Map<String, String> extractResponseHeadersFromInterceptors(final List<Interceptor<T>> interceptors) {
        Map<String, String> headers = new HashMap<>();
        for (Interceptor<T> interceptor : interceptors) {
            if (interceptor instanceof ResponseHeadersInterceptor) {
                headers.putAll(((ResponseHeadersInterceptor) interceptor).getAdditionalHeaders());
            }
        }
        return headers;
    }

    public static <T, I> List<Interceptor<I>> getAnnotationInterceptors(Class<T> clazz) {
        // Support specifying simple interceptors via the @Interceptors({ MyInterceptor.class, MyOtherInterceptor.class }) format
        return clazz.isAnnotationPresent(Interceptors.class)
                ? Arrays.stream(clazz.getAnnotation(Interceptors.class).value()).map(c -> {
            try {
                return (Interceptor<I>) c.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(String.format(
                        "Cannot create instance of interceptor %s. Please ensure it has a public constructor " +
                                "with no arguments, or override the getInterceptors method instead of using the annotation", c.getSimpleName()), e);
            }
        }).collect(Collectors.toList())
                : new ArrayList<>();
    }

    public static <TInput> HandlerChain<TInput> buildHandlerChain(final List<Interceptor<TInput>> interceptors, final HandlerChain<TInput> baseChain) {
        if (interceptors.isEmpty()) {
            return baseChain;
        } else {
            Interceptor<TInput> interceptor = interceptors.get(0);
            HandlerChain<TInput> remainingChain = buildHandlerChain(interceptors.subList(1, interceptors.size()), baseChain);
            return new HandlerChain<TInput>() {
                @Override
                public Response next(ChainedRequestInput<TInput> input) {
                    return interceptor.handle(new ChainedRequestInput<TInput>() {
                        @Override
                        public APIGatewayProxyRequestEvent getEvent() {
                            return input.getEvent();
                        }

                        @Override
                        public Context getContext() {
                            return input.getContext();
                        }

                        @Override
                        public TInput getInput() {
                            return input.getInput();
                        }

                        @Override
                        public HandlerChain<TInput> getChain() {
                            return remainingChain;
                        }

                        @Override
                        public Map<String, Object> getInterceptorContext() {
                            return input.getInterceptorContext();
                        }
                    });
                }
            };
        }
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptor.java": "
package test.test.runtime.api.handlers;

/**
 * Interceptors can perform generic operations on requests and/or responses, optionally delegating to the remainder
 * of the request chain.
 */
public interface Interceptor<TInput> {
    /**
     * Handle a request. Usually the response from \`input.getChain().next(input)\` is returned to delegate to the
     * remainder of the chain, however you may wish to return an alternative Response.
     */
    Response handle(ChainedRequestInput<TInput> input);
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWarmupChainedRequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.ClientContext;
import com.amazonaws.services.lambda.runtime.CognitoIdentity;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

/**
 * An "empty" chained request input used to warm up interceptors which extend the InterceptorWithWarmup
 */
public class InterceptorWarmupChainedRequestInput<T> implements ChainedRequestInput<T> {

  @Override
  public HandlerChain<T> getChain() {
    return new HandlerChain<T>() {
      @Override
      public Response next(ChainedRequestInput<T> input) {
        return new Response() {
          @Override
          public String getBody() {
            return "";
          }

          @Override
          public int getStatusCode() {
            return 0;
          }

          @Override
          public Map<String, String> getHeaders() {
            return new HashMap<>();
          }

          @Override
          public Map<String, List<String>> getMultiValueHeaders() {
            return new HashMap<>();
          }
        };
      }
    };
  }

  @Override
  public Context getContext() {
    return new Context() {
      @Override
      public String getAwsRequestId() {
        return "";
      }

      @Override
      public String getLogGroupName() {
        return "";
      }

      @Override
      public String getLogStreamName() {
        return "";
      }

      @Override
      public String getFunctionName() {
        return "";
      }

      @Override
      public String getFunctionVersion() {
        return "";
      }

      @Override
      public String getInvokedFunctionArn() {
        return "";
      }

      @Override
      public CognitoIdentity getIdentity() {
        return null;
      }

      @Override
      public ClientContext getClientContext() {
        return null;
      }

      @Override
      public int getRemainingTimeInMillis() {
        return 0;
      }

      @Override
      public int getMemoryLimitInMB() {
        return 0;
      }

      @Override
      public LambdaLogger getLogger() {
        return null;
      }
    };
  }

  @Override
  public APIGatewayProxyRequestEvent getEvent() {
    return new APIGatewayProxyRequestEvent();
  }

  @Override
  public T getInput() {
    return null;
  }

  @Override
  public Map<String, Object> getInterceptorContext() {
    Map<String, Object> context = new HashMap<>();
    context.put("operationId", "__tsapi_interceptor_warmup");
    return context;
  }
}
",
  "src/main/java/test/test/runtime/api/handlers/InterceptorWithWarmup.java": "
package test.test.runtime.api.handlers;

import org.crac.Resource;
import org.crac.Core;
import org.crac.Context;

/**
 * An interceptor with a "warmUp" method with default snap-start warmup behaviour, which can be overridden if desired.
 */
public abstract class InterceptorWithWarmup<TInput> implements Interceptor<TInput>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    @Override
    public void beforeCheckpoint(Context<? extends Resource> context) {
        this.warmUp();
    }

    @Override
    public void afterRestore(Context<? extends Resource> context) {

    }

    /**
     * Called prior to the lambda snap-start snapshot.
     * Override this to change the default behaviour, which is to call the interceptor's handle method with an empty
     * chained request.
     */
    public void warmUp() {
        this.handle(new InterceptorWarmupChainedRequestInput<>());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/Interceptors.java": "
package test.test.runtime.api.handlers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Use this annotation to add interceptors to the request handler. Interceptors used in the annotation must have a
 * constructor with no arguments.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Interceptors {
    public Class<? extends Interceptor>[] value() default {};
}
",
  "src/main/java/test/test/runtime/api/handlers/RequestInput.java": "
package test.test.runtime.api.handlers;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.Context;
import java.util.Map;

/**
 * Defines the input for a request.
 */
public interface RequestInput<TInput> {
    /**
     * The raw event from API Gateway
     */
    APIGatewayProxyRequestEvent getEvent();
    /**
     * Lambda execution context
     */
    Context getContext();
    /**
     * Demarshalled request input
     */
    TInput getInput();
    /**
     * Storage for arbitrary interceptor context for the lifetime of the request. Set and get values to pass state
     * between interceptors or to the final handler.
     */
    Map<String, Object> getInterceptorContext();
}
",
  "src/main/java/test/test/runtime/api/handlers/Response.java": "
package test.test.runtime.api.handlers;

import java.util.Map;
import java.util.List;

/**
 * Represents an HTTP response from an api operation
 */
public interface Response {
    /**
     * Returns the response body
     */
    String getBody();
    /**
     * Returns the response status code
     */
    int getStatusCode();
    /**
     * Returns the response headers
     */
    Map<String, String> getHeaders();
    /**
     * Returns the multi-value response headers
     */
    Map<String, List<String>> getMultiValueHeaders();
}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponse.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the anyRequestResponse operation
 */
public abstract class AnyRequestResponse implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the anyRequestResponse operation
     */
    public abstract AnyRequestResponseResponse handle(final AnyRequestResponseRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<AnyRequestResponseInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(AnyRequestResponse.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<AnyRequestResponseInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<AnyRequestResponseInput>> getHandlerInterceptors() {
        List<Interceptor<AnyRequestResponseInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<AnyRequestResponseInput> buildChain(List<Interceptor<AnyRequestResponseInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<AnyRequestResponseInput>() {
            @Override
            public Response next(ChainedRequestInput<AnyRequestResponseInput> input) {
                return handle(new AnyRequestResponseRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<AnyRequestResponseInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final AnyRequestResponseInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<AnyRequestResponseInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public AnyRequestResponseInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new AnyRequestResponseInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<AnyRequestResponseInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "anyRequestResponse");

        List<Interceptor<AnyRequestResponseInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        AnyRequestResponseInput input;

        try {
            input = new AnyRequestResponseInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponse200Response.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the anyRequestResponse operation
 */
public class AnyRequestResponse200Response extends RuntimeException implements AnyRequestResponseResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final String typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private AnyRequestResponse200Response(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body;
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public String getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a AnyRequestResponse200Response with a body
     */
    public static AnyRequestResponse200Response of(final String body) {
        return new AnyRequestResponse200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a AnyRequestResponse200Response with a body and headers
     */
    public static AnyRequestResponse200Response of(final String body, final Map<String, String> headers) {
        return new AnyRequestResponse200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a AnyRequestResponse200Response with a body, headers and multi-value headers
     */
    public static AnyRequestResponse200Response of(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new AnyRequestResponse200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseInput.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the anyRequestResponse operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class AnyRequestResponseInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final AnyRequestResponseRequestParameters requestParameters;
    private final String body;

    public AnyRequestResponseInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new AnyRequestResponseRequestParameters(event);
        this.body = event.getBody();
    }

    public AnyRequestResponseRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

    public String getBody() {
        return this.body;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseRequestInput.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the anyRequestResponse operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class AnyRequestResponseRequestInput implements RequestInput<AnyRequestResponseInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final AnyRequestResponseInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public AnyRequestResponseInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseRequestParameters.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the AnyRequestResponse operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class AnyRequestResponseRequestParameters {

    public AnyRequestResponseRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/any_request_response/AnyRequestResponseResponse.java": "
package test.test.runtime.api.handlers.any_request_response;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the anyRequestResponse operation
 */
public interface AnyRequestResponseResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/empty/Empty.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the empty operation
 */
public abstract class Empty implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the empty operation
     */
    public abstract EmptyResponse handle(final EmptyRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<EmptyInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(Empty.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<EmptyInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<EmptyInput>> getHandlerInterceptors() {
        List<Interceptor<EmptyInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<EmptyInput> buildChain(List<Interceptor<EmptyInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<EmptyInput>() {
            @Override
            public Response next(ChainedRequestInput<EmptyInput> input) {
                return handle(new EmptyRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<EmptyInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final EmptyInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<EmptyInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public EmptyInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new EmptyInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<EmptyInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "empty");

        List<Interceptor<EmptyInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        EmptyInput input;

        try {
            input = new EmptyInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/empty/Empty204Response.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 204 for the empty operation
 */
public class Empty204Response extends RuntimeException implements EmptyResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private Empty204Response(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        
        this.body = "";
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 204;
    }

    @Override
    public String getBody() {
        return this.body;
    }


    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a Empty204Response without a body
     */
    public static Empty204Response of() {
        return new Empty204Response(new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a Empty204Response without a body and headers
     */
    public static Empty204Response of(final Map<String, String> headers) {
        return new Empty204Response(headers, new HashMap<>());
    }

    /**
     * Create a Empty204Response without a body, headers and multi-value headers
     */
    public static Empty204Response of(final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new Empty204Response(headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/empty/EmptyInput.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the empty operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class EmptyInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final EmptyRequestParameters requestParameters;

    public EmptyInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new EmptyRequestParameters(event);
    }

    public EmptyRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/empty/EmptyRequestInput.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the empty operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class EmptyRequestInput implements RequestInput<EmptyInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final EmptyInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public EmptyInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/empty/EmptyRequestParameters.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the Empty operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class EmptyRequestParameters {

    public EmptyRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/empty/EmptyResponse.java": "
package test.test.runtime.api.handlers.empty;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the empty operation
 */
public interface EmptyResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponse.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the mapResponse operation
 */
public abstract class MapResponse implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the mapResponse operation
     */
    public abstract MapResponseResponse handle(final MapResponseRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<MapResponseInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(MapResponse.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<MapResponseInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<MapResponseInput>> getHandlerInterceptors() {
        List<Interceptor<MapResponseInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<MapResponseInput> buildChain(List<Interceptor<MapResponseInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<MapResponseInput>() {
            @Override
            public Response next(ChainedRequestInput<MapResponseInput> input) {
                return handle(new MapResponseRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<MapResponseInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final MapResponseInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<MapResponseInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public MapResponseInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new MapResponseInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MapResponseInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "mapResponse");

        List<Interceptor<MapResponseInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        MapResponseInput input;

        try {
            input = new MapResponseInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponse200Response.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the mapResponse operation
 */
public class MapResponse200Response extends RuntimeException implements MapResponseResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final MapResponse typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private MapResponse200Response(final MapResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public MapResponse getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a MapResponse200Response with a body
     */
    public static MapResponse200Response of(final MapResponse body) {
        return new MapResponse200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a MapResponse200Response with a body and headers
     */
    public static MapResponse200Response of(final MapResponse body, final Map<String, String> headers) {
        return new MapResponse200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a MapResponse200Response with a body, headers and multi-value headers
     */
    public static MapResponse200Response of(final MapResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new MapResponse200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponseInput.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the mapResponse operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MapResponseInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final MapResponseRequestParameters requestParameters;

    public MapResponseInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new MapResponseRequestParameters(event);
    }

    public MapResponseRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponseRequestInput.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the mapResponse operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MapResponseRequestInput implements RequestInput<MapResponseInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final MapResponseInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public MapResponseInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponseRequestParameters.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the MapResponse operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MapResponseRequestParameters {

    public MapResponseRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/map_response/MapResponseResponse.java": "
package test.test.runtime.api.handlers.map_response;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the mapResponse operation
 */
public interface MapResponseResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypes.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the mediaTypes operation
 */
public abstract class MediaTypes implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the mediaTypes operation
     */
    public abstract MediaTypesResponse handle(final MediaTypesRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<MediaTypesInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(MediaTypes.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<MediaTypesInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<MediaTypesInput>> getHandlerInterceptors() {
        List<Interceptor<MediaTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<MediaTypesInput> buildChain(List<Interceptor<MediaTypesInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<MediaTypesInput>() {
            @Override
            public Response next(ChainedRequestInput<MediaTypesInput> input) {
                return handle(new MediaTypesRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<MediaTypesInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final MediaTypesInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<MediaTypesInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public MediaTypesInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new MediaTypesInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MediaTypesInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "mediaTypes");

        List<Interceptor<MediaTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        MediaTypesInput input;

        try {
            input = new MediaTypesInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypes200Response.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the mediaTypes operation
 */
public class MediaTypes200Response extends RuntimeException implements MediaTypesResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final String typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private MediaTypes200Response(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body;
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public String getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a MediaTypes200Response with a body
     */
    public static MediaTypes200Response of(final String body) {
        return new MediaTypes200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a MediaTypes200Response with a body and headers
     */
    public static MediaTypes200Response of(final String body, final Map<String, String> headers) {
        return new MediaTypes200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a MediaTypes200Response with a body, headers and multi-value headers
     */
    public static MediaTypes200Response of(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new MediaTypes200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesInput.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the mediaTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MediaTypesInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final MediaTypesRequestParameters requestParameters;
    private final String body;

    public MediaTypesInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new MediaTypesRequestParameters(event);
        this.body = event.getBody();
    }

    public MediaTypesRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

    public String getBody() {
        return this.body;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesRequestInput.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the mediaTypes operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MediaTypesRequestInput implements RequestInput<MediaTypesInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final MediaTypesInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public MediaTypesInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesRequestParameters.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the MediaTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MediaTypesRequestParameters {

    public MediaTypesRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/media_types/MediaTypesResponse.java": "
package test.test.runtime.api.handlers.media_types;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the mediaTypes operation
 */
public interface MediaTypesResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypes.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the multipleContentTypes operation
 */
public abstract class MultipleContentTypes implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the multipleContentTypes operation
     */
    public abstract MultipleContentTypesResponse handle(final MultipleContentTypesRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<MultipleContentTypesInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(MultipleContentTypes.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<MultipleContentTypesInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<MultipleContentTypesInput>> getHandlerInterceptors() {
        List<Interceptor<MultipleContentTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<MultipleContentTypesInput> buildChain(List<Interceptor<MultipleContentTypesInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<MultipleContentTypesInput>() {
            @Override
            public Response next(ChainedRequestInput<MultipleContentTypesInput> input) {
                return handle(new MultipleContentTypesRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<MultipleContentTypesInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final MultipleContentTypesInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<MultipleContentTypesInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public MultipleContentTypesInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new MultipleContentTypesInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<MultipleContentTypesInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "multipleContentTypes");

        List<Interceptor<MultipleContentTypesInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        MultipleContentTypesInput input;

        try {
            input = new MultipleContentTypesInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypes200Response.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the multipleContentTypes operation
 */
public class MultipleContentTypes200Response extends RuntimeException implements MultipleContentTypesResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final String typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private MultipleContentTypes200Response(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body;
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public String getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a MultipleContentTypes200Response with a body
     */
    public static MultipleContentTypes200Response of(final String body) {
        return new MultipleContentTypes200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a MultipleContentTypes200Response with a body and headers
     */
    public static MultipleContentTypes200Response of(final String body, final Map<String, String> headers) {
        return new MultipleContentTypes200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a MultipleContentTypes200Response with a body, headers and multi-value headers
     */
    public static MultipleContentTypes200Response of(final String body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new MultipleContentTypes200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesInput.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the multipleContentTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MultipleContentTypesInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final MultipleContentTypesRequestParameters requestParameters;
    private final TestRequest body;

    public MultipleContentTypesInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new MultipleContentTypesRequestParameters(event);
        try {
            this.body = TestRequest.fromJson(event.getBody());
        } catch (IOException e) {
            throw new RuntimeException(e);
        };
    }

    public MultipleContentTypesRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

    public TestRequest getBody() {
        return this.body;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesRequestInput.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the multipleContentTypes operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MultipleContentTypesRequestInput implements RequestInput<MultipleContentTypesInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final MultipleContentTypesInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public MultipleContentTypesInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesRequestParameters.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the MultipleContentTypes operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class MultipleContentTypesRequestParameters {

    public MultipleContentTypesRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/multiple_content_types/MultipleContentTypesResponse.java": "
package test.test.runtime.api.handlers.multiple_content_types;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the multipleContentTypes operation
 */
public interface MultipleContentTypesResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the operationOne operation
 */
public abstract class OperationOne implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the operationOne operation
     */
    public abstract OperationOneResponse handle(final OperationOneRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<OperationOneInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(OperationOne.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<OperationOneInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<OperationOneInput>> getHandlerInterceptors() {
        List<Interceptor<OperationOneInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<OperationOneInput> buildChain(List<Interceptor<OperationOneInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<OperationOneInput>() {
            @Override
            public Response next(ChainedRequestInput<OperationOneInput> input) {
                return handle(new OperationOneRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<OperationOneInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final OperationOneInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<OperationOneInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public OperationOneInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new OperationOneInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        if (statusCode == 400 && "ApiError".endsWith("ResponseContent")) {
            headers.put("x-amzn-errortype", "ApiError".substring(0, "ApiError".length() - "ResponseContent".length()));
        }
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<OperationOneInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "operationOne");

        List<Interceptor<OperationOneInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        OperationOneInput input;

        try {
            input = new OperationOneInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne200Response.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the operationOne operation
 */
public class OperationOne200Response extends RuntimeException implements OperationOneResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final TestResponse typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private OperationOne200Response(final TestResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public TestResponse getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a OperationOne200Response with a body
     */
    public static OperationOne200Response of(final TestResponse body) {
        return new OperationOne200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a OperationOne200Response with a body and headers
     */
    public static OperationOne200Response of(final TestResponse body, final Map<String, String> headers) {
        return new OperationOne200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a OperationOne200Response with a body, headers and multi-value headers
     */
    public static OperationOne200Response of(final TestResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new OperationOne200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOne400Response.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 400 for the operationOne operation
 */
public class OperationOne400Response extends RuntimeException implements OperationOneResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final ApiError typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private OperationOne400Response(final ApiError body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 400;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public ApiError getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a OperationOne400Response with a body
     */
    public static OperationOne400Response of(final ApiError body) {
        return new OperationOne400Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a OperationOne400Response with a body and headers
     */
    public static OperationOne400Response of(final ApiError body, final Map<String, String> headers) {
        return new OperationOne400Response(body, headers, new HashMap<>());
    }

    /**
     * Create a OperationOne400Response with a body, headers and multi-value headers
     */
    public static OperationOne400Response of(final ApiError body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new OperationOne400Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneInput.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the operationOne operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OperationOneInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final OperationOneRequestParameters requestParameters;
    private final TestRequest body;

    public OperationOneInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new OperationOneRequestParameters(event);
        try {
            this.body = TestRequest.fromJson(event.getBody());
        } catch (IOException e) {
            throw new RuntimeException(e);
        };
    }

    public OperationOneRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

    public TestRequest getBody() {
        return this.body;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneRequestInput.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the operationOne operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OperationOneRequestInput implements RequestInput<OperationOneInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final OperationOneInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public OperationOneInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneRequestParameters.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the OperationOne operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class OperationOneRequestParameters {
    private final String param1;
    private final List<String> param2;
    private final BigDecimal param3;
    private final String pathParam;
    private final String xHeaderParam;
    private final Optional<String> param4;
    private final Optional<List<String>> xMultiValueHeaderParam;

    public OperationOneRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

        this.param1 = Handlers.coerceStringParameter("param1", true, decodedStringParameters);
        this.param2 = Handlers.coerceStringArrayParameter("param2", true, decodedStringArrayParameters);
        this.param3 = Handlers.coerceBigDecimalParameter("param3", true, decodedStringParameters);
        this.pathParam = Handlers.coerceStringParameter("pathParam", true, decodedStringParameters);
        this.xHeaderParam = Handlers.coerceStringParameter("x-header-param", true, decodedStringParameters);
        this.param4 = Optional.ofNullable(Handlers.coerceStringParameter("param4", false, decodedStringParameters));
        this.xMultiValueHeaderParam = Optional.ofNullable(Handlers.coerceStringArrayParameter("x-multi-value-header-param", false, decodedStringArrayParameters));
    }

    public String getParam1() {
        return this.param1;
    }
    public List<String> getParam2() {
        return this.param2;
    }
    public BigDecimal getParam3() {
        return this.param3;
    }
    public String getPathParam() {
        return this.pathParam;
    }
    public String getxHeaderParam() {
        return this.xHeaderParam;
    }
    public Optional<String> getParam4() {
        return this.param4;
    }
    public Optional<List<String>> getxMultiValueHeaderParam() {
        return this.xMultiValueHeaderParam;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/operation_one/OperationOneResponse.java": "
package test.test.runtime.api.handlers.operation_one;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the operationOne operation
 */
public interface OperationOneResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDelete.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.Handlers;
import test.test.runtime.api.handlers.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import org.crac.Core;
import org.crac.Resource;


/**
 * Lambda handler wrapper for the withoutOperationIdDelete operation
 */
public abstract class WithoutOperationIdDelete implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>, Resource {
    {
        Core.getGlobalContext().register(this);
    }

    /**
     * Handle the request for the withoutOperationIdDelete operation
     */
    public abstract WithoutOperationIdDeleteResponse handle(final WithoutOperationIdDeleteRequestInput request);

    /**
     * Interceptors that the handler class has been decorated with
     */
    private List<Interceptor<WithoutOperationIdDeleteInput>> annotationInterceptors = Handlers.getAnnotationInterceptors(WithoutOperationIdDelete.class);

    /**
     * For more complex interceptors that require instantiation with parameters, you may override this method to
     * return a list of instantiated interceptors. For simple interceptors with no need for constructor arguments,
     * prefer the @Interceptors annotation.
     */
    public List<Interceptor<WithoutOperationIdDeleteInput>> getInterceptors() {
        return Collections.emptyList();
    }

    private List<Interceptor<WithoutOperationIdDeleteInput>> getHandlerInterceptors() {
        List<Interceptor<WithoutOperationIdDeleteInput>> interceptors = new ArrayList<>();
        interceptors.addAll(annotationInterceptors);
        interceptors.addAll(this.getInterceptors());
        return interceptors;
    }

    private HandlerChain<WithoutOperationIdDeleteInput> buildChain(List<Interceptor<WithoutOperationIdDeleteInput>> interceptors) {
        return Handlers.buildHandlerChain(interceptors, new HandlerChain<WithoutOperationIdDeleteInput>() {
            @Override
            public Response next(ChainedRequestInput<WithoutOperationIdDeleteInput> input) {
                return handle(new WithoutOperationIdDeleteRequestInput(input.getEvent(), input.getContext(), input.getInterceptorContext(), input.getInput()));
            }
        });
    }

    private ChainedRequestInput<WithoutOperationIdDeleteInput> buildChainedRequestInput(final APIGatewayProxyRequestEvent event, final Context context, final WithoutOperationIdDeleteInput input, final Map<String, Object> interceptorContext) {
        return new ChainedRequestInput<WithoutOperationIdDeleteInput>() {
            @Override
            public HandlerChain getChain() {
                // The chain's next method ignores the chain given as input, and is pre-built to follow the remaining
                // chain.
                return null;
            }

            @Override
            public APIGatewayProxyRequestEvent getEvent() {
                return event;
            }

            @Override
            public Context getContext() {
                return context;
            }

            @Override
            public WithoutOperationIdDeleteInput getInput() {
                return input;
            }

            @Override
            public Map<String, Object> getInterceptorContext() {
                return interceptorContext;
            }
        };
    }

    @Override
    public void beforeCheckpoint(org.crac.Context<? extends Resource> context) {
        // Prime building the handler chain which can take a few 100ms to JIT.
        this.buildChain(this.getHandlerInterceptors());
        this.buildChainedRequestInput(null, null, null, null);

        // Initialise instance of Gson and prime serialisation and deserialisation
        new JSON();
        JSON.getGson().fromJson(JSON.getGson().toJson(new ApiResponse("", 0, new HashMap<>(), new HashMap<>())), ApiResponse.class);

        try {
            // Prime input validation - this will likely fail for the fake event but ensures the code path is optimised
            // ready for a real invocation
            new WithoutOperationIdDeleteInput(new APIGatewayProxyRequestEvent()
                    .withBody("{}")
                    .withPathParameters(new HashMap<>())
                    .withQueryStringParameters(new HashMap<>())
                    .withMultiValueQueryStringParameters(new HashMap<>())
                    .withHeaders(new HashMap<>())
                    .withMultiValueHeaders(new HashMap<>())
            );
        } catch (Exception e) {

        }

        this.warmUp();
    }

    @Override
    public void afterRestore(org.crac.Context<? extends Resource> context) {

    }

    /**
     * Override this method to perform any warmup activities which will be executed prior to the snap-start snapshot.
     */
    public void warmUp() {

    }

    @Override
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent event, final Context context) {
        return this.handleRequestWithAdditionalInterceptors(event, context, new ArrayList<>());
    }

    private Map<String, String> getErrorResponseHeaders(final int statusCode) {
        Map<String, String> headers = new HashMap<>();
        return headers;
    }

    public APIGatewayProxyResponseEvent handleRequestWithAdditionalInterceptors(final APIGatewayProxyRequestEvent event, final Context context, final List<Interceptor<WithoutOperationIdDeleteInput>> additionalInterceptors) {
        final Map<String, Object> interceptorContext = new HashMap<>();
        interceptorContext.put("operationId", "withoutOperationIdDelete");

        List<Interceptor<WithoutOperationIdDeleteInput>> interceptors = new ArrayList<>();
        interceptors.addAll(additionalInterceptors);
        interceptors.addAll(this.getHandlerInterceptors());

        final HandlerChain chain = this.buildChain(interceptors);

        WithoutOperationIdDeleteInput input;

        try {
            input = new WithoutOperationIdDeleteInput(event);
        } catch (RuntimeException e) {
            Map<String, String> headers = new HashMap<>();
            headers.putAll(Handlers.extractResponseHeadersFromInterceptors(interceptors));
            headers.putAll(this.getErrorResponseHeaders(400));
            return new APIGatewayProxyResponseEvent()
                .withStatusCode(400)
                .withHeaders(headers)
                .withBody("{\\"message\\": \\"" + e.getMessage() + "\\"}");
        }

        final Response response = chain.next(this.buildChainedRequestInput(event, context, input, interceptorContext));

        Map<String, String> responseHeaders = new HashMap<>();
        responseHeaders.putAll(this.getErrorResponseHeaders(response.getStatusCode()));
        responseHeaders.putAll(response.getHeaders());

        return new APIGatewayProxyResponseEvent()
                .withStatusCode(response.getStatusCode())
                .withHeaders(responseHeaders)
                .withMultiValueHeaders(response.getMultiValueHeaders())
                .withBody(response.getBody());
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDelete200Response.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.Map;
import java.util.HashMap;
import java.util.List;

/**
 * Response with status code 200 for the withoutOperationIdDelete operation
 */
public class WithoutOperationIdDelete200Response extends RuntimeException implements WithoutOperationIdDeleteResponse {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final String body;
    private final TestResponse typedBody;
    private final Map<String, String> headers;
    private final Map<String, List<String>> multiValueHeaders;

    private WithoutOperationIdDelete200Response(final TestResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        this.typedBody = body;
        this.body = body.toJson();
        this.headers = headers;
        this.multiValueHeaders = multiValueHeaders;
    }

    @Override
    public int getStatusCode() {
        return 200;
    }

    @Override
    public String getBody() {
        return this.body;
    }

    public TestResponse getTypedBody() {
        return this.typedBody;
    }

    @Override
    public Map<String, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, List<String>> getMultiValueHeaders() {
        return this.multiValueHeaders;
    }

    /**
     * Create a WithoutOperationIdDelete200Response with a body
     */
    public static WithoutOperationIdDelete200Response of(final TestResponse body) {
        return new WithoutOperationIdDelete200Response(body, new HashMap<>(), new HashMap<>());
    }

    /**
     * Create a WithoutOperationIdDelete200Response with a body and headers
     */
    public static WithoutOperationIdDelete200Response of(final TestResponse body, final Map<String, String> headers) {
        return new WithoutOperationIdDelete200Response(body, headers, new HashMap<>());
    }

    /**
     * Create a WithoutOperationIdDelete200Response with a body, headers and multi-value headers
     */
    public static WithoutOperationIdDelete200Response of(final TestResponse body, final Map<String, String> headers, final Map<String, List<String>> multiValueHeaders) {
        return new WithoutOperationIdDelete200Response(body, headers, multiValueHeaders);
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteInput.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.model.*;
import test.test.runtime.JSON;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;

/**
 * Input for the withoutOperationIdDelete operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class WithoutOperationIdDeleteInput {
    static {
        // JSON has a static instance of Gson which is instantiated lazily the first time it is initialised.
        // Create an instance here if required to ensure that the static Gson instance is always available.
        if (JSON.getGson() == null) {
            new JSON();
        }
    }

    private final WithoutOperationIdDeleteRequestParameters requestParameters;

    public WithoutOperationIdDeleteInput(final APIGatewayProxyRequestEvent event) {
        this.requestParameters = new WithoutOperationIdDeleteRequestParameters(event);
    }

    public WithoutOperationIdDeleteRequestParameters getRequestParameters() {
        return this.requestParameters;
    }

}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteRequestInput.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.model.*;
import test.test.runtime.api.handlers.RequestInput;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import java.io.IOException;
import com.amazonaws.services.lambda.runtime.Context;

/**
 * Full request input for the withoutOperationIdDelete operation, including the raw API Gateway event
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class WithoutOperationIdDeleteRequestInput implements RequestInput<WithoutOperationIdDeleteInput> {
    private final APIGatewayProxyRequestEvent event;
    private final Context context;
    private final Map<String, Object> interceptorContext;
    private final WithoutOperationIdDeleteInput input;

    /**
     * Returns the typed request input, with path, query and body parameters
     */
    public WithoutOperationIdDeleteInput getInput() {
        return this.input;
    }

    /**
     * Returns the raw API Gateway event
     */
    public APIGatewayProxyRequestEvent getEvent() {
        return this.event;
    }

    /**
     * Returns the lambda context
     */
    public Context getContext() {
        return this.context;
    }

    /**
     * Returns the interceptor context, which may contain values set by request interceptors
     */
    public Map<String, Object> getInterceptorContext() {
        return this.interceptorContext;
    }
}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteRequestParameters.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.api.handlers.Handlers;
import java.util.Optional;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.time.OffsetDateTime;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;

import test.test.runtime.model.*;

/**
 * Query, path and header parameters for the WithoutOperationIdDelete operation
 */
@lombok.Builder
@lombok.AllArgsConstructor
public class WithoutOperationIdDeleteRequestParameters {

    public WithoutOperationIdDeleteRequestParameters(final APIGatewayProxyRequestEvent event) {
        Map<String, String> rawStringParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getPathParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getQueryStringParameters(), rawStringParameters);
        Handlers.putAllFromNullableMap(event.getHeaders(), rawStringParameters);
        Map<String, String> decodedStringParameters = Handlers.decodeRequestParameters(rawStringParameters);

        Map<String, List<String>> rawStringArrayParameters = new HashMap<>();
        Handlers.putAllFromNullableMap(event.getMultiValueQueryStringParameters(), rawStringArrayParameters);
        Handlers.putAllFromNullableMap(event.getMultiValueHeaders(), rawStringArrayParameters);
        Map<String, List<String>> decodedStringArrayParameters = Handlers.decodeRequestArrayParameters(rawStringArrayParameters);

    }

}
",
  "src/main/java/test/test/runtime/api/handlers/without_operation_id_delete/WithoutOperationIdDeleteResponse.java": "
package test.test.runtime.api.handlers.without_operation_id_delete;

import test.test.runtime.api.handlers.Response;

/**
 * Response for the withoutOperationIdDelete operation
 */
public interface WithoutOperationIdDeleteResponse extends Response {}
",
  "src/main/java/test/test/runtime/api/interceptors/DefaultInterceptors.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.interceptors.powertools.LoggingInterceptor;
import test.test.runtime.api.interceptors.powertools.MetricsInterceptor;
import test.test.runtime.api.interceptors.powertools.TracingInterceptor;
import test.test.runtime.api.handlers.Interceptor;

import java.util.Arrays;
import java.util.List;

public class DefaultInterceptors {
    public static <T> List<Interceptor<T>> all() {
        return Arrays.asList(
            new ResponseHeadersInterceptor<>(),
            new LoggingInterceptor<>(),
            new TryCatchInterceptor<>(),
            new TracingInterceptor<>(),
            new MetricsInterceptor<>()
        );
    }
}",
  "src/main/java/test/test/runtime/api/interceptors/ResponseHeadersInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import java.util.Map;
import java.util.HashMap;

/**
 * An interceptor for adding cross-origin resource sharing (CORS) headers to the response.
 * Allows all origins and headers.
 */
public class ResponseHeadersInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final Map<String, String> additionalHeaders;

    public ResponseHeadersInterceptor() {
        this.additionalHeaders = new HashMap<>();
        this.additionalHeaders.put("Access-Control-Allow-Origin", "*");
        this.additionalHeaders.put("Access-Control-Allow-Headers", "*");
    }

    public ResponseHeadersInterceptor(final Map<String, String> headers) {
        this.additionalHeaders = headers;
    }

    @Override
    public Response handle(ChainedRequestInput<Input> input) {
        Response res = input.getChain().next(input);
        res.getHeaders().putAll(this.additionalHeaders);
        return res;
    }

    public Map<String, String> getAdditionalHeaders() {
        return this.additionalHeaders;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/TryCatchInterceptor.java": "package test.test.runtime.api.interceptors;

import test.test.runtime.api.handlers.ApiResponse;
import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import org.apache.logging.log4j.Logger;

/**
 * Interceptor for handling uncaught exceptions and responding with a default error response
 */
public class TryCatchInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private final int statusCode;
    private final String errorResponseBody;

    public TryCatchInterceptor() {
        this(500, "{\\"message\\": \\"Internal Error\\"}");
    }

    public TryCatchInterceptor(final int statusCode, final String errorResponseBody) {
        this.statusCode = statusCode;
        this.errorResponseBody = errorResponseBody;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        try {
            return input.getChain().next(input);
        } catch (Throwable e) {
            if (e instanceof Response) {
                return (Response) e;
            }

            Object logger = input.getInterceptorContext().get("logger");
            if (logger instanceof Logger) {
                ((Logger) logger).error("Interceptor caught exception", e);
            } else {
                System.err.println("Interceptor caught exception");
                e.printStackTrace();
            }

            return ApiResponse.builder()
                    .statusCode(this.statusCode)
                    .body(this.errorResponseBody)
                    .build();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/LoggingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.services.lambda.runtime.Context;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.logging.LoggingUtils;

/**
 * An interceptor which adds an aws lambda powertools logger to the interceptor context,
 * and adds the lambda context.
 * See https://docs.powertools.aws.dev/lambda/java/latest/core/logging/
 */
public class LoggingInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private Logger logger = LogManager.getLogger(LoggingInterceptor.class);

    @Override
    public void warmUp() {
        super.warmUp();
        logger.info("LoggingInterceptor: init");
    }

    /**
     * Return the instance of the logger from the interceptor context
     */
    public static <T> Logger getLogger(final RequestInput<T> request) {
        Object logger = request.getInterceptorContext().get("logger");
        if (logger == null) {
            throw new RuntimeException("No logger found. Did you configure the LoggingInterceptor?");
        }
        return (Logger) logger;
    }

    private void addContext(final Context context) {
        LoggingUtils.appendKey("functionName", context.getFunctionName());
        LoggingUtils.appendKey("functionVersion", context.getFunctionVersion());
        LoggingUtils.appendKey("functionArn", context.getInvokedFunctionArn());
        LoggingUtils.appendKey("functionMemorySize", String.valueOf(context.getMemoryLimitInMB()));
        // Same casing as powertools aspect implementation
        LoggingUtils.appendKey("function_request_id", String.valueOf(context.getAwsRequestId()));
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        // Add lambda context fields
        this.addContext(input.getContext());

        // Add service, cold start and tracing
        LoggingUtils.appendKey("service", LambdaHandlerProcessor.serviceName());
        LoggingUtils.appendKey("coldStart", LambdaHandlerProcessor.isColdStart() ? "true" : "false");
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((xRayTraceId) -> {
            LoggingUtils.appendKey("xray_trace_id", xRayTraceId);
        });

        // Add the operation id
        String operationId = (String) input.getInterceptorContext().get("operationId");
        LoggingUtils.appendKey("operationId", operationId);

        // Add the logger to the interceptor context
        input.getInterceptorContext().put("logger", logger);

        Response response = input.getChain().next(input);

        // Mark cold start done
        LambdaHandlerProcessor.coldStartDone();

        // Clear the logger keys
        ThreadContext.clearMap();

        return response;
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/MetricsInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.RequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;
import software.amazon.cloudwatchlogs.emf.model.DimensionSet;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.metrics.MetricsUtils;

/**
 * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context (under the key "metrics"),
 * and ensures metrics are flushed prior to finishing the lambda execution
 * See: https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics
 */
public class MetricsInterceptor<Input> extends InterceptorWithWarmup<Input> {
    private MetricsLogger metrics = MetricsUtils.metricsLogger();

    /**
     * Return the instance of the metrics logger from the interceptor context
     */
    public static <T> MetricsLogger getMetrics(final RequestInput<T> request) {
        Object metrics = request.getInterceptorContext().get("metrics");
        if (metrics == null) {
            throw new RuntimeException("No metrics logger found. Did you configure the MetricsInterceptor?");
        }
        return (MetricsLogger) metrics;
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        metrics.putDimensions(DimensionSet.of("operationId", (String) input.getInterceptorContext().get("operationId")));

        input.getInterceptorContext().put("metrics", metrics);

        metrics.putProperty("function_request_id", input.getContext().getAwsRequestId());
        LambdaHandlerProcessor.getXrayTraceId().ifPresent((traceId) -> {
            metrics.putProperty("xray_trace_id", traceId);
        });

        try {
            Response response = input.getChain().next(input);

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } finally {
            metrics.flush();
        }
    }
}
",
  "src/main/java/test/test/runtime/api/interceptors/powertools/TracingInterceptor.java": "package test.test.runtime.api.interceptors.powertools;

import test.test.runtime.api.handlers.ChainedRequestInput;
import test.test.runtime.api.handlers.Response;
import test.test.runtime.api.handlers.Interceptor;
import test.test.runtime.api.handlers.InterceptorWithWarmup;
import com.amazonaws.xray.AWSXRay;
import com.amazonaws.xray.AWSXRayRecorderBuilder;
import com.amazonaws.xray.entities.Subsegment;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.core.internal.LambdaHandlerProcessor;
import software.amazon.lambda.powertools.tracing.TracingUtils;

/**
 * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * See: https://docs.powertools.aws.dev/lambda/java/latest/core/tracing/
 */
public class TracingInterceptor<Input> extends InterceptorWithWarmup<Input> {

    static {
        AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard();
        AWSXRay.setGlobalRecorder(builder.build());
    }

    private final boolean captureResponse;

    public TracingInterceptor(final boolean captureResponse) {
        this.captureResponse = captureResponse;
    }

    public TracingInterceptor() {
        this(false);
    }

    @Override
    public void warmUp() {
        try {
            // Set a dummy trace header to ensure the regular subsegment code path is followed and warmed.
            // The segment is not actually recorded by xray.
            System.setProperty("com.amazonaws.xray.traceHeader", "Root=1-xxx;Parent=yyy;Sampled=1");
            super.warmUp();
        } finally {
            System.clearProperty("com.amazonaws.xray.traceHeader");
        }
    }

    private void logError(final String message, final ChainedRequestInput<Input> input, final Throwable e) {
        Object logger = input.getInterceptorContext().get("logger");
        if (logger instanceof Logger) {
            ((Logger) logger).error(message, e);
        } else {
            System.err.println(message);
            e.printStackTrace();
        }
    }

    @Override
    public Response handle(final ChainedRequestInput<Input> input) {
        String operationId = (String) input.getInterceptorContext().get("operationId");
        Subsegment segment = AWSXRay.beginSubsegment("## " + operationId);

        segment.setNamespace(operationId);
        segment.putAnnotation("ColdStart", LambdaHandlerProcessor.isColdStart());
        segment.putAnnotation("Service", LambdaHandlerProcessor.serviceName());

        try {
            Response response = input.getChain().next(input);

            try {
                if (this.captureResponse) {
                    segment.putMetadata(operationId + " response", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(response) : response);
                }
            } catch (JsonProcessingException e) {
                this.logError("Failed to add response to trace", input, e);
            }

            // Mark cold start done
            LambdaHandlerProcessor.coldStartDone();

            return response;
        } catch (Throwable e) {
            try {
                segment.putMetadata(operationId + " error", TracingUtils.objectMapper() != null ? TracingUtils.objectMapper().writeValueAsString(e) : e);
            } catch (JsonProcessingException ex) {
                this.logError("Failed to add error to trace", input, e);
            }
            throw e;
        } finally {
            if (!LambdaHandlerProcessor.isSamLocal()) {
                AWSXRay.endSubsegment();
            }
        }
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationConfig.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;

// Generic type for object "keyed" by operation names
@lombok.Builder @lombok.Getter
public class OperationConfig<T> {
    private T anyRequestResponse;
    private T empty;
    private T mapResponse;
    private T mediaTypes;
    private T multipleContentTypes;
    private T operationOne;
    private T withoutOperationIdDelete;

    public Map<String, T> asMap() {
        Map<String, T> map = new HashMap<>();
        map.put("anyRequestResponse", this.anyRequestResponse);
        map.put("empty", this.empty);
        map.put("mapResponse", this.mapResponse);
        map.put("mediaTypes", this.mediaTypes);
        map.put("multipleContentTypes", this.multipleContentTypes);
        map.put("operationOne", this.operationOne);
        map.put("withoutOperationIdDelete", this.withoutOperationIdDelete);
        return map;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/OperationLookup.java": "package test.test.runtime.api.operation_config;

import test.test.runtime.model.*;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.Arrays;


// Look up path and http method for a given operation name
public class OperationLookup {
    @lombok.Builder @lombok.Getter
    public static class OperationLookupEntry {
        private String method;
        private String path;
        private List<String> contentTypes;
    }

    /**
     * Returns the operation lookup information for the TypeSafeRestApi construct
     */
    public static Map<String, OperationLookupEntry> getOperationLookup() {
        final Map<String, OperationLookupEntry> config = new HashMap<>();

        config.put("anyRequestResponse", OperationLookupEntry.builder()
            .path("/any-request-response")
            .method("PUT")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("empty", OperationLookupEntry.builder()
            .path("/empty-response")
            .method("PUT")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("mapResponse", OperationLookupEntry.builder()
            .path("/map-response")
            .method("GET")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("mediaTypes", OperationLookupEntry.builder()
            .path("/different-media-type")
            .method("POST")
            .contentTypes(Arrays.asList("application/pdf"))
            .build());
        config.put("multipleContentTypes", OperationLookupEntry.builder()
            .path("/multiple-content-types")
            .method("POST")
            .contentTypes(Arrays.asList("application/json","application/pdf"))
            .build());
        config.put("operationOne", OperationLookupEntry.builder()
            .path("/path/{pathParam}")
            .method("POST")
            .contentTypes(Arrays.asList("application/json"))
            .build());
        config.put("withoutOperationIdDelete", OperationLookupEntry.builder()
            .path("/without-operation-id")
            .method("DELETE")
            .contentTypes(Arrays.asList("application/json"))
            .build());

        return config;
    }
}
",
  "src/main/java/test/test/runtime/api/operation_config/Operations.java": "package test.test.runtime.api.operation_config;

public class Operations {
    /**
     * Returns an OperationConfig Builder with all values populated with the given value.
     * You can override specific values on the builder if you like.
     * Make sure you call \`.build()\` at the end to construct the OperationConfig.
     */
    public static <T> OperationConfig.OperationConfigBuilder<T> all(final T value) {
        return OperationConfig.<T>builder()
                .anyRequestResponse(value)
                .empty(value)
                .mapResponse(value)
                .mediaTypes(value)
                .multipleContentTypes(value)
                .operationOne(value)
                .withoutOperationIdDelete(value)
                ;
    }
}
",
  "src/main/java/test/test/runtime/auth/ApiKeyAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class ApiKeyAuth implements Authentication {
  private final String location;
  private final String paramName;

  private String apiKey;
  private String apiKeyPrefix;

  public ApiKeyAuth(String location, String paramName) {
    this.location = location;
    this.paramName = paramName;
  }

  public String getLocation() {
    return location;
  }

  public String getParamName() {
    return paramName;
  }

  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }

  public String getApiKeyPrefix() {
    return apiKeyPrefix;
  }

  public void setApiKeyPrefix(String apiKeyPrefix) {
    this.apiKeyPrefix = apiKeyPrefix;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                           String payload, String method, URI uri) throws ApiException {
    if (apiKey == null) {
      return;
    }
    String value;
    if (apiKeyPrefix != null) {
      value = apiKeyPrefix + " " + apiKey;
    } else {
      value = apiKey;
    }
    if ("query".equals(location)) {
      queryParams.add(new Pair(paramName, value));
    } else if ("header".equals(location)) {
      headerParams.put(paramName, value);
    } else if ("cookie".equals(location)) {
      cookieParams.put(paramName, value);
    }
  }
}
",
  "src/main/java/test/test/runtime/auth/Authentication.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import java.net.URI;
import java.util.Map;
import java.util.List;

public interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     *
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws ApiException if failed to update the parameters
     */
    void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException;
}
",
  "src/main/java/test/test/runtime/auth/HttpBasicAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.Pair;
import test.test.runtime.ApiException;

import okhttp3.Credentials;

import java.net.URI;
import java.util.Map;
import java.util.List;

import java.io.UnsupportedEncodingException;

public class HttpBasicAuth implements Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                              String payload, String method, URI uri) throws ApiException {
        if (username == null && password == null) {
            return;
        }
        headerParams.put("Authorization", Credentials.basic(
            username == null ? "" : username,
            password == null ? "" : password));
    }
}
",
  "src/main/java/test/test/runtime/auth/HttpBearerAuth.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.auth;

import test.test.runtime.ApiException;
import test.test.runtime.Pair;

import java.net.URI;
import java.util.Map;
import java.util.List;

public class HttpBearerAuth implements Authentication {
  private final String scheme;
  private String bearerToken;

  public HttpBearerAuth(String scheme) {
    this.scheme = scheme;
  }

  /**
   * Gets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @return The bearer token
   */
  public String getBearerToken() {
    return bearerToken;
  }

  /**
   * Sets the token, which together with the scheme, will be sent as the value of the Authorization header.
   *
   * @param bearerToken The bearer token to send in the Authorization header
   */
  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }

  @Override
  public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams,
                            String payload, String method, URI uri) throws ApiException {
    if (bearerToken == null) {
      return;
    }

    headerParams.put("Authorization", (scheme != null ? upperCaseBearer(scheme) + " " : "") + bearerToken);
  }

  private static String upperCaseBearer(String scheme) {
    return ("bearer".equalsIgnoreCase(scheme)) ? "Bearer" : scheme;
  }
}
",
  "src/main/java/test/test/runtime/model/AbstractOpenApiSchema.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import test.test.runtime.ApiException;
import java.util.Objects;
import java.lang.reflect.Type;
import java.util.Map;
import javax.ws.rs.core.GenericType;

//import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Abstract class for oneOf,anyOf schemas defined in OpenAPI spec
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public abstract class AbstractOpenApiSchema {

    // store the actual instance of the schema/object
    private Object instance;

    // is nullable
    private Boolean isNullable;

    // schema type (e.g. oneOf, anyOf)
    private final String schemaType;

    public AbstractOpenApiSchema(String schemaType, Boolean isNullable) {
        this.schemaType = schemaType;
        this.isNullable = isNullable;
    }

    /**
     * Get the list of oneOf/anyOf composed schemas allowed to be stored in this object
     *
     * @return an instance of the actual schema/object
     */
    public abstract Map<String, GenericType> getSchemas();

    /**
     * Get the actual instance
     *
     * @return an instance of the actual schema/object
     */
    //@JsonValue
    public Object getActualInstance() {return instance;}

    /**
     * Set the actual instance
     *
     * @param instance the actual instance of the schema/object
     */
    public void setActualInstance(Object instance) {this.instance = instance;}

    /**
     * Get the instant recursively when the schemas defined in oneOf/anyof happen to be oneOf/anyOf schema as well
     *
     * @return an instance of the actual schema/object
     */
    public Object getActualInstanceRecursively() {
        return getActualInstanceRecursively(this);
    }

    private Object getActualInstanceRecursively(AbstractOpenApiSchema object) {
        if (object.getActualInstance() == null) {
            return null;
        } else if (object.getActualInstance() instanceof AbstractOpenApiSchema) {
            return getActualInstanceRecursively((AbstractOpenApiSchema)object.getActualInstance());
        } else {
            return object.getActualInstance();
        }
    }

    /**
     * Get the schema type (e.g. anyOf, oneOf)
     *
     * @return the schema type
     */
    public String getSchemaType() {
        return schemaType;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ").append(getClass()).append(" {\\n");
        sb.append("    instance: ").append(toIndentedString(instance)).append("\\n");
        sb.append("    isNullable: ").append(toIndentedString(isNullable)).append("\\n");
        sb.append("    schemaType: ").append(toIndentedString(schemaType)).append("\\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\\n", "\\n    ");
    }

    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AbstractOpenApiSchema a = (AbstractOpenApiSchema) o;
        return Objects.equals(this.instance, a.instance) &&
            Objects.equals(this.isNullable, a.isNullable) &&
            Objects.equals(this.schemaType, a.schemaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(instance, isNullable, schemaType);
    }

    /**
     * Is nullable
     *
     * @return true if it's nullable
     */
    public Boolean isNullable() {
        if (Boolean.TRUE.equals(isNullable)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }



}
",
  "src/main/java/test/test/runtime/model/ApiError.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * ApiError
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class ApiError {
  public static final String SERIALIZED_NAME_ERROR_MESSAGE = "errorMessage";
  @SerializedName(SERIALIZED_NAME_ERROR_MESSAGE)
  private String errorMessage;

  public ApiError() {
  }

  public ApiError errorMessage(String errorMessage) {

    this.errorMessage = errorMessage;
    return this;
  }

   /**
   * Get errorMessage
   * @return errorMessage
  **/
  @javax.annotation.Nonnull
  public String getErrorMessage() {
    return errorMessage;
  }


  public void setErrorMessage(String errorMessage) {
    this.errorMessage = errorMessage;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiError apiError = (ApiError) o;
    return Objects.equals(this.errorMessage, apiError.errorMessage);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(errorMessage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiError {\\n");
    sb.append("    errorMessage: ").append(toIndentedString(errorMessage)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("errorMessage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("errorMessage");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ApiError
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ApiError.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApiError is not found in the empty JSON string", ApiError.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ApiError.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`ApiError\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ApiError.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("errorMessage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`errorMessage\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("errorMessage").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApiError.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApiError' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApiError> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApiError.class));

       return (TypeAdapter<T>) new TypeAdapter<ApiError>() {
           @Override
           public void write(JsonWriter out, ApiError value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApiError read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ApiError given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ApiError
  * @throws IOException if the JSON string is invalid with respect to ApiError
  */
  public static ApiError fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiError.class);
  }

 /**
  * Convert an instance of ApiError to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/MapResponse.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.MapResponseMapPropertyValue;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * MapResponse
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class MapResponse {
  public static final String SERIALIZED_NAME_MAP_PROPERTY = "mapProperty";
  @SerializedName(SERIALIZED_NAME_MAP_PROPERTY)
  private Map<String, MapResponseMapPropertyValue> mapProperty = new HashMap<>();

  public MapResponse() {
  }

  public MapResponse mapProperty(Map<String, MapResponseMapPropertyValue> mapProperty) {

    this.mapProperty = mapProperty;
    return this;
  }

  public MapResponse putMapPropertyItem(String key, MapResponseMapPropertyValue mapPropertyItem) {
    this.mapProperty.put(key, mapPropertyItem);
    return this;
  }

   /**
   * Get mapProperty
   * @return mapProperty
  **/
  @javax.annotation.Nonnull
  public Map<String, MapResponseMapPropertyValue> getMapProperty() {
    return mapProperty;
  }


  public void setMapProperty(Map<String, MapResponseMapPropertyValue> mapProperty) {
    this.mapProperty = mapProperty;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MapResponse mapResponse = (MapResponse) o;
    return Objects.equals(this.mapProperty, mapResponse.mapProperty);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(mapProperty);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MapResponse {\\n");
    sb.append("    mapProperty: ").append(toIndentedString(mapProperty)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("mapProperty");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("mapProperty");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MapResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MapResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MapResponse is not found in the empty JSON string", MapResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MapResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`MapResponse\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MapResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MapResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MapResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MapResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MapResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<MapResponse>() {
           @Override
           public void write(JsonWriter out, MapResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MapResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MapResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MapResponse
  * @throws IOException if the JSON string is invalid with respect to MapResponse
  */
  public static MapResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MapResponse.class);
  }

 /**
  * Convert an instance of MapResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/MapResponseMapPropertyValue.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * MapResponseMapPropertyValue
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class MapResponseMapPropertyValue {
  public static final String SERIALIZED_NAME_A = "a";
  @SerializedName(SERIALIZED_NAME_A)
  private String a;

  public static final String SERIALIZED_NAME_B = "b";
  @SerializedName(SERIALIZED_NAME_B)
  private String b;

  public MapResponseMapPropertyValue() {
  }

  public MapResponseMapPropertyValue a(String a) {

    this.a = a;
    return this;
  }

   /**
   * Get a
   * @return a
  **/
  @javax.annotation.Nonnull
  public String getA() {
    return a;
  }


  public void setA(String a) {
    this.a = a;
  }

  public MapResponseMapPropertyValue b(String b) {

    this.b = b;
    return this;
  }

   /**
   * Get b
   * @return b
  **/
  @javax.annotation.Nullable
  public String getB() {
    return b;
  }


  public void setB(String b) {
    this.b = b;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MapResponseMapPropertyValue mapResponseMapPropertyValue = (MapResponseMapPropertyValue) o;
    return Objects.equals(this.a, mapResponseMapPropertyValue.a) &&
        Objects.equals(this.b, mapResponseMapPropertyValue.b);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(a, b);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MapResponseMapPropertyValue {\\n");
    sb.append("    a: ").append(toIndentedString(a)).append("\\n");
    sb.append("    b: ").append(toIndentedString(b)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("a");
    openapiFields.add("b");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("a");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MapResponseMapPropertyValue
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MapResponseMapPropertyValue.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MapResponseMapPropertyValue is not found in the empty JSON string", MapResponseMapPropertyValue.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MapResponseMapPropertyValue.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`MapResponseMapPropertyValue\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MapResponseMapPropertyValue.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("a").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`a\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("a").toString()));
      }
      if ((jsonObj.get("b") != null && !jsonObj.get("b").isJsonNull()) && !jsonObj.get("b").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`b\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("b").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MapResponseMapPropertyValue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MapResponseMapPropertyValue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MapResponseMapPropertyValue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MapResponseMapPropertyValue.class));

       return (TypeAdapter<T>) new TypeAdapter<MapResponseMapPropertyValue>() {
           @Override
           public void write(JsonWriter out, MapResponseMapPropertyValue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MapResponseMapPropertyValue read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MapResponseMapPropertyValue given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MapResponseMapPropertyValue
  * @throws IOException if the JSON string is invalid with respect to MapResponseMapPropertyValue
  */
  public static MapResponseMapPropertyValue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MapResponseMapPropertyValue.class);
  }

 /**
  * Convert an instance of MapResponseMapPropertyValue to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/TestRequest.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * This is a test request
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class TestRequest {
  public static final String SERIALIZED_NAME_MY_INPUT = "myInput";
  @SerializedName(SERIALIZED_NAME_MY_INPUT)
  private BigDecimal myInput;

  public TestRequest() {
  }

  public TestRequest myInput(BigDecimal myInput) {

    this.myInput = myInput;
    return this;
  }

   /**
   * Get myInput
   * @return myInput
  **/
  @javax.annotation.Nullable
  public BigDecimal getMyInput() {
    return myInput;
  }


  public void setMyInput(BigDecimal myInput) {
    this.myInput = myInput;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestRequest testRequest = (TestRequest) o;
    return Objects.equals(this.myInput, testRequest.myInput);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(myInput);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestRequest {\\n");
    sb.append("    myInput: ").append(toIndentedString(myInput)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("myInput");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestRequest is not found in the empty JSON string", TestRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestRequest\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<TestRequest>() {
           @Override
           public void write(JsonWriter out, TestRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestRequest
  * @throws IOException if the JSON string is invalid with respect to TestRequest
  */
  public static TestRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestRequest.class);
  }

 /**
  * Convert an instance of TestRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/TestResponse.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import test.test.runtime.model.TestResponseMessagesInner;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * This is a test response
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class TestResponse {
  public static final String SERIALIZED_NAME_MESSAGES = "messages";
  @SerializedName(SERIALIZED_NAME_MESSAGES)
  private List<TestResponseMessagesInner> messages = new ArrayList<>();

  public TestResponse() {
  }

  public TestResponse messages(List<TestResponseMessagesInner> messages) {

    this.messages = messages;
    return this;
  }

  public TestResponse addMessagesItem(TestResponseMessagesInner messagesItem) {
    this.messages.add(messagesItem);
    return this;
  }

   /**
   * Get messages
   * @return messages
  **/
  @javax.annotation.Nonnull
  public List<TestResponseMessagesInner> getMessages() {
    return messages;
  }


  public void setMessages(List<TestResponseMessagesInner> messages) {
    this.messages = messages;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResponse testResponse = (TestResponse) o;
    return Objects.equals(this.messages, testResponse.messages);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(messages);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResponse {\\n");
    sb.append("    messages: ").append(toIndentedString(messages)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("messages");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("messages");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResponse is not found in the empty JSON string", TestResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestResponse\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TestResponse.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("messages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field \`messages\` to be an array in the JSON string but got \`%s\`", jsonObj.get("messages").toString()));
      }

      JsonArray jsonArraymessages = jsonObj.getAsJsonArray("messages");
      // validate the required field \`messages\` (array)
      for (int i = 0; i < jsonArraymessages.size(); i++) {
        TestResponseMessagesInner.validateJsonObject(jsonArraymessages.get(i).getAsJsonObject());
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResponse>() {
           @Override
           public void write(JsonWriter out, TestResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestResponse
  * @throws IOException if the JSON string is invalid with respect to TestResponse
  */
  public static TestResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResponse.class);
  }

 /**
  * Convert an instance of TestResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
  "src/main/java/test/test/runtime/model/TestResponseMessagesInner.java": "/*
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */


package test.test.runtime.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.io.File;
import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import test.test.runtime.JSON;

/**
 * TestResponseMessagesInner
 */
@lombok.AllArgsConstructor @lombok.experimental.SuperBuilder
public class TestResponseMessagesInner {
  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public TestResponseMessagesInner() {
  }

  public TestResponseMessagesInner message(String message) {

    this.message = message;
    return this;
  }

   /**
   * This is a message
   * @return message
  **/
  @javax.annotation.Nullable
  public String getMessage() {
    return message;
  }


  public void setMessage(String message) {
    this.message = message;
  }

  public TestResponseMessagesInner id(Integer id) {

    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull
  public Integer getId() {
    return id;
  }


  public void setId(Integer id) {
    this.id = id;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResponseMessagesInner testResponseMessagesInner = (TestResponseMessagesInner) o;
    return Objects.equals(this.message, testResponseMessagesInner.message) &&
        Objects.equals(this.id, testResponseMessagesInner.id);
        
  }

  @Override
  public int hashCode() {
    return Objects.hash(message, id);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResponseMessagesInner {\\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\\n", "\\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("message");
    openapiFields.add("id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to TestResponseMessagesInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!TestResponseMessagesInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResponseMessagesInner is not found in the empty JSON string", TestResponseMessagesInner.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!TestResponseMessagesInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field \`%s\` in the JSON string is not defined in the \`TestResponseMessagesInner\` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TestResponseMessagesInner.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field \`%s\` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) && !jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field \`message\` to be a primitive type in the JSON string but got \`%s\`", jsonObj.get("message").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResponseMessagesInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResponseMessagesInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResponseMessagesInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResponseMessagesInner.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResponseMessagesInner>() {
           @Override
           public void write(JsonWriter out, TestResponseMessagesInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResponseMessagesInner read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TestResponseMessagesInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TestResponseMessagesInner
  * @throws IOException if the JSON string is invalid with respect to TestResponseMessagesInner
  */
  public static TestResponseMessagesInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResponseMessagesInner.class);
  }

 /**
  * Convert an instance of TestResponseMessagesInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
",
}
`;
