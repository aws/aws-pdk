// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Typescript Async Runtime Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".tsapi-manifest": "src/index.ts
src/interceptors/try-catch.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts
src/server/operation-config.ts
src/server/server-sdk.ts
src/models/index.ts
src/models/model-utils.ts
src/models/ApiError.ts
src/models/MapRequest.ts
src/models/MapRequestMapPropertyValue.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts",
  "src/index.ts": "export * from './models';
export * from './server/operation-config';
export * from './server/server-sdk';
export * from './interceptors'
",
  "src/interceptors/index.ts": "import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, and error handling
 */
export const INTERCEPTORS = [
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async (
    request: PayloadlessChainedRequestInput,
  ): Promise<void> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = (request: PayloadlessChainedRequestInput | ChainedRequestInput<any>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async (
    request: PayloadlessChainedRequestInput,
  ): Promise<void> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = (
    request: PayloadlessChainedRequestInput | ChainedRequestInput<any>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const tracer = new Tracer();

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = () => async (
  request: PayloadlessChainedRequestInput,
): Promise<void> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    return await request.chain.next(request);
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = (
    request: PayloadlessChainedRequestInput | ChainedRequestInput<any>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  PayloadlessChainedRequestInput,
} from '..';

/**
 * Create an interceptor which catches any unhandled exceptions
 */
export const buildTryCatchInterceptor = () => async (
  request: PayloadlessChainedRequestInput,
): Promise<void> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }
  }
};

/**
 * Interceptor for catching unhandled exceptions
 */
export const tryCatchInterceptor = buildTryCatchInterceptor();
",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


/**
 * Check if a given object implements the ApiError interface.
 */
export function instanceOfApiError(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "errorMessage" in value;
    return isInstance;
}

export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/MapRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';
import type { MapRequestMapPropertyValue } from './MapRequestMapPropertyValue';
import {
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueFromJSONTyped,
    MapRequestMapPropertyValueToJSON,
    instanceOfMapRequestMapPropertyValue,
} from './MapRequestMapPropertyValue';

/**
 * 
 * @export
 * @interface MapRequest
 */
export interface MapRequest {
    /**
     * 
     * @type {{ [key: string]: MapRequestMapPropertyValue; }}
     * @memberof MapRequest
     */
    mapProperty: { [key: string]: MapRequestMapPropertyValue; };
}


/**
 * Check if a given object implements the MapRequest interface.
 */
export function instanceOfMapRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "mapProperty" in value;
    return isInstance;
}

export function MapRequestFromJSON(json: any): MapRequest {
    return MapRequestFromJSONTyped(json, false);
}

export function MapRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'mapProperty': (mapValues(json['mapProperty'], MapRequestMapPropertyValueFromJSON)),
    };
}

export function MapRequestToJSON(value?: MapRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'mapProperty': (mapValues(value.mapProperty, MapRequestMapPropertyValueToJSON)),
    };
}

",
  "src/models/MapRequestMapPropertyValue.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';

/**
 * 
 * @export
 * @interface MapRequestMapPropertyValue
 */
export interface MapRequestMapPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof MapRequestMapPropertyValue
     */
    a: string;
    /**
     * 
     * @type {string}
     * @memberof MapRequestMapPropertyValue
     */
    b?: string;
}


/**
 * Check if a given object implements the MapRequestMapPropertyValue interface.
 */
export function instanceOfMapRequestMapPropertyValue(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "a" in value;
    return isInstance;
}

export function MapRequestMapPropertyValueFromJSON(json: any): MapRequestMapPropertyValue {
    return MapRequestMapPropertyValueFromJSONTyped(json, false);
}

export function MapRequestMapPropertyValueFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapRequestMapPropertyValue {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'a': json['a'],
        'b': !exists(json, 'b') ? undefined : json['b'],
    };
}

export function MapRequestMapPropertyValueToJSON(value?: MapRequestMapPropertyValue | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'a': value.a,
        'b': value.b,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';

/**
 * This is a test request
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


/**
 * Check if a given object implements the TestRequest interface.
 */
export function instanceOfTestRequest(value: object): boolean {
    let isInstance = true;
    return isInstance;
}

export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';
import type { TestResponseMessagesInner } from './TestResponseMessagesInner';
import {
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
    instanceOfTestResponseMessagesInner,
} from './TestResponseMessagesInner';

/**
 * This is a test response
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


/**
 * Check if a given object implements the TestResponse interface.
 */
export function instanceOfTestResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;
    return isInstance;
}

export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
import { exists, mapValues } from './model-utils';

/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * This is a message
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


/**
 * Check if a given object implements the TestResponseMessagesInner interface.
 */
export function instanceOfTestResponseMessagesInner(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}

export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {

        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {

        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './MapRequest';
export * from './MapRequestMapPropertyValue';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/models/model-utils.ts": "/* tslint:disable */
/* eslint-disable */

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function exists(json: any, key: string) {
  const value = json[key];
  return value !== null && value !== undefined;
}
",
  "src/server/operation-config.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapRequest,
    MapRequestFromJSON,
    MapRequestToJSON,
    MapRequestMapPropertyValue,
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from '../models';

// API Gateway Types
import { APIGatewayProxyWebsocketEventV2, APIGatewayProxyResultV2, Context } from "aws-lambda";
import { DefaultApiServerSdk } from "./server-sdk";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    anyRequest: T;
    bidirectional: T;
    clientToServer: T;
    empty: T;
    mapRequest: T;
    mediaTypes: T;
    multipleContentTypes: T;
    withoutOperationIdPost: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    anyRequest: {
        path: '/any-request',
        method: 'PUT',
        contentTypes: ['application/json'],
    },
    bidirectional: {
        path: '/bidirectional',
        method: 'POST',
        contentTypes: ['application/json'],
    },
    clientToServer: {
        path: '/client-to-server',
        method: 'POST',
        contentTypes: ['application/json'],
    },
    empty: {
        path: '/empty-request',
        method: 'PUT',
        contentTypes: ['application/json'],
    },
    mapRequest: {
        path: '/map-request',
        method: 'POST',
        contentTypes: ['application/json'],
    },
    mediaTypes: {
        path: '/different-media-type',
        method: 'POST',
        contentTypes: ['application/pdf'],
    },
    multipleContentTypes: {
        path: '/multiple-content-types',
        method: 'POST',
        contentTypes: ['application/json','application/pdf'],
    },
    withoutOperationIdPost: {
        path: '/without-operation-id',
        method: 'POST',
        contentTypes: ['application/json'],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

/**
 * Parse the body if the content type is json and return the payload, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

/**
 * Utilities for the $connect route to allow or deny a pending connection
 */
export class $PendingConnection {
  public static DENY_CONTEXT_KEY = '$PendingConnectionDenied';

  public static of = (request: PayloadlessChainedRequestInput) => {
    return new $PendingConnection(request.interceptorContext);
  };

  private constructor(private interceptorContext: Record<string, any>) {}

  /**
   * Allows the connection (not immediate, takes effect when the lambda handler returns)
   */
  public allow = () => {
    this.interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] = false;
  };

  /**
   * Denies the connection (not immediate, takes effect when the lambda handler returns)
   */
  public deny = () => {
    this.interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] = true;
  };
}

export type OperationIds = "$connect" | "$disconnect" | 'anyRequest' | 'bidirectional' | 'clientToServer' | 'empty' | 'mapRequest' | 'mediaTypes' | 'multipleContentTypes' | 'withoutOperationIdPost';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResultV2 & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyWebsocketEventV2, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

export type InterceptorContext = { [key: string]: any };

export interface PayloadlessRequestInput {
    connectionId: string;
    sdk: DefaultApiServerSdk;
    event: APIGatewayProxyWebsocketEventV2;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface RequestInput<RequestBody> extends PayloadlessRequestInput {
    input: RequestBody;
}

export interface PayloadlessChainedRequestInput extends PayloadlessRequestInput {
    chain: PayloadlessLambdaHandlerChain;
}

export interface ChainedRequestInput<RequestBody> extends RequestInput<RequestBody> {
    chain: LambdaHandlerChain<RequestBody>;
}

export type PayloadlessChainedLambdaHandlerFunction = (
  input: PayloadlessChainedRequestInput
) => Promise<void>;

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestBody> = (
  input: ChainedRequestInput<RequestBody>,
) => Promise<void>;

export type PayloadlessLambdaHandlerFunction = (
  input: PayloadlessRequestInput
) => Promise<void>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestBody> = (
  input: RequestInput<RequestBody>,
) => Promise<void>;

export interface PayloadlessLambdaHandlerChain {
  next: PayloadlessLambdaHandlerFunction;
}

export interface LambdaHandlerChain<RequestBody> {
  next: LambdaHandlerFunction<RequestBody>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestBody> = ChainedLambdaHandlerFunction<RequestBody>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestBody>(
  ...handlers: ChainedLambdaHandlerFunction<RequestBody>[]
): LambdaHandlerChain<RequestBody> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};


/**
 * Request body parameter for AnyRequest
 */
export type AnyRequestRequestBody = string;

// Type that the handler function provided to the wrapper must conform to
export type AnyRequestHandlerFunction = LambdaHandlerFunction<AnyRequestRequestBody>;
export type AnyRequestChainedHandlerFunction = ChainedLambdaHandlerFunction<AnyRequestRequestBody>;
export type AnyRequestChainedRequestInput = ChainedRequestInput<AnyRequestRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of anyRequest
 */
export const anyRequestHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | AnyRequestChainedHandlerFunction)[], AnyRequestChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'anyRequest'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | AnyRequestChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "anyRequest";

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as AnyRequestRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for Bidirectional
 */
export type BidirectionalRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type BidirectionalHandlerFunction = LambdaHandlerFunction<BidirectionalRequestBody>;
export type BidirectionalChainedHandlerFunction = ChainedLambdaHandlerFunction<BidirectionalRequestBody>;
export type BidirectionalChainedRequestInput = ChainedRequestInput<BidirectionalRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of bidirectional
 */
export const bidirectionalHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | BidirectionalChainedHandlerFunction)[], BidirectionalChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'bidirectional'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | BidirectionalChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "bidirectional";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as BidirectionalRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for ClientToServer
 */
export type ClientToServerRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type ClientToServerHandlerFunction = LambdaHandlerFunction<ClientToServerRequestBody>;
export type ClientToServerChainedHandlerFunction = ChainedLambdaHandlerFunction<ClientToServerRequestBody>;
export type ClientToServerChainedRequestInput = ChainedRequestInput<ClientToServerRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of clientToServer
 */
export const clientToServerHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ClientToServerChainedHandlerFunction)[], ClientToServerChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'clientToServer'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | ClientToServerChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "clientToServer";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as ClientToServerRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for Empty
 */
export type EmptyRequestBody = never;

// Type that the handler function provided to the wrapper must conform to
export type EmptyHandlerFunction = LambdaHandlerFunction<EmptyRequestBody>;
export type EmptyChainedHandlerFunction = ChainedLambdaHandlerFunction<EmptyRequestBody>;
export type EmptyChainedRequestInput = ChainedRequestInput<EmptyRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of empty
 */
export const emptyHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | EmptyChainedHandlerFunction)[], EmptyChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'empty'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | EmptyChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "empty";

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as EmptyRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MapRequest
 */
export type MapRequestRequestBody = MapRequest;

// Type that the handler function provided to the wrapper must conform to
export type MapRequestHandlerFunction = LambdaHandlerFunction<MapRequestRequestBody>;
export type MapRequestChainedHandlerFunction = ChainedLambdaHandlerFunction<MapRequestRequestBody>;
export type MapRequestChainedRequestInput = ChainedRequestInput<MapRequestRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mapRequest
 */
export const mapRequestHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MapRequestChainedHandlerFunction)[], MapRequestChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'mapRequest'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MapRequestChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "mapRequest";

    const demarshal = (bodyString: string): any => {
        return MapRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as MapRequestRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MediaTypes
 */
export type MediaTypesRequestBody = string;

// Type that the handler function provided to the wrapper must conform to
export type MediaTypesHandlerFunction = LambdaHandlerFunction<MediaTypesRequestBody>;
export type MediaTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MediaTypesRequestBody>;
export type MediaTypesChainedRequestInput = ChainedRequestInput<MediaTypesRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mediaTypes
 */
export const mediaTypesHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MediaTypesChainedHandlerFunction)[], MediaTypesChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'mediaTypes'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MediaTypesChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "mediaTypes";

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/pdf']) as MediaTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MultipleContentTypes
 */
export type MultipleContentTypesRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type MultipleContentTypesHandlerFunction = LambdaHandlerFunction<MultipleContentTypesRequestBody>;
export type MultipleContentTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MultipleContentTypesRequestBody>;
export type MultipleContentTypesChainedRequestInput = ChainedRequestInput<MultipleContentTypesRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of multipleContentTypes
 */
export const multipleContentTypesHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MultipleContentTypesChainedHandlerFunction)[], MultipleContentTypesChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'multipleContentTypes'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MultipleContentTypesChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "multipleContentTypes";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json','application/pdf']) as MultipleContentTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for WithoutOperationIdPost
 */
export type WithoutOperationIdPostRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type WithoutOperationIdPostHandlerFunction = LambdaHandlerFunction<WithoutOperationIdPostRequestBody>;
export type WithoutOperationIdPostChainedHandlerFunction = ChainedLambdaHandlerFunction<WithoutOperationIdPostRequestBody>;
export type WithoutOperationIdPostChainedRequestInput = ChainedRequestInput<WithoutOperationIdPostRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of withoutOperationIdPost
 */
export const withoutOperationIdPostHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | WithoutOperationIdPostChainedHandlerFunction)[], WithoutOperationIdPostChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'withoutOperationIdPost'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | WithoutOperationIdPostChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "withoutOperationIdPost";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as WithoutOperationIdPostRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

export type $ConnectChainedLambdaHandlerFunction = PayloadlessChainedLambdaHandlerFunction;

export const $connectHandler = (
  ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<any>)[], $ConnectChainedLambdaHandlerFunction]
): OperationApiGatewayLambdaHandler<'$connect'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: PayloadlessChainedLambdaHandlerFunction[] = []): Promise<APIGatewayProxyResultV2> => {
  const operationId = "$connect";
  const chain = buildHandlerChain(...additionalInterceptors, ...(handlers as any)) as PayloadlessLambdaHandlerChain;
  const interceptorContext = { operationId };
  await chain.next({
      connectionId: event.requestContext.connectionId,
      sdk: new DefaultApiServerSdk({
        callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
      }),
      event,
      context,
      interceptorContext,
  });

  return {
      // Respond with 200, unless the handler explicitly denies the connection
      statusCode: interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] ? 403 : 200,
  };
};

export type $DisconnectChainedLambdaHandlerFunction = PayloadlessChainedLambdaHandlerFunction;

export const $disconnectHandler = (
  ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<any>)[], $DisconnectChainedLambdaHandlerFunction]
): OperationApiGatewayLambdaHandler<'$disconnect'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: PayloadlessChainedLambdaHandlerFunction[] = []): Promise<APIGatewayProxyResultV2> => {
  const operationId = "$disconnect";
  const chain = buildHandlerChain(...additionalInterceptors, ...handlers) as PayloadlessLambdaHandlerChain;
  await chain.next({
      connectionId: event.requestContext.connectionId,
      sdk: new DefaultApiServerSdk({
        callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
      }),
      event,
      context,
      interceptorContext: { operationId },
  });

  return {
      // Respond success to indicate to API gateway that we have implemented the integration
      // Websocket operations are one-way.
      statusCode: 200,
  };
};

export interface HandlerRouterHandlers {
  readonly anyRequest: OperationApiGatewayLambdaHandler<'anyRequest'>;
  readonly bidirectional: OperationApiGatewayLambdaHandler<'bidirectional'>;
  readonly clientToServer: OperationApiGatewayLambdaHandler<'clientToServer'>;
  readonly empty: OperationApiGatewayLambdaHandler<'empty'>;
  readonly mapRequest: OperationApiGatewayLambdaHandler<'mapRequest'>;
  readonly mediaTypes: OperationApiGatewayLambdaHandler<'mediaTypes'>;
  readonly multipleContentTypes: OperationApiGatewayLambdaHandler<'multipleContentTypes'>;
  readonly withoutOperationIdPost: OperationApiGatewayLambdaHandler<'withoutOperationIdPost'>;
  readonly $connect?: OperationApiGatewayLambdaHandler<'$connect'>;
  readonly $disconnect?: OperationApiGatewayLambdaHandler<'$disconnect'>;
}

export type AnyOperationRequestBodies = | AnyRequestRequestBody| BidirectionalRequestBody| ClientToServerRequestBody| EmptyRequestBody| MapRequestRequestBody| MediaTypesRequestBody| MultipleContentTypesRequestBody| WithoutOperationIdPostRequestBody;

export interface HandlerRouterProps<
  RequestBody,
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ReadonlyArray<(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<RequestBody>)>;

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const OperationIdByPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, details]: [string, {path: string}]) => [details.path.replace(/\\//g, ''), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestBodies
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const handler = props.handlers[OperationIdByPath[event.requestContext.routeKey]];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/server/server-sdk.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapRequest,
    MapRequestFromJSON,
    MapRequestToJSON,
    MapRequestMapPropertyValue,
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from "../models";
import {
  ApiGatewayManagementApiClient,
  PostToConnectionCommand,
  DeleteConnectionCommand,
} from "@aws-sdk/client-apigatewaymanagementapi";

/**
 * Options for the server SDK
 */
export interface DefaultApiServerSdkProps {
  /**
   * API Gateway management API callback url
   */
  readonly callbackUrl: string;
}

/**
 * SDK for sending messages from the server to connected clients
 */
export class DefaultApiServerSdk {
  private readonly client: ApiGatewayManagementApiClient;

  constructor(props: DefaultApiServerSdkProps) {
    this.client = new ApiGatewayManagementApiClient({ endpoint: props.callbackUrl });
  }

  public async anyRequest(connectionId: string, input: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "AnyRequest",
        payload: input,
      }),
    }));
  }
  public async bidirectional(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "Bidirectional",
        payload: input,
      }),
    }));
  }
  public async empty(connectionId: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "Empty",
        payload: input,
      }),
    }));
  }
  public async mapRequest(connectionId: string, input: MapRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MapRequest",
        payload: input,
      }),
    }));
  }
  public async mediaTypes(connectionId: string, input: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MediaTypes",
        payload: input,
      }),
    }));
  }
  public async multipleContentTypes(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MultipleContentTypes",
        payload: input,
      }),
    }));
  }
  public async serverToClient(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "ServerToClient",
        payload: input,
      }),
    }));
  }
  public async withoutOperationIdPost(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "WithoutOperationIdPost",
        payload: input,
      }),
    }));
  }

  /**
   * Disconnect a connected client
   */
  public async $disconnect(connectionId: string): Promise<void> {
    await this.client.send(new DeleteConnectionCommand({
      ConnectionId: connectionId,
    }));
  }
}
",
}
`;
