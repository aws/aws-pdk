// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Typescript Async Runtime Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".gitignore
.npmignore
.openapi-generator-ignore
README.md
package.json
src/__interceptors.ts
src/apis/DefaultApi.ts
src/apis/index.ts
src/index.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/MapRequest.ts
src/models/MapRequest.ts
src/models/MapRequest.ts
src/models/MapRequestMapPropertyValue.ts
src/models/MapRequestMapPropertyValue.ts
src/models/MapRequestMapPropertyValue.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/index.ts
src/runtime.ts
src/server/operation-config.ts
src/server/server-sdk.ts
tsconfig.esm.json
tsconfig.json
src/interceptors/try-catch.ts
src/interceptors/powertools/logger.ts
src/interceptors/powertools/tracer.ts
src/interceptors/powertools/metrics.ts
src/interceptors/index.ts",
  ".openapi-generator/VERSION": "6.3.0",
  ".pdk/dynamic-files/openapitools.json": {
    "$schema": "node_modules/@openapitools/openapi-generator-cli/config.schema.json",
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run "npx projen".",
    "generator-cli": {
      "storageDir": "~/.open-api-generator-cli",
      "version": "6.3.0",
    },
    "spaces": 2,
  },
  "README.md": "## test@1.0.0

This generator creates TypeScript/JavaScript client that utilizes [Fetch API](https://fetch.spec.whatwg.org/). The generated Node module can be used in the following environments:

Environment
* Node.js
* Webpack
* Browserify

Language level
* ES5 - you must have a Promises/A+ library installed
* ES6

Module system
* CommonJS
* ES6 module system

It can be used in both TypeScript and JavaScript. In TypeScript, the definition should be automatically resolved via \`package.json\`. ([Reference](http://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html))

### Building

To build and compile the typescript sources to javascript use:
\`\`\`
npm install
npm run build
\`\`\`

### Publishing

First build the package then run \`\`\`npm publish\`\`\`

### Consuming

navigate to the folder of your consuming project and run one of the following commands.

_published:_

\`\`\`
npm install test@1.0.0 --save
\`\`\`

_unPublished (not recommended):_

\`\`\`
npm install PATH_TO_GENERATED_PACKAGE --save
",
  "openapitools.json": {
    "$schema": "node_modules/@openapitools/openapi-generator-cli/config.schema.json",
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run "npx projen".",
    "generator-cli": {
      "storageDir": "~/.open-api-generator-cli",
      "version": "6.3.0",
    },
    "spaces": 2,
  },
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './models';
export * from './server/operation-config';
export * from './server/server-sdk';
export * from './interceptors'
",
  "src/interceptors/index.ts": "import { LoggingInterceptor } from './powertools/logger';
import { MetricsInterceptor } from './powertools/metrics';
import { TracingInterceptor } from './powertools/tracer';
import { tryCatchInterceptor } from './try-catch';

export * from './try-catch';
export * from './powertools/tracer';
export * from './powertools/metrics';
export * from './powertools/logger';

/**
 * All default interceptors, for logging, tracing, metrics, and error handling
 */
export const INTERCEPTORS = [
  LoggingInterceptor.intercept,
  tryCatchInterceptor,
  TracingInterceptor.intercept,
  MetricsInterceptor.intercept,
] as const;
",
  "src/interceptors/powertools/logger.ts": "import { Logger } from '@aws-lambda-powertools/logger';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const logger = new Logger();

export class LoggingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools logger to the interceptor context,
   * and adds the lambda context
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/
   */
  public static intercept = async (
    request: PayloadlessChainedRequestInput,
  ): Promise<void> => {
    logger.addContext(request.context);
    logger.appendKeys({ operationId: request.interceptorContext.operationId });
    request.interceptorContext.logger = logger;
    const response = await request.chain.next(request);
    logger.removeKeys(['operationId']);
    return response;
  };

  /**
   * Retrieve the logger from the interceptor context
   */
  public static getLogger = (request: PayloadlessChainedRequestInput | ChainedRequestInput<any>): Logger => {
    if (!request.interceptorContext.logger) {
      throw new Error('No logger found, did you configure the LoggingInterceptor?');
    }
    return request.interceptorContext.logger;
  };
}
",
  "src/interceptors/powertools/metrics.ts": "import { Metrics } from '@aws-lambda-powertools/metrics';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const metrics = new Metrics();

export class MetricsInterceptor {
  /**
   * Interceptor which adds an instance of aws lambda powertools metrics to the interceptor context,
   * and ensures metrics are flushed prior to finishing the lambda execution
   * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/
   */
  public static intercept = async (
    request: PayloadlessChainedRequestInput,
  ): Promise<void> => {
    metrics.addDimension("operationId", request.interceptorContext.operationId);
    request.interceptorContext.metrics = metrics;
    try {
      return await request.chain.next(request);
    } finally {
      // Flush metrics
      metrics.publishStoredMetrics();
    }
  };

  /**
   * Retrieve the metrics logger from the request
   */
  public static getMetrics = (
    request: PayloadlessChainedRequestInput | ChainedRequestInput<any>,
  ): Metrics => {
    if (!request.interceptorContext.metrics) {
      throw new Error('No metrics logger found, did you configure the MetricsInterceptor?');
    }
    return request.interceptorContext.metrics;
  };
}
",
  "src/interceptors/powertools/tracer.ts": "import { Tracer } from '@aws-lambda-powertools/tracer';
import { PayloadlessChainedRequestInput, ChainedRequestInput } from '../..';

const tracer = new Tracer();

/**
 * Create an interceptor which adds an aws lambda powertools tracer to the interceptor context,
 * creating the appropriate segment for the handler execution and annotating with recommended
 * details.
 * @see https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/#lambda-handler
 */
export const buildTracingInterceptor = () => async (
  request: PayloadlessChainedRequestInput,
): Promise<void> => {
  const handler = request.interceptorContext.operationId ?? process.env._HANDLER ?? 'index.handler';
  const segment = tracer.getSegment();
  let subsegment;
  if (segment) {
    subsegment = segment.addNewSubsegment(handler);
    tracer.setSegment(subsegment);
  }

  tracer.annotateColdStart();
  tracer.addServiceNameAnnotation();

  if (request.interceptorContext.logger) {
    tracer.provider.setLogger(request.interceptorContext.logger);
  }

  request.interceptorContext.tracer = tracer;

  try {
    return await request.chain.next(request);
  } catch (e) {
    tracer.addErrorAsMetadata(e as Error);
    throw e;
  } finally {
    if (segment && subsegment) {
      subsegment.close();
      tracer.setSegment(segment);
    }
  }
};

export class TracingInterceptor {
  /**
   * Interceptor which adds an aws lambda powertools tracer to the interceptor context,
   * creating the appropriate segment for the handler execution and annotating with recommended
   * details.
   */
  public static intercept = buildTracingInterceptor();

  /**
   * Get the tracer from the interceptor context
   */
  public static getTracer = (
    request: PayloadlessChainedRequestInput | ChainedRequestInput<any>,
  ): Tracer => {
    if (!request.interceptorContext.tracer) {
      throw new Error('No tracer found, did you configure the TracingInterceptor?');
    }
    return request.interceptorContext.tracer;
  };
}
",
  "src/interceptors/try-catch.ts": "import {
  PayloadlessChainedRequestInput,
} from '..';

/**
 * Create an interceptor which catches any unhandled exceptions
 */
export const buildTryCatchInterceptor = () => async (
  request: PayloadlessChainedRequestInput,
): Promise<void> => {
  try {
    return await request.chain.next(request);
  } catch (e: any) {
    // Log the error if the logger is present
    if (request.interceptorContext.logger && request.interceptorContext.logger.error) {
      request.interceptorContext.logger.error('Interceptor caught exception', e as Error);
    } else {
      console.error('Interceptor caught exception', e);
    }
  }
};

/**
 * Interceptor for catching unhandled exceptions
 */
export const tryCatchInterceptor = buildTryCatchInterceptor();
",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


/**
 * Check if a given object implements the ApiError interface.
 */
export function instanceOfApiError(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "errorMessage" in value;

    return isInstance;
}

export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/MapRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { MapRequestMapPropertyValue } from './MapRequestMapPropertyValue';
import {
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueFromJSONTyped,
    MapRequestMapPropertyValueToJSON,
} from './MapRequestMapPropertyValue';

/**
 * 
 * @export
 * @interface MapRequest
 */
export interface MapRequest {
    /**
     * 
     * @type {{ [key: string]: MapRequestMapPropertyValue; }}
     * @memberof MapRequest
     */
    mapProperty: { [key: string]: MapRequestMapPropertyValue; };
}


/**
 * Check if a given object implements the MapRequest interface.
 */
export function instanceOfMapRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "mapProperty" in value;

    return isInstance;
}

export function MapRequestFromJSON(json: any): MapRequest {
    return MapRequestFromJSONTyped(json, false);
}

export function MapRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'mapProperty': (mapValues(json['mapProperty'], MapRequestMapPropertyValueFromJSON)),
    };
}

export function MapRequestToJSON(value?: MapRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'mapProperty': (mapValues(value.mapProperty, MapRequestMapPropertyValueToJSON)),
    };
}

",
  "src/models/MapRequestMapPropertyValue.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface MapRequestMapPropertyValue
 */
export interface MapRequestMapPropertyValue {
    /**
     * 
     * @type {string}
     * @memberof MapRequestMapPropertyValue
     */
    a: string;
    /**
     * 
     * @type {string}
     * @memberof MapRequestMapPropertyValue
     */
    b?: string;
}


/**
 * Check if a given object implements the MapRequestMapPropertyValue interface.
 */
export function instanceOfMapRequestMapPropertyValue(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "a" in value;

    return isInstance;
}

export function MapRequestMapPropertyValueFromJSON(json: any): MapRequestMapPropertyValue {
    return MapRequestMapPropertyValueFromJSONTyped(json, false);
}

export function MapRequestMapPropertyValueFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapRequestMapPropertyValue {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'a': json['a'],
        'b': !exists(json, 'b') ? undefined : json['b'],
    };
}

export function MapRequestMapPropertyValueToJSON(value?: MapRequestMapPropertyValue | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'a': value.a,
        'b': value.b,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * This is a test request
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


/**
 * Check if a given object implements the TestRequest interface.
 */
export function instanceOfTestRequest(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { TestResponseMessagesInner } from './TestResponseMessagesInner';
import {
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
} from './TestResponseMessagesInner';

/**
 * This is a test response
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


/**
 * Check if a given object implements the TestResponse interface.
 */
export function instanceOfTestResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;

    return isInstance;
}

export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * This is a message
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


/**
 * Check if a given object implements the TestResponseMessagesInner interface.
 */
export function instanceOfTestResponseMessagesInner(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;

    return isInstance;
}

export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './MapRequest';
export * from './MapRequestMapPropertyValue';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export const BASE_PATH = "http://localhost".replace(/\\/+$/, "");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        const init: RequestInit = {
            ...overriddenInit,
            body:
                isFormData(overriddenInit.body) ||
                overriddenInit.body instanceof URLSearchParams ||
                isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
  "src/server/operation-config.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapRequest,
    MapRequestFromJSON,
    MapRequestToJSON,
    MapRequestMapPropertyValue,
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from '../models';

// API Gateway Types
import { APIGatewayProxyWebsocketEventV2, APIGatewayProxyResultV2, Context } from "aws-lambda";
import { DefaultApiServerSdk } from "./server-sdk";

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    anyRequest: T;
    bidirectional: T;
    clientToServer: T;
    empty: T;
    mapRequest: T;
    mediaTypes: T;
    multipleContentTypes: T;
    withoutOperationIdPost: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    anyRequest: {
        path: '/any-request',
        method: 'PUT',
        contentTypes: ['application/json',],
    },
    bidirectional: {
        path: '/bidirectional',
        method: 'POST',
        contentTypes: ['application/json',],
    },
    clientToServer: {
        path: '/client-to-server',
        method: 'POST',
        contentTypes: ['application/json',],
    },
    empty: {
        path: '/empty-request',
        method: 'PUT',
        contentTypes: ['application/json'],
    },
    mapRequest: {
        path: '/map-request',
        method: 'POST',
        contentTypes: ['application/json',],
    },
    mediaTypes: {
        path: '/different-media-type',
        method: 'POST',
        contentTypes: ['application/pdf',],
    },
    multipleContentTypes: {
        path: '/multiple-content-types',
        method: 'POST',
        contentTypes: ['application/json','application/pdf',],
    },
    withoutOperationIdPost: {
        path: '/without-operation-id',
        method: 'POST',
        contentTypes: ['application/json',],
    },
};

export class Operations {
  /**
   * Return an OperationConfig with the same value for every operation
   */
  public static all = <T>(value: T): OperationConfig<T> => Object.fromEntries(
    Object.keys(OperationLookup).map((operationId) => [operationId, value])
  ) as unknown as OperationConfig<T>;
}

/**
 * Parse the body if the content type is json and return the payload, otherwise leave as a raw string
 */
const parseBody = (body: string, demarshal: (body: string) => any, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? demarshal(body || '{}') : body;

/**
 * Utilities for the $connect route to allow or deny a pending connection
 */
export class $PendingConnection {
  public static DENY_CONTEXT_KEY = '$PendingConnectionDenied';

  public static of = (request: PayloadlessChainedRequestInput) => {
    return new $PendingConnection(request.interceptorContext);
  };

  private constructor(private interceptorContext: Record<string, any>) {}

  /**
   * Allows the connection (not immediate, takes effect when the lambda handler returns)
   */
  public allow = () => {
    this.interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] = false;
  };

  /**
   * Denies the connection (not immediate, takes effect when the lambda handler returns)
   */
  public deny = () => {
    this.interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] = true;
  };
}

export type OperationIds = "$connect" | "$disconnect" | 'anyRequest' | 'bidirectional' | 'clientToServer' | 'empty' | 'mapRequest' | 'mediaTypes' | 'multipleContentTypes' | 'withoutOperationIdPost';
export type OperationApiGatewayProxyResult<T extends OperationIds> = APIGatewayProxyResultV2 & { __operationId?: T };

// Api gateway lambda handler type
export type OperationApiGatewayLambdaHandler<T extends OperationIds> = (event: APIGatewayProxyWebsocketEventV2, context: Context) => Promise<OperationApiGatewayProxyResult<T>>;

export type InterceptorContext = { [key: string]: any };

export interface PayloadlessRequestInput {
    connectionId: string;
    sdk: DefaultApiServerSdk;
    event: APIGatewayProxyWebsocketEventV2;
    context: Context;
    interceptorContext: InterceptorContext;
}

export interface RequestInput<RequestBody> extends PayloadlessRequestInput {
    input: RequestBody;
}

export interface PayloadlessChainedRequestInput extends PayloadlessRequestInput {
    chain: PayloadlessLambdaHandlerChain;
}

export interface ChainedRequestInput<RequestBody> extends RequestInput<RequestBody> {
    chain: LambdaHandlerChain<RequestBody>;
}

export type PayloadlessChainedLambdaHandlerFunction = (
  input: PayloadlessChainedRequestInput
) => Promise<void>;

/**
 * A lambda handler function which is part of a chain. It may invoke the remainder of the chain via the given chain input
 */
export type ChainedLambdaHandlerFunction<RequestBody> = (
  input: ChainedRequestInput<RequestBody>,
) => Promise<void>;

export type PayloadlessLambdaHandlerFunction = (
  input: PayloadlessRequestInput
) => Promise<void>;

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestBody> = (
  input: RequestInput<RequestBody>,
) => Promise<void>;

export interface PayloadlessLambdaHandlerChain {
  next: PayloadlessLambdaHandlerFunction;
}

export interface LambdaHandlerChain<RequestBody> {
  next: LambdaHandlerFunction<RequestBody>;
}

// Interceptor is a type alias for ChainedLambdaHandlerFunction
export type Interceptor<RequestBody> = ChainedLambdaHandlerFunction<RequestBody>;

/**
 * Build a chain from the given array of chained lambda handlers
 */
const buildHandlerChain = <RequestBody>(
  ...handlers: ChainedLambdaHandlerFunction<RequestBody>[]
): LambdaHandlerChain<RequestBody> => {
  if (handlers.length === 0) {
    return {
      next: () => {
        throw new Error("No more handlers remain in the chain! The last handler should not call next.");
      }
    };
  }
  const [currentHandler, ...remainingHandlers] = handlers;
  return {
    next: (input) => {
      return currentHandler({
        ...input,
        chain: buildHandlerChain(...remainingHandlers),
      });
    },
  };
};


/**
 * Request body parameter for AnyRequest
 */
export type AnyRequestRequestBody = string;

// Type that the handler function provided to the wrapper must conform to
export type AnyRequestHandlerFunction = LambdaHandlerFunction<AnyRequestRequestBody>;
export type AnyRequestChainedHandlerFunction = ChainedLambdaHandlerFunction<AnyRequestRequestBody>;
export type AnyRequestChainedRequestInput = ChainedRequestInput<AnyRequestRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of anyRequest
 */
export const anyRequestHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | AnyRequestChainedHandlerFunction)[], AnyRequestChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'anyRequest'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | AnyRequestChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "anyRequest";

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as AnyRequestRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for Bidirectional
 */
export type BidirectionalRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type BidirectionalHandlerFunction = LambdaHandlerFunction<BidirectionalRequestBody>;
export type BidirectionalChainedHandlerFunction = ChainedLambdaHandlerFunction<BidirectionalRequestBody>;
export type BidirectionalChainedRequestInput = ChainedRequestInput<BidirectionalRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of bidirectional
 */
export const bidirectionalHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | BidirectionalChainedHandlerFunction)[], BidirectionalChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'bidirectional'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | BidirectionalChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "bidirectional";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as BidirectionalRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for ClientToServer
 */
export type ClientToServerRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type ClientToServerHandlerFunction = LambdaHandlerFunction<ClientToServerRequestBody>;
export type ClientToServerChainedHandlerFunction = ChainedLambdaHandlerFunction<ClientToServerRequestBody>;
export type ClientToServerChainedRequestInput = ChainedRequestInput<ClientToServerRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of clientToServer
 */
export const clientToServerHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ClientToServerChainedHandlerFunction)[], ClientToServerChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'clientToServer'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | ClientToServerChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "clientToServer";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as ClientToServerRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for Empty
 */
export type EmptyRequestBody = never;

// Type that the handler function provided to the wrapper must conform to
export type EmptyHandlerFunction = LambdaHandlerFunction<EmptyRequestBody>;
export type EmptyChainedHandlerFunction = ChainedLambdaHandlerFunction<EmptyRequestBody>;
export type EmptyChainedRequestInput = ChainedRequestInput<EmptyRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of empty
 */
export const emptyHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | EmptyChainedHandlerFunction)[], EmptyChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'empty'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | EmptyChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "empty";

    const demarshal = (bodyString: string): any => {
        return {};
    };
    const body = parseBody(event.body, demarshal, ['application/json']) as EmptyRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MapRequest
 */
export type MapRequestRequestBody = MapRequest;

// Type that the handler function provided to the wrapper must conform to
export type MapRequestHandlerFunction = LambdaHandlerFunction<MapRequestRequestBody>;
export type MapRequestChainedHandlerFunction = ChainedLambdaHandlerFunction<MapRequestRequestBody>;
export type MapRequestChainedRequestInput = ChainedRequestInput<MapRequestRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mapRequest
 */
export const mapRequestHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MapRequestChainedHandlerFunction)[], MapRequestChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'mapRequest'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MapRequestChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "mapRequest";

    const demarshal = (bodyString: string): any => {
        return MapRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as MapRequestRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MediaTypes
 */
export type MediaTypesRequestBody = string;

// Type that the handler function provided to the wrapper must conform to
export type MediaTypesHandlerFunction = LambdaHandlerFunction<MediaTypesRequestBody>;
export type MediaTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MediaTypesRequestBody>;
export type MediaTypesChainedRequestInput = ChainedRequestInput<MediaTypesRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of mediaTypes
 */
export const mediaTypesHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MediaTypesChainedHandlerFunction)[], MediaTypesChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'mediaTypes'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MediaTypesChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "mediaTypes";

    const demarshal = (bodyString: string): any => {
        return bodyString;
    };
    const body = parseBody(event.body, demarshal, ['application/pdf',]) as MediaTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for MultipleContentTypes
 */
export type MultipleContentTypesRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type MultipleContentTypesHandlerFunction = LambdaHandlerFunction<MultipleContentTypesRequestBody>;
export type MultipleContentTypesChainedHandlerFunction = ChainedLambdaHandlerFunction<MultipleContentTypesRequestBody>;
export type MultipleContentTypesChainedRequestInput = ChainedRequestInput<MultipleContentTypesRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of multipleContentTypes
 */
export const multipleContentTypesHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | MultipleContentTypesChainedHandlerFunction)[], MultipleContentTypesChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'multipleContentTypes'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | MultipleContentTypesChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "multipleContentTypes";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json','application/pdf',]) as MultipleContentTypesRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

/**
 * Request body parameter for WithoutOperationIdPost
 */
export type WithoutOperationIdPostRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
export type WithoutOperationIdPostHandlerFunction = LambdaHandlerFunction<WithoutOperationIdPostRequestBody>;
export type WithoutOperationIdPostChainedHandlerFunction = ChainedLambdaHandlerFunction<WithoutOperationIdPostRequestBody>;
export type WithoutOperationIdPostChainedRequestInput = ChainedRequestInput<WithoutOperationIdPostRequestBody>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of withoutOperationIdPost
 */
export const withoutOperationIdPostHandler = (
    ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | WithoutOperationIdPostChainedHandlerFunction)[], WithoutOperationIdPostChainedHandlerFunction]
): OperationApiGatewayLambdaHandler<'withoutOperationIdPost'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: (PayloadlessChainedLambdaHandlerFunction | WithoutOperationIdPostChainedHandlerFunction)[] = []): Promise<APIGatewayProxyResultV2> => {
    const operationId = "withoutOperationIdPost";

    const demarshal = (bodyString: string): any => {
        return TestRequestFromJSON(JSON.parse(bodyString)?.payload ?? {});
    };
    const body = parseBody(event.body, demarshal, ['application/json',]) as WithoutOperationIdPostRequestBody;

    const chain = buildHandlerChain(...additionalInterceptors, ...handlers);
    await chain.next({
        input: body,
        connectionId: event.requestContext.connectionId,
        sdk: new DefaultApiServerSdk({
          callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
        }),
        event,
        context,
        interceptorContext: { operationId },
    });

    return {
        // Respond success to indicate to API gateway that we have implemented the integration
        // Websocket operations are one-way.
        statusCode: 200,
    };
};

export type $ConnectChainedLambdaHandlerFunction = PayloadlessChainedLambdaHandlerFunction;

export const $connectHandler = (
  ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<any>)[], $ConnectChainedLambdaHandlerFunction]
): OperationApiGatewayLambdaHandler<'$connect'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: PayloadlessChainedLambdaHandlerFunction[] = []): Promise<APIGatewayProxyResultV2> => {
  const operationId = "$connect";
  const chain = buildHandlerChain(...additionalInterceptors, ...(handlers as any)) as PayloadlessLambdaHandlerChain;
  const interceptorContext = { operationId };
  await chain.next({
      connectionId: event.requestContext.connectionId,
      sdk: new DefaultApiServerSdk({
        callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
      }),
      event,
      context,
      interceptorContext,
  });

  return {
      // Respond with 200, unless the handler explicitly denies the connection
      statusCode: interceptorContext[$PendingConnection.DENY_CONTEXT_KEY] ? 403 : 200,
  };
};

export type $DisconnectChainedLambdaHandlerFunction = PayloadlessChainedLambdaHandlerFunction;

export const $disconnectHandler = (
  ...handlers: [...(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<any>)[], $DisconnectChainedLambdaHandlerFunction]
): OperationApiGatewayLambdaHandler<'$disconnect'> => async (event: APIGatewayProxyWebsocketEventV2, context: any, _callback?: any, additionalInterceptors: PayloadlessChainedLambdaHandlerFunction[] = []): Promise<APIGatewayProxyResultV2> => {
  const operationId = "$disconnect";
  const chain = buildHandlerChain(...additionalInterceptors, ...handlers) as PayloadlessLambdaHandlerChain;
  await chain.next({
      connectionId: event.requestContext.connectionId,
      sdk: new DefaultApiServerSdk({
        callbackUrl: \`https://\${event.requestContext.domainName}/\${event.requestContext.stage}\`,
      }),
      event,
      context,
      interceptorContext: { operationId },
  });

  return {
      // Respond success to indicate to API gateway that we have implemented the integration
      // Websocket operations are one-way.
      statusCode: 200,
  };
};

export interface HandlerRouterHandlers {
  readonly anyRequest: OperationApiGatewayLambdaHandler<'anyRequest'>;
  readonly bidirectional: OperationApiGatewayLambdaHandler<'bidirectional'>;
  readonly clientToServer: OperationApiGatewayLambdaHandler<'clientToServer'>;
  readonly empty: OperationApiGatewayLambdaHandler<'empty'>;
  readonly mapRequest: OperationApiGatewayLambdaHandler<'mapRequest'>;
  readonly mediaTypes: OperationApiGatewayLambdaHandler<'mediaTypes'>;
  readonly multipleContentTypes: OperationApiGatewayLambdaHandler<'multipleContentTypes'>;
  readonly withoutOperationIdPost: OperationApiGatewayLambdaHandler<'withoutOperationIdPost'>;
  readonly $connect?: OperationApiGatewayLambdaHandler<'$connect'>;
  readonly $disconnect?: OperationApiGatewayLambdaHandler<'$disconnect'>;
}

export type AnyOperationRequestBodies = never| AnyRequestRequestBody| BidirectionalRequestBody| ClientToServerRequestBody| EmptyRequestBody| MapRequestRequestBody| MediaTypesRequestBody| MultipleContentTypesRequestBody| WithoutOperationIdPostRequestBody;

export interface HandlerRouterProps<
  RequestBody,
> {
  /**
   * Interceptors to apply to all handlers
   */
  readonly interceptors?: ReadonlyArray<(PayloadlessChainedLambdaHandlerFunction | ChainedLambdaHandlerFunction<RequestBody>)>;

  /**
   * Handlers to register for each operation
   */
  readonly handlers: HandlerRouterHandlers;
}

const OperationIdByPath = Object.fromEntries(Object.entries(OperationLookup).map(
  ([operationId, details]: [string, {path: string}]) => [details.path.replace(/\\//g, ''), operationId]
));

/**
 * Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
 */
export const handlerRouter = (props: HandlerRouterProps<
  AnyOperationRequestBodies
>): OperationApiGatewayLambdaHandler<OperationIds> => async (event, context) => {
  const handler = props.handlers[OperationIdByPath[event.requestContext.routeKey]];
  return handler(event, context, undefined, props.interceptors);
};
",
  "src/server/server-sdk.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    MapRequest,
    MapRequestFromJSON,
    MapRequestToJSON,
    MapRequestMapPropertyValue,
    MapRequestMapPropertyValueFromJSON,
    MapRequestMapPropertyValueToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerToJSON,
} from "../models";
import {
  ApiGatewayManagementApiClient,
  PostToConnectionCommand,
  DeleteConnectionCommand,
} from "@aws-sdk/client-apigatewaymanagementapi";

/**
 * Options for the server SDK
 */
export interface DefaultApiServerSdkProps {
  /**
   * API Gateway management API callback url
   */
  readonly callbackUrl: string;
}

/**
 * SDK for sending messages from the server to connected clients
 */
export class DefaultApiServerSdk {
  private readonly client: ApiGatewayManagementApiClient;

  constructor(props: DefaultApiServerSdkProps) {
    this.client = new ApiGatewayManagementApiClient({ endpoint: props.callbackUrl });
  }

  public async anyRequest(connectionId: string, input: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "AnyRequest",
        payload: input,
      }),
    }));
  }
  public async bidirectional(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "Bidirectional",
        payload: input,
      }),
    }));
  }
  public async empty(connectionId: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "Empty",
        payload: input,
      }),
    }));
  }
  public async mapRequest(connectionId: string, input: MapRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MapRequest",
        payload: input,
      }),
    }));
  }
  public async mediaTypes(connectionId: string, input: string): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MediaTypes",
        payload: input,
      }),
    }));
  }
  public async multipleContentTypes(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "MultipleContentTypes",
        payload: input,
      }),
    }));
  }
  public async serverToClient(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "ServerToClient",
        payload: input,
      }),
    }));
  }
  public async withoutOperationIdPost(connectionId: string, input: TestRequest): Promise<void> {
    await this.client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: JSON.stringify({
        route: "WithoutOperationIdPost",
        payload: input,
      }),
    }));
  }

  /**
   * Disconnect a connected client
   */
  public async $disconnect(connectionId: string): Promise<void> {
    await this.client.send(new DeleteConnectionCommand({
      ConnectionId: connectionId,
    }));
  }
}
",
}
`;
