// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generated Typescript Client Code Unit Tests Multi 1`] = `
Object {
  ".gitignore": "wwwroot/*.js
node_modules
typings
dist
",
  ".npmignore": "README.md",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".gitignore
.npmignore
.openapi-generator-ignore
README.md
package.json
src/apis/DefaultApi.ts
src/apis/DefaultApi/OperationConfig.ts
src/apis/index.ts
src/index.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/index.ts
src/runtime.ts
tsconfig.esm.json
tsconfig.json
",
  ".openapi-generator/VERSION": "6.0.0",
  ".projen/files.json": Object {
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run \\"npx projen\\".",
    "files": Array [
      ".gitattributes",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
    ],
  },
  ".projen/tasks.json": Object {
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run \\"npx projen\\".",
    "tasks": Object {
      "build": Object {
        "description": "Full release build",
        "name": "build",
        "steps": Array [
          Object {
            "spawn": "default",
          },
          Object {
            "spawn": "pre-compile",
          },
          Object {
            "spawn": "compile",
          },
          Object {
            "spawn": "post-compile",
          },
          Object {
            "spawn": "test",
          },
          Object {
            "spawn": "package",
          },
        ],
      },
      "compile": Object {
        "description": "Only compile",
        "name": "compile",
      },
      "default": Object {
        "description": "Synthesize project files",
        "name": "default",
      },
      "eject": Object {
        "description": "Remove projen from the project",
        "env": Object {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": Array [
          Object {
            "spawn": "default",
          },
        ],
      },
      "package": Object {
        "description": "Creates the distribution package",
        "name": "package",
      },
      "post-compile": Object {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": Object {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
      },
      "test": Object {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  "README.md": "## test@1.0.0

This generator creates TypeScript/JavaScript client that utilizes [Fetch API](https://fetch.spec.whatwg.org/). The generated Node module can be used in the following environments:

Environment
* Node.js
* Webpack
* Browserify

Language level
* ES5 - you must have a Promises/A+ library installed
* ES6

Module system
* CommonJS
* ES6 module system

It can be used in both TypeScript and JavaScript. In TypeScript, the definition should be automatically resolved via \`package.json\`. ([Reference](http://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html))

### Building

To build and compile the typescript sources to javascript use:
\`\`\`
npm install
npm run build
\`\`\`

### Publishing

First build the package then run \`\`\`npm publish\`\`\`

### Consuming

navigate to the folder of your consuming project and run one of the following commands.

_published:_

\`\`\`
npm install test@1.0.0 --save
\`\`\`

_unPublished (not recommended):_

\`\`\`
npm install PATH_TO_GENERATED_PACKAGE --save
",
  "package.json": Object {
    "author": "OpenAPI-Generator",
    "description": "OpenAPI client for test",
    "devDependencies": Object {
      "typescript": "^4.0",
    },
    "main": "./dist/index.js",
    "module": "./dist/esm/index.js",
    "name": "test",
    "repository": Object {
      "type": "git",
      "url": "https://github.com/GIT_USER_ID/GIT_REPO_ID.git",
    },
    "scripts": Object {
      "build": "tsc && tsc -p tsconfig.esm.json",
      "prepare": "npm run build",
    },
    "sideEffects": false,
    "typings": "./dist/index.d.ts",
    "version": "1.0.0",
  },
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../models';

export interface SomeTestOperationRequest {
    pathParam: string;
    testRequest: TestRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async someTestOperationRaw(requestParameters: SomeTestOperationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        if (requestParameters.pathParam === null || requestParameters.pathParam === undefined) {
            throw new runtime.RequiredError('pathParam','Required parameter requestParameters.pathParam was null or undefined when calling someTestOperation.');
        }

        if (requestParameters.testRequest === null || requestParameters.testRequest === undefined) {
            throw new runtime.RequiredError('testRequest','Required parameter requestParameters.testRequest was null or undefined when calling someTestOperation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: \`/operation/{pathParam}\`.replace(\`{\${\\"pathParam\\"}}\`, encodeURIComponent(String(requestParameters.pathParam))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestRequestToJSON(requestParameters.testRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     */
    async someTestOperation(requestParameters: SomeTestOperationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TestResponse> {
        const response = await this.someTestOperationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    SomeTestOperationRequest,
} from '..';

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    someTestOperation: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    someTestOperation: {
        path: '/operation/{pathParam}',
        method: 'POST',
    },
};

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? JSON.parse(body || '{}') : body;

// Api gateway lambda handler type
type ApiGatewayLambdaHandler = (event: any, context: any) => Promise<any>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<T, ApiError> {
    statusCode: number;
    headers?: { [key: string]: string };
    body?: T | ApiError;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody> = {
    requestParameters: RequestParameters,
    requestArrayParameters: RequestArrayParameters,
    body: RequestBody,
};

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, RequestOutput, ApiError> = (
    input: LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody>,
    event: any,
    context: any,
) => Promise<OperationResponse<RequestOutput, ApiError>>;

// Type alias for the request
type SomeTestOperationRequestInput = SomeTestOperationRequest;

/**
 * Single-value path/query parameters for SomeTestOperation
 */
export interface SomeTestOperationRequestParameters {
    readonly pathParam: string;
}

/**
 * Multi-value query parameters for SomeTestOperation
 */
export interface SomeTestOperationRequestArrayParameters {
}

/**
 * Request body parameter for SomeTestOperation
 */
export type SomeTestOperationRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
type SomeTestOperationHandlerFunction<ApiError> = LambdaHandlerFunction<SomeTestOperationRequestParameters, SomeTestOperationRequestArrayParameters, SomeTestOperationRequestBody, TestResponse, ApiError>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of someTestOperation
 */
export const someTestOperationHandler = <ApiError>(handler: SomeTestOperationHandlerFunction<ApiError>): ApiGatewayLambdaHandler => async (event: any, context: any): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as SomeTestOperationRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as SomeTestOperationRequestArrayParameters;

    const body = parseBody(event.body, ['application/json',]) as SomeTestOperationRequestBody;

    const response = await handler({
        requestParameters,
        requestArrayParameters,
        body,
    }, event, context);

    return {
        ...response,
        body: response.body ? JSON.stringify(response.body) : '',
    };
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
} from './TestResponseMessagesInner';

/**
 * 
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export const BASE_PATH = \\"http://localhost\\".replace(/\\\\/+$/, \\"\\");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a \\"?\\" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === \\"function\\"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overridedInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        }

        const init: RequestInit = {
            ...overridedInit,
            body:
                isFormData(overridedInit.body) ||
                overridedInit.body instanceof URLSearchParams ||
                isBlob(overridedInit.body)
                    ? overridedInit.body
                    : JSON.stringify(overridedInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== \\"undefined\\" && value instanceof FormData
}

export class ResponseError extends Error {
    name: \\"ResponseError\\" = \\"ResponseError\\";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    name: \\"RequiredError\\" = \\"RequiredError\\";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: \\",\\",
    ssv: \\" \\",
    tsv: \\"\\\\t\\",
    pipes: \\"|\\",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody }
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
  "tsconfig.esm.json": Object {
    "compilerOptions": Object {
      "module": "esnext",
      "outDir": "dist/esm",
    },
    "extends": "./tsconfig.json",
  },
  "tsconfig.json": Object {
    "compilerOptions": Object {
      "declaration": true,
      "module": "commonjs",
      "moduleResolution": "node",
      "outDir": "dist",
      "target": "es6",
      "typeRoots": Array [
        "node_modules/@types",
      ],
    },
    "exclude": Array [
      "dist",
      "node_modules",
    ],
  },
}
`;

exports[`Generated Typescript Client Code Unit Tests Single 1`] = `
Object {
  ".gitignore": "wwwroot/*.js
node_modules
typings
dist
",
  ".npmignore": "README.md",
  ".openapi-generator-ignore": "# OpenAPI Generator Ignore
# Generated by openapi-generator https://github.com/openapitools/openapi-generator

# Use this file to prevent files from being overwritten by the generator.
# The patterns follow closely to .gitignore or .dockerignore.

# As an example, the C# client generator defines ApiClient.cs.
# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
#ApiClient.cs

# You can match any string of characters against a directory, file or extension with a single asterisk (*):
#foo/*/qux
# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux

# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
#foo/**/qux
# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux

# You can also negate patterns with an exclamation (!).
# For example, you can ignore all files in a docs folder with the file extension .md:
#docs/*.md
# Then explicitly reverse the ignore rule for a single file:
#!docs/README.md
",
  ".openapi-generator/FILES": ".gitignore
.npmignore
.openapi-generator-ignore
README.md
package.json
src/apis/DefaultApi.ts
src/apis/DefaultApi/OperationConfig.ts
src/apis/index.ts
src/index.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/ApiError.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestRequest.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponse.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/TestResponseMessagesInner.ts
src/models/index.ts
src/runtime.ts
tsconfig.esm.json
tsconfig.json
",
  ".openapi-generator/VERSION": "6.0.0",
  ".projen/files.json": Object {
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run \\"npx projen\\".",
    "files": Array [
      ".gitattributes",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
    ],
  },
  ".projen/tasks.json": Object {
    "//": "~~ Generated by projen. To modify, edit .projenrc.js and run \\"npx projen\\".",
    "tasks": Object {
      "build": Object {
        "description": "Full release build",
        "name": "build",
        "steps": Array [
          Object {
            "spawn": "default",
          },
          Object {
            "spawn": "pre-compile",
          },
          Object {
            "spawn": "compile",
          },
          Object {
            "spawn": "post-compile",
          },
          Object {
            "spawn": "test",
          },
          Object {
            "spawn": "package",
          },
        ],
      },
      "compile": Object {
        "description": "Only compile",
        "name": "compile",
      },
      "default": Object {
        "description": "Synthesize project files",
        "name": "default",
      },
      "eject": Object {
        "description": "Remove projen from the project",
        "env": Object {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": Array [
          Object {
            "spawn": "default",
          },
        ],
      },
      "package": Object {
        "description": "Creates the distribution package",
        "name": "package",
      },
      "post-compile": Object {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": Object {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
      },
      "test": Object {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  "README.md": "## test@1.0.0

This generator creates TypeScript/JavaScript client that utilizes [Fetch API](https://fetch.spec.whatwg.org/). The generated Node module can be used in the following environments:

Environment
* Node.js
* Webpack
* Browserify

Language level
* ES5 - you must have a Promises/A+ library installed
* ES6

Module system
* CommonJS
* ES6 module system

It can be used in both TypeScript and JavaScript. In TypeScript, the definition should be automatically resolved via \`package.json\`. ([Reference](http://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html))

### Building

To build and compile the typescript sources to javascript use:
\`\`\`
npm install
npm run build
\`\`\`

### Publishing

First build the package then run \`\`\`npm publish\`\`\`

### Consuming

navigate to the folder of your consuming project and run one of the following commands.

_published:_

\`\`\`
npm install test@1.0.0 --save
\`\`\`

_unPublished (not recommended):_

\`\`\`
npm install PATH_TO_GENERATED_PACKAGE --save
",
  "package.json": Object {
    "author": "OpenAPI-Generator",
    "description": "OpenAPI client for test",
    "devDependencies": Object {
      "typescript": "^4.0",
    },
    "main": "./dist/index.js",
    "module": "./dist/esm/index.js",
    "name": "test",
    "repository": Object {
      "type": "git",
      "url": "https://github.com/GIT_USER_ID/GIT_REPO_ID.git",
    },
    "scripts": Object {
      "build": "tsc && tsc -p tsconfig.esm.json",
      "prepare": "npm run build",
    },
    "sideEffects": false,
    "typings": "./dist/index.d.ts",
    "version": "1.0.0",
  },
  "src/apis/DefaultApi.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../models';

export interface OperationOneRequest {
    param1: string;
    param2: Array<string>;
    param3: number;
    pathParam: string;
    testRequest: TestRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async operationOneRaw(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        if (requestParameters.param1 === null || requestParameters.param1 === undefined) {
            throw new runtime.RequiredError('param1','Required parameter requestParameters.param1 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param2 === null || requestParameters.param2 === undefined) {
            throw new runtime.RequiredError('param2','Required parameter requestParameters.param2 was null or undefined when calling operationOne.');
        }

        if (requestParameters.param3 === null || requestParameters.param3 === undefined) {
            throw new runtime.RequiredError('param3','Required parameter requestParameters.param3 was null or undefined when calling operationOne.');
        }

        if (requestParameters.pathParam === null || requestParameters.pathParam === undefined) {
            throw new runtime.RequiredError('pathParam','Required parameter requestParameters.pathParam was null or undefined when calling operationOne.');
        }

        if (requestParameters.testRequest === null || requestParameters.testRequest === undefined) {
            throw new runtime.RequiredError('testRequest','Required parameter requestParameters.testRequest was null or undefined when calling operationOne.');
        }

        const queryParameters: any = {};

        if (requestParameters.param1 !== undefined) {
            queryParameters['param1'] = requestParameters.param1;
        }

        if (requestParameters.param2) {
            queryParameters['param2'] = requestParameters.param2;
        }

        if (requestParameters.param3 !== undefined) {
            queryParameters['param3'] = requestParameters.param3;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: \`/path/{pathParam}\`.replace(\`{\${\\"pathParam\\"}}\`, encodeURIComponent(String(requestParameters.pathParam))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestRequestToJSON(requestParameters.testRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     */
    async operationOne(requestParameters: OperationOneRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TestResponse> {
        const response = await this.operationOneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async withoutOperationIdDeleteRaw(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TestResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: \`/without-operation-id\`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TestResponseFromJSON(jsonValue));
    }

    /**
     */
    async withoutOperationIdDelete(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TestResponse> {
        const response = await this.withoutOperationIdDeleteRaw(initOverrides);
        return await response.value();
    }

}
",
  "src/apis/DefaultApi/OperationConfig.ts": "// Import models
import {
    ApiError,
    ApiErrorFromJSON,
    ApiErrorToJSON,
    TestRequest,
    TestRequestFromJSON,
    TestRequestToJSON,
    TestResponse,
    TestResponseFromJSON,
    TestResponseToJSON,
} from '../../models';
// Import request parameter interfaces
import {
    OperationOneRequest,
    
} from '..';

// Generic type for object keyed by operation names
export interface OperationConfig<T> {
    operationOne: T;
    withoutOperationIdDelete: T;
}

// Look up path and http method for a given operation name
export const OperationLookup = {
    operationOne: {
        path: '/path/{pathParam}',
        method: 'POST',
    },
    withoutOperationIdDelete: {
        path: '/without-operation-id',
        method: 'DELETE',
    },
};

// Standard apigateway request parameters (query parameters or path parameters, multi or single value)
type ApiGatewayRequestParameters = { [key: string]: string | string[] | undefined };

/**
 * URI decode for a string or array of strings
 */
const uriDecode = (value: string | string[]): string | string[] =>
    typeof value === 'string' ? decodeURIComponent(value) : value.map((v) => decodeURIComponent(v));

/**
 * URI decodes apigateway request parameters (query or path parameters)
 */
const decodeRequestParameters = (parameters: ApiGatewayRequestParameters): ApiGatewayRequestParameters => {
    const decodedParameters = {};
    Object.keys(parameters || {}).forEach((key) => {
        decodedParameters[key] = parameters[key] ? uriDecode(parameters[key]) : parameters[key];
    });
    return decodedParameters;
};

/**
 * Parse the body if the content type is json, otherwise leave as a raw string
 */
const parseBody = (body: string, contentTypes: string[]): any => contentTypes.filter((contentType) => contentType !== 'application/json').length === 0 ? JSON.parse(body || '{}') : body;

// Api gateway lambda handler type
type ApiGatewayLambdaHandler = (event: any, context: any) => Promise<any>;

// Type of the response to be returned by an operation lambda handler
export interface OperationResponse<T, ApiError> {
    statusCode: number;
    headers?: { [key: string]: string };
    body?: T | ApiError;
}

// Input for a lambda handler for an operation
export type LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody> = {
    requestParameters: RequestParameters,
    requestArrayParameters: RequestArrayParameters,
    body: RequestBody,
};

// Type for a lambda handler function to be wrapped
export type LambdaHandlerFunction<RequestParameters, RequestArrayParameters, RequestBody, RequestOutput, ApiError> = (
    input: LambdaRequestParameters<RequestParameters, RequestArrayParameters, RequestBody>,
    event: any,
    context: any,
) => Promise<OperationResponse<RequestOutput, ApiError>>;

// Type alias for the request
type OperationOneRequestInput = OperationOneRequest;

/**
 * Single-value path/query parameters for OperationOne
 */
export interface OperationOneRequestParameters {
    readonly param1: string;
    readonly param3: string;
    readonly pathParam: string;
}

/**
 * Multi-value query parameters for OperationOne
 */
export interface OperationOneRequestArrayParameters {
    readonly param2: string[];
}

/**
 * Request body parameter for OperationOne
 */
export type OperationOneRequestBody = TestRequest;

// Type that the handler function provided to the wrapper must conform to
type OperationOneHandlerFunction<ApiError> = LambdaHandlerFunction<OperationOneRequestParameters, OperationOneRequestArrayParameters, OperationOneRequestBody, TestResponse, ApiError>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of operationOne
 */
export const operationOneHandler = <ApiError>(handler: OperationOneHandlerFunction<ApiError>): ApiGatewayLambdaHandler => async (event: any, context: any): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as OperationOneRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as OperationOneRequestArrayParameters;

    const body = parseBody(event.body, ['application/json',]) as OperationOneRequestBody;

    const response = await handler({
        requestParameters,
        requestArrayParameters,
        body,
    }, event, context);

    return {
        ...response,
        body: response.body ? JSON.stringify(response.body) : '',
    };
};
// Type alias for the request
type WithoutOperationIdDeleteRequestInput = {};

/**
 * Single-value path/query parameters for WithoutOperationIdDelete
 */
export interface WithoutOperationIdDeleteRequestParameters {
}

/**
 * Multi-value query parameters for WithoutOperationIdDelete
 */
export interface WithoutOperationIdDeleteRequestArrayParameters {
}

/**
 * Request body parameter for WithoutOperationIdDelete
 */
export type WithoutOperationIdDeleteRequestBody = never;

// Type that the handler function provided to the wrapper must conform to
type WithoutOperationIdDeleteHandlerFunction<ApiError> = LambdaHandlerFunction<WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestArrayParameters, WithoutOperationIdDeleteRequestBody, TestResponse, ApiError>;

/**
 * Lambda handler wrapper to provide typed interface for the implementation of withoutOperationIdDelete
 */
export const withoutOperationIdDeleteHandler = <ApiError>(handler: WithoutOperationIdDeleteHandlerFunction<ApiError>): ApiGatewayLambdaHandler => async (event: any, context: any): Promise<any> => {
    const requestParameters = decodeRequestParameters({
        ...(event.pathParameters || {}),
        ...(event.queryStringParameters || {}),
    }) as unknown as WithoutOperationIdDeleteRequestParameters;

    const requestArrayParameters = decodeRequestParameters({
        ...(event.multiValueQueryStringParameters || {}),
    }) as unknown as WithoutOperationIdDeleteRequestArrayParameters;

    const body = parseBody(event.body, ['application/json']) as WithoutOperationIdDeleteRequestBody;

    const response = await handler({
        requestParameters,
        requestArrayParameters,
        body,
    }, event, context);

    return {
        ...response,
        body: response.body ? JSON.stringify(response.body) : '',
    };
};
",
  "src/apis/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './DefaultApi';
",
  "src/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './runtime';
export * from './apis';
export * from './models';
export * from './apis/DefaultApi/OperationConfig';",
  "src/models/ApiError.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    errorMessage: string;
}


export function ApiErrorFromJSON(json: any): ApiError {
    return ApiErrorFromJSONTyped(json, false);
}

export function ApiErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ApiError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'errorMessage': json['errorMessage'],
    };
}

export function ApiErrorToJSON(value?: ApiError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'errorMessage': value.errorMessage,
    };
}

",
  "src/models/TestRequest.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    myInput?: number;
}


export function TestRequestFromJSON(json: any): TestRequest {
    return TestRequestFromJSONTyped(json, false);
}

export function TestRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'myInput': !exists(json, 'myInput') ? undefined : json['myInput'],
    };
}

export function TestRequestToJSON(value?: TestRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'myInput': value.myInput,
    };
}

",
  "src/models/TestResponse.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    TestResponseMessagesInner,
    TestResponseMessagesInnerFromJSON,
    TestResponseMessagesInnerFromJSONTyped,
    TestResponseMessagesInnerToJSON,
} from './TestResponseMessagesInner';

/**
 * 
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {Array<TestResponseMessagesInner>}
     * @memberof TestResponse
     */
    messages: Array<TestResponseMessagesInner>;
}


export function TestResponseFromJSON(json: any): TestResponse {
    return TestResponseFromJSONTyped(json, false);
}

export function TestResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'messages': ((json['messages'] as Array<any>).map(TestResponseMessagesInnerFromJSON)),
    };
}

export function TestResponseToJSON(value?: TestResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'messages': ((value.messages as Array<any>).map(TestResponseMessagesInnerToJSON)),
    };
}

",
  "src/models/TestResponseMessagesInner.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface TestResponseMessagesInner
 */
export interface TestResponseMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof TestResponseMessagesInner
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponseMessagesInner
     */
    id: number;
}


export function TestResponseMessagesInnerFromJSON(json: any): TestResponseMessagesInner {
    return TestResponseMessagesInnerFromJSONTyped(json, false);
}

export function TestResponseMessagesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): TestResponseMessagesInner {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'message': !exists(json, 'message') ? undefined : json['message'],
        'id': json['id'],
    };
}

export function TestResponseMessagesInnerToJSON(value?: TestResponseMessagesInner | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'message': value.message,
        'id': value.id,
    };
}

",
  "src/models/index.ts": "/* tslint:disable */
/* eslint-disable */
export * from './ApiError';
export * from './TestRequest';
export * from './TestResponse';
export * from './TestResponseMessagesInner';
",
  "src/runtime.ts": "/* tslint:disable */
/* eslint-disable */
/**
 * Example API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export const BASE_PATH = \\"http://localhost\\".replace(/\\\\/+$/, \\"\\");

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a \\"?\\" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === \\"function\\"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overridedInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        }

        const init: RequestInit = {
            ...overridedInit,
            body:
                isFormData(overridedInit.body) ||
                overridedInit.body instanceof URLSearchParams ||
                isBlob(overridedInit.body)
                    ? overridedInit.body
                    : JSON.stringify(overridedInit.body),
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of \`this\` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== \\"undefined\\" && value instanceof FormData
}

export class ResponseError extends Error {
    name: \\"ResponseError\\" = \\"ResponseError\\";
    constructor(public response: Response, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    name: \\"RequiredError\\" = \\"RequiredError\\";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: \\",\\",
    ssv: \\" \\",
    tsv: \\"\\\\t\\",
    pipes: \\"|\\",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody }
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? \`[\${key}]\` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(\`&\${encodeURIComponent(fullKey)}=\`);
        return \`\${encodeURIComponent(fullKey)}=\${multiValue}\`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(value.toISOString())}\`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return \`\${encodeURIComponent(fullKey)}=\${encodeURIComponent(String(value))}\`;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}
",
  "tsconfig.esm.json": Object {
    "compilerOptions": Object {
      "module": "esnext",
      "outDir": "dist/esm",
    },
    "extends": "./tsconfig.json",
  },
  "tsconfig.json": Object {
    "compilerOptions": Object {
      "declaration": true,
      "module": "commonjs",
      "moduleResolution": "node",
      "outDir": "dist",
      "target": "es6",
      "typeRoots": Array [
        "node_modules/@types",
      ],
    },
    "exclude": Array [
      "dist",
      "node_modules",
    ],
  },
}
`;
