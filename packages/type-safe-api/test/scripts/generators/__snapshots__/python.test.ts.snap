// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Python Client Code Generation Script Unit Tests Generates With allof-model.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/Template.md
docs/TemplateBase.md
docs/TemplateBody.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/template.py
test_project/models/template_base.py
test_project/models/template_body.py",
  "README.md": "# My API
See https://github.com/aws/aws-pdk/issues/841

This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.say_hello()
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**say_hello**](docs/DefaultApi.md#say_hello) | **GET** /hello | 

## Documentation For Models

 - [Template](docs/Template.md)
 - [TemplateBase](docs/TemplateBase.md)
 - [TemplateBody](docs/TemplateBody.md)
",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**say_hello**](DefaultApi.md#say_hello) | **GET** /hello | 

# **say_hello**
> Template say_hello()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.say_hello()
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**Template**](Template.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/Template.md": "# Template

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** | The unique identifier for a template. | 
**parent_id** | **str** | The unique identifier for a template. | [optional] 
**boolean** | **bool** | A boolean value. | [optional] 

## Example

\`\`\`python
from test_project.models.template import Template

# TODO update the JSON string below
json = "{}"
# create an instance of Template from a JSON string
template_instance = Template.from_json(json)
# print the JSON string representation of the object
print(Template.to_json())

# convert the object into a dict
template_dict = template_instance.to_dict()
# create an instance of Template from a dict
template_form_dict = template.from_dict(template_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/TemplateBase.md": "# TemplateBase

Represents the base properties of a template.

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** | The unique identifier for a template. | 

## Example

\`\`\`python
from test_project.models.template_base import TemplateBase

# TODO update the JSON string below
json = "{}"
# create an instance of TemplateBase from a JSON string
template_base_instance = TemplateBase.from_json(json)
# print the JSON string representation of the object
print(TemplateBase.to_json())

# convert the object into a dict
template_base_dict = template_base_instance.to_dict()
# create an instance of TemplateBase from a dict
template_base_form_dict = template_base.from_dict(template_base_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/TemplateBody.md": "# TemplateBody

Represents the body of a template.

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**parent_id** | **str** | The unique identifier for a template. | [optional] 
**boolean** | **bool** | A boolean value. | [optional] 

## Example

\`\`\`python
from test_project.models.template_body import TemplateBody

# TODO update the JSON string below
json = "{}"
# create an instance of TemplateBody from a JSON string
template_body_instance = TemplateBody.from_json(json)
# print the JSON string representation of the object
print(TemplateBody.to_json())

# convert the object into a dict
template_body_dict = template_body_instance.to_dict()
# create an instance of TemplateBody from a dict
template_body_form_dict = template_body.from_dict(template_body_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.template import Template
from test_project.models.template_base import TemplateBase
from test_project.models.template_body import TemplateBody
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.template import Template

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def say_hello(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Template:
        """say_hello
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Template"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def say_hello_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Template]:
        """say_hello
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Template"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def say_hello_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """say_hello
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Template"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _say_hello_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hello',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    say_hello: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "say_hello": {
        "path": "/hello",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class SayHelloRequestParameters(BaseModel):
    """
    Query, path and header parameters for the SayHello operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SayHelloRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> SayHelloRequestParameters:
        if obj is None:
            return None
        return SayHelloRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
SayHelloRequestBody = Any

SayHello200OperationResponse = ApiResponse[Literal[200], Template]

SayHelloOperationResponses = Union[SayHello200OperationResponse, ]

# Request type for say_hello
SayHelloRequest = ApiRequest[SayHelloRequestParameters, SayHelloRequestBody]
SayHelloChainedRequest = ChainedApiRequest[SayHelloRequestParameters, SayHelloRequestBody]

class SayHelloHandlerFunction(Protocol):
    def __call__(self, input: SayHelloRequest, **kwargs) -> SayHelloOperationResponses:
        ...

SayHelloInterceptor = Callable[[SayHelloChainedRequest], SayHelloOperationResponses]

def say_hello_handler(_handler: SayHelloHandlerFunction = None, interceptors: List[SayHelloInterceptor] = []):
    """
    Decorator for an api handler for the say_hello operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: SayHelloHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = SayHelloRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "say_hello",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by say_hello_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  say_hello: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.template import Template
from test_project.models.template_base import TemplateBase
from test_project.models.template_body import TemplateBody
",
  "test_project/models/template.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Template(BaseModel):
    """
    Template
    """ # noqa: E501
    id: Annotated[str, Field(strict=True, max_length=36)] = Field(description="The unique identifier for a template.")
    parent_id: Optional[Annotated[str, Field(strict=True, max_length=36)]] = Field(default=None, description="The unique identifier for a template.")
    boolean: Optional[StrictBool] = Field(default=None, description="A boolean value.")
    __properties: ClassVar[List[str]] = ["id", "parent_id", "boolean"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Template from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Template from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "parent_id": obj.get("parent_id"),
            "boolean": obj.get("boolean")
        })
        return _obj

",
  "test_project/models/template_base.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class TemplateBase(BaseModel):
    """
    Represents the base properties of a template.

    """ # noqa: E501
    id: Annotated[str, Field(strict=True, max_length=36)] = Field(description="The unique identifier for a template.")
    __properties: ClassVar[List[str]] = ["id"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TemplateBase from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of TemplateBase from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id")
        })
        return _obj

",
  "test_project/models/template_body.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class TemplateBody(BaseModel):
    """
    Represents the body of a template.

    """ # noqa: E501
    parent_id: Optional[Annotated[str, Field(strict=True, max_length=36)]] = Field(default=None, description="The unique identifier for a template.")
    boolean: Optional[StrictBool] = Field(default=None, description="A boolean value.")
    __properties: ClassVar[List[str]] = ["parent_id", "boolean"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TemplateBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of TemplateBody from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "parent_id": obj.get("parent_id"),
            "boolean": obj.get("boolean")
        })
        return _obj

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With composite-models.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/A.md
docs/AllOfInlineAndRefs.md
docs/AllOfRefs.md
docs/AnyOfInlineAndRefs.md
docs/AnyOfInlineAndRefsAnyOf.md
docs/AnyOfInlineAndRefsAnyOf1.md
docs/AnyOfPrimitives.md
docs/AnyOfPrimitivesAndRefs.md
docs/AnyOfRefs.md
docs/B.md
docs/C.md
docs/OneOfInlineAndRefs.md
docs/OneOfInlineAndRefsOneOf.md
docs/OneOfInlineAndRefsOneOf1.md
docs/OneOfPrimitives.md
docs/OneOfPrimitivesAndRefs.md
docs/OneOfRefs.md
docs/Wrapper.md
docs/WrapperAllOf.md
docs/WrapperAnyOf.md
docs/WrapperOneOf.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/a.py
test_project/models/all_of_inline_and_refs.py
test_project/models/all_of_refs.py
test_project/models/any_of_inline_and_refs.py
test_project/models/any_of_inline_and_refs_any_of.py
test_project/models/any_of_inline_and_refs_any_of1.py
test_project/models/any_of_primitives.py
test_project/models/any_of_primitives_and_refs.py
test_project/models/any_of_refs.py
test_project/models/b.py
test_project/models/c.py
test_project/models/one_of_inline_and_refs.py
test_project/models/one_of_inline_and_refs_one_of.py
test_project/models/one_of_inline_and_refs_one_of1.py
test_project/models/one_of_primitives.py
test_project/models/one_of_primitives_and_refs.py
test_project/models/one_of_refs.py
test_project/models/wrapper.py
test_project/models/wrapper_all_of.py
test_project/models/wrapper_any_of.py
test_project/models/wrapper_one_of.py",
  "README.md": "# composite models


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.op_get()
        print("The response of DefaultApi->op_get:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->op_get: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**op_get**](docs/DefaultApi.md#op_get) | **GET** /op | 

## Documentation For Models

 - [A](docs/A.md)
 - [AllOfInlineAndRefs](docs/AllOfInlineAndRefs.md)
 - [AllOfInlineAndRefsAllOf](docs/AllOfInlineAndRefsAllOf.md)
 - [AllOfInlineAndRefsAllOf1](docs/AllOfInlineAndRefsAllOf1.md)
 - [AllOfRefs](docs/AllOfRefs.md)
 - [AnyOfInlineAndRefs](docs/AnyOfInlineAndRefs.md)
 - [AnyOfInlineAndRefsAnyOf](docs/AnyOfInlineAndRefsAnyOf.md)
 - [AnyOfInlineAndRefsAnyOf1](docs/AnyOfInlineAndRefsAnyOf1.md)
 - [AnyOfPrimitives](docs/AnyOfPrimitives.md)
 - [AnyOfPrimitivesAndRefs](docs/AnyOfPrimitivesAndRefs.md)
 - [AnyOfRefs](docs/AnyOfRefs.md)
 - [B](docs/B.md)
 - [C](docs/C.md)
 - [OneOfInlineAndRefs](docs/OneOfInlineAndRefs.md)
 - [OneOfInlineAndRefsOneOf](docs/OneOfInlineAndRefsOneOf.md)
 - [OneOfInlineAndRefsOneOf1](docs/OneOfInlineAndRefsOneOf1.md)
 - [OneOfPrimitives](docs/OneOfPrimitives.md)
 - [OneOfPrimitivesAndRefs](docs/OneOfPrimitivesAndRefs.md)
 - [OneOfRefs](docs/OneOfRefs.md)
 - [Wrapper](docs/Wrapper.md)
 - [WrapperAllOf](docs/WrapperAllOf.md)
 - [WrapperAnyOf](docs/WrapperAnyOf.md)
 - [WrapperOneOf](docs/WrapperOneOf.md)
",
  "docs/A.md": "# A

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**a** | **str** |  | 

## Example

\`\`\`python
from test_project.models.a import A

# TODO update the JSON string below
json = "{}"
# create an instance of A from a JSON string
a_instance = A.from_json(json)
# print the JSON string representation of the object
print(A.to_json())

# convert the object into a dict
a_dict = a_instance.to_dict()
# create an instance of A from a dict
a_form_dict = a.from_dict(a_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AllOfInlineAndRefs.md": "# AllOfInlineAndRefs

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**d** | **str** |  | 
**a** | **str** |  | 
**b** | **str** |  | 
**c** | **str** |  | 
**e** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.all_of_inline_and_refs import AllOfInlineAndRefs

# TODO update the JSON string below
json = "{}"
# create an instance of AllOfInlineAndRefs from a JSON string
all_of_inline_and_refs_instance = AllOfInlineAndRefs.from_json(json)
# print the JSON string representation of the object
print(AllOfInlineAndRefs.to_json())

# convert the object into a dict
all_of_inline_and_refs_dict = all_of_inline_and_refs_instance.to_dict()
# create an instance of AllOfInlineAndRefs from a dict
all_of_inline_and_refs_form_dict = all_of_inline_and_refs.from_dict(all_of_inline_and_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AllOfRefs.md": "# AllOfRefs

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**a** | **str** |  | 
**b** | **str** |  | 
**c** | **str** |  | 

## Example

\`\`\`python
from test_project.models.all_of_refs import AllOfRefs

# TODO update the JSON string below
json = "{}"
# create an instance of AllOfRefs from a JSON string
all_of_refs_instance = AllOfRefs.from_json(json)
# print the JSON string representation of the object
print(AllOfRefs.to_json())

# convert the object into a dict
all_of_refs_dict = all_of_refs_instance.to_dict()
# create an instance of AllOfRefs from a dict
all_of_refs_form_dict = all_of_refs.from_dict(all_of_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfInlineAndRefs.md": "# AnyOfInlineAndRefs

## Composed Of

This model can be set to any of the following types:

Type | Description | Notes
------------- | ------------- | -------------
[**AnyOfInlineAndRefsAnyOf**](AnyOfInlineAndRefsAnyOf.md) | 
[**A**](A.md) | 
[**B**](B.md) | 
[**C**](C.md) | 
[**AnyOfInlineAndRefsAnyOf1**](AnyOfInlineAndRefsAnyOf1.md) | 

## Example

\`\`\`python
from test_project.models.any_of_inline_and_refs import AnyOfInlineAndRefs

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfInlineAndRefs from a JSON string
any_of_inline_and_refs_instance = AnyOfInlineAndRefs.from_json(json)
# print the JSON string representation of the object
print(AnyOfInlineAndRefs.to_json())

# convert the object into a dict
any_of_inline_and_refs_dict = any_of_inline_and_refs_instance.to_dict()
# create an instance of AnyOfInlineAndRefs from a dict
any_of_inline_and_refs_form_dict = any_of_inline_and_refs.from_dict(any_of_inline_and_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfInlineAndRefsAnyOf.md": "# AnyOfInlineAndRefsAnyOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**d** | **str** |  | 

## Example

\`\`\`python
from test_project.models.any_of_inline_and_refs_any_of import AnyOfInlineAndRefsAnyOf

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfInlineAndRefsAnyOf from a JSON string
any_of_inline_and_refs_any_of_instance = AnyOfInlineAndRefsAnyOf.from_json(json)
# print the JSON string representation of the object
print(AnyOfInlineAndRefsAnyOf.to_json())

# convert the object into a dict
any_of_inline_and_refs_any_of_dict = any_of_inline_and_refs_any_of_instance.to_dict()
# create an instance of AnyOfInlineAndRefsAnyOf from a dict
any_of_inline_and_refs_any_of_form_dict = any_of_inline_and_refs_any_of.from_dict(any_of_inline_and_refs_any_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfInlineAndRefsAnyOf1.md": "# AnyOfInlineAndRefsAnyOf1

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**e** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.any_of_inline_and_refs_any_of1 import AnyOfInlineAndRefsAnyOf1

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfInlineAndRefsAnyOf1 from a JSON string
any_of_inline_and_refs_any_of1_instance = AnyOfInlineAndRefsAnyOf1.from_json(json)
# print the JSON string representation of the object
print(AnyOfInlineAndRefsAnyOf1.to_json())

# convert the object into a dict
any_of_inline_and_refs_any_of1_dict = any_of_inline_and_refs_any_of1_instance.to_dict()
# create an instance of AnyOfInlineAndRefsAnyOf1 from a dict
any_of_inline_and_refs_any_of1_form_dict = any_of_inline_and_refs_any_of1.from_dict(any_of_inline_and_refs_any_of1_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfPrimitives.md": "# AnyOfPrimitives

## Composed Of

This model can be set to any of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
**int** | 

## Example

\`\`\`python
from test_project.models.any_of_primitives import AnyOfPrimitives

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfPrimitives from a JSON string
any_of_primitives_instance = AnyOfPrimitives.from_json(json)
# print the JSON string representation of the object
print(AnyOfPrimitives.to_json())

# convert the object into a dict
any_of_primitives_dict = any_of_primitives_instance.to_dict()
# create an instance of AnyOfPrimitives from a dict
any_of_primitives_form_dict = any_of_primitives.from_dict(any_of_primitives_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfPrimitivesAndRefs.md": "# AnyOfPrimitivesAndRefs

## Composed Of

This model can be set to any of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
[**A**](A.md) | 

## Example

\`\`\`python
from test_project.models.any_of_primitives_and_refs import AnyOfPrimitivesAndRefs

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfPrimitivesAndRefs from a JSON string
any_of_primitives_and_refs_instance = AnyOfPrimitivesAndRefs.from_json(json)
# print the JSON string representation of the object
print(AnyOfPrimitivesAndRefs.to_json())

# convert the object into a dict
any_of_primitives_and_refs_dict = any_of_primitives_and_refs_instance.to_dict()
# create an instance of AnyOfPrimitivesAndRefs from a dict
any_of_primitives_and_refs_form_dict = any_of_primitives_and_refs.from_dict(any_of_primitives_and_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/AnyOfRefs.md": "# AnyOfRefs

## Composed Of

This model can be set to any of the following types:

Type | Description | Notes
------------- | ------------- | -------------
[**A**](A.md) | 
[**B**](B.md) | 
[**C**](C.md) | 

## Example

\`\`\`python
from test_project.models.any_of_refs import AnyOfRefs

# TODO update the JSON string below
json = "{}"
# create an instance of AnyOfRefs from a JSON string
any_of_refs_instance = AnyOfRefs.from_json(json)
# print the JSON string representation of the object
print(AnyOfRefs.to_json())

# convert the object into a dict
any_of_refs_dict = any_of_refs_instance.to_dict()
# create an instance of AnyOfRefs from a dict
any_of_refs_form_dict = any_of_refs.from_dict(any_of_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/B.md": "# B

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**b** | **str** |  | 

## Example

\`\`\`python
from test_project.models.b import B

# TODO update the JSON string below
json = "{}"
# create an instance of B from a JSON string
b_instance = B.from_json(json)
# print the JSON string representation of the object
print(B.to_json())

# convert the object into a dict
b_dict = b_instance.to_dict()
# create an instance of B from a dict
b_form_dict = b.from_dict(b_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/C.md": "# C

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**c** | **str** |  | 

## Example

\`\`\`python
from test_project.models.c import C

# TODO update the JSON string below
json = "{}"
# create an instance of C from a JSON string
c_instance = C.from_json(json)
# print the JSON string representation of the object
print(C.to_json())

# convert the object into a dict
c_dict = c_instance.to_dict()
# create an instance of C from a dict
c_form_dict = c.from_dict(c_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**op_get**](DefaultApi.md#op_get) | **GET** /op | 

# **op_get**
> Wrapper op_get()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.op_get()
        print("The response of DefaultApi->op_get:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->op_get: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**Wrapper**](Wrapper.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/OneOfInlineAndRefs.md": "# OneOfInlineAndRefs

## Composed Of

This model can be set to one of the following types:

Type | Description | Notes
------------- | ------------- | -------------
[**OneOfInlineAndRefsOneOf**](OneOfInlineAndRefsOneOf.md) | 
[**A**](A.md) | 
[**B**](B.md) | 
[**C**](C.md) | 
[**OneOfInlineAndRefsOneOf1**](OneOfInlineAndRefsOneOf1.md) | 

## Example

\`\`\`python
from test_project.models.one_of_inline_and_refs import OneOfInlineAndRefs

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfInlineAndRefs from a JSON string
one_of_inline_and_refs_instance = OneOfInlineAndRefs.from_json(json)
# print the JSON string representation of the object
print(OneOfInlineAndRefs.to_json())

# convert the object into a dict
one_of_inline_and_refs_dict = one_of_inline_and_refs_instance.to_dict()
# create an instance of OneOfInlineAndRefs from a dict
one_of_inline_and_refs_form_dict = one_of_inline_and_refs.from_dict(one_of_inline_and_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/OneOfInlineAndRefsOneOf.md": "# OneOfInlineAndRefsOneOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**d** | **str** |  | 

## Example

\`\`\`python
from test_project.models.one_of_inline_and_refs_one_of import OneOfInlineAndRefsOneOf

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfInlineAndRefsOneOf from a JSON string
one_of_inline_and_refs_one_of_instance = OneOfInlineAndRefsOneOf.from_json(json)
# print the JSON string representation of the object
print(OneOfInlineAndRefsOneOf.to_json())

# convert the object into a dict
one_of_inline_and_refs_one_of_dict = one_of_inline_and_refs_one_of_instance.to_dict()
# create an instance of OneOfInlineAndRefsOneOf from a dict
one_of_inline_and_refs_one_of_form_dict = one_of_inline_and_refs_one_of.from_dict(one_of_inline_and_refs_one_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/OneOfInlineAndRefsOneOf1.md": "# OneOfInlineAndRefsOneOf1

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**e** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.one_of_inline_and_refs_one_of1 import OneOfInlineAndRefsOneOf1

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfInlineAndRefsOneOf1 from a JSON string
one_of_inline_and_refs_one_of1_instance = OneOfInlineAndRefsOneOf1.from_json(json)
# print the JSON string representation of the object
print(OneOfInlineAndRefsOneOf1.to_json())

# convert the object into a dict
one_of_inline_and_refs_one_of1_dict = one_of_inline_and_refs_one_of1_instance.to_dict()
# create an instance of OneOfInlineAndRefsOneOf1 from a dict
one_of_inline_and_refs_one_of1_form_dict = one_of_inline_and_refs_one_of1.from_dict(one_of_inline_and_refs_one_of1_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/OneOfPrimitives.md": "# OneOfPrimitives

## Composed Of

This model can be set to one of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
**int** | 

## Example

\`\`\`python
from test_project.models.one_of_primitives import OneOfPrimitives

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfPrimitives from a JSON string
one_of_primitives_instance = OneOfPrimitives.from_json(json)
# print the JSON string representation of the object
print(OneOfPrimitives.to_json())

# convert the object into a dict
one_of_primitives_dict = one_of_primitives_instance.to_dict()
# create an instance of OneOfPrimitives from a dict
one_of_primitives_form_dict = one_of_primitives.from_dict(one_of_primitives_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/OneOfPrimitivesAndRefs.md": "# OneOfPrimitivesAndRefs

## Composed Of

This model can be set to one of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
[**A**](A.md) | 

## Example

\`\`\`python
from test_project.models.one_of_primitives_and_refs import OneOfPrimitivesAndRefs

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfPrimitivesAndRefs from a JSON string
one_of_primitives_and_refs_instance = OneOfPrimitivesAndRefs.from_json(json)
# print the JSON string representation of the object
print(OneOfPrimitivesAndRefs.to_json())

# convert the object into a dict
one_of_primitives_and_refs_dict = one_of_primitives_and_refs_instance.to_dict()
# create an instance of OneOfPrimitivesAndRefs from a dict
one_of_primitives_and_refs_form_dict = one_of_primitives_and_refs.from_dict(one_of_primitives_and_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/OneOfRefs.md": "# OneOfRefs

## Composed Of

This model can be set to one of the following types:

Type | Description | Notes
------------- | ------------- | -------------
[**A**](A.md) | 
[**B**](B.md) | 
[**C**](C.md) | 

## Example

\`\`\`python
from test_project.models.one_of_refs import OneOfRefs

# TODO update the JSON string below
json = "{}"
# create an instance of OneOfRefs from a JSON string
one_of_refs_instance = OneOfRefs.from_json(json)
# print the JSON string representation of the object
print(OneOfRefs.to_json())

# convert the object into a dict
one_of_refs_dict = one_of_refs_instance.to_dict()
# create an instance of OneOfRefs from a dict
one_of_refs_form_dict = one_of_refs.from_dict(one_of_refs_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/Wrapper.md": "# Wrapper

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**all_of** | [**WrapperAllOf**](WrapperAllOf.md) |  | [optional] 
**any_of** | [**WrapperAnyOf**](WrapperAnyOf.md) |  | [optional] 
**one_of** | [**WrapperOneOf**](WrapperOneOf.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.wrapper import Wrapper

# TODO update the JSON string below
json = "{}"
# create an instance of Wrapper from a JSON string
wrapper_instance = Wrapper.from_json(json)
# print the JSON string representation of the object
print(Wrapper.to_json())

# convert the object into a dict
wrapper_dict = wrapper_instance.to_dict()
# create an instance of Wrapper from a dict
wrapper_form_dict = wrapper.from_dict(wrapper_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/WrapperAllOf.md": "# WrapperAllOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**refs** | [**AllOfRefs**](AllOfRefs.md) |  | [optional] 
**inline_and_refs** | [**AllOfInlineAndRefs**](AllOfInlineAndRefs.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.wrapper_all_of import WrapperAllOf

# TODO update the JSON string below
json = "{}"
# create an instance of WrapperAllOf from a JSON string
wrapper_all_of_instance = WrapperAllOf.from_json(json)
# print the JSON string representation of the object
print(WrapperAllOf.to_json())

# convert the object into a dict
wrapper_all_of_dict = wrapper_all_of_instance.to_dict()
# create an instance of WrapperAllOf from a dict
wrapper_all_of_form_dict = wrapper_all_of.from_dict(wrapper_all_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/WrapperAnyOf.md": "# WrapperAnyOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**refs** | [**AnyOfRefs**](AnyOfRefs.md) |  | [optional] 
**inline_and_refs** | [**AnyOfInlineAndRefs**](AnyOfInlineAndRefs.md) |  | [optional] 
**primitives** | [**AnyOfPrimitives**](AnyOfPrimitives.md) |  | [optional] 
**primitives_and_refs** | [**AnyOfPrimitivesAndRefs**](AnyOfPrimitivesAndRefs.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.wrapper_any_of import WrapperAnyOf

# TODO update the JSON string below
json = "{}"
# create an instance of WrapperAnyOf from a JSON string
wrapper_any_of_instance = WrapperAnyOf.from_json(json)
# print the JSON string representation of the object
print(WrapperAnyOf.to_json())

# convert the object into a dict
wrapper_any_of_dict = wrapper_any_of_instance.to_dict()
# create an instance of WrapperAnyOf from a dict
wrapper_any_of_form_dict = wrapper_any_of.from_dict(wrapper_any_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/WrapperOneOf.md": "# WrapperOneOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**refs** | [**OneOfRefs**](OneOfRefs.md) |  | [optional] 
**inline_and_refs** | [**OneOfInlineAndRefs**](OneOfInlineAndRefs.md) |  | [optional] 
**primitives** | [**OneOfPrimitives**](OneOfPrimitives.md) |  | [optional] 
**primitives_and_refs** | [**OneOfPrimitivesAndRefs**](OneOfPrimitivesAndRefs.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.wrapper_one_of import WrapperOneOf

# TODO update the JSON string below
json = "{}"
# create an instance of WrapperOneOf from a JSON string
wrapper_one_of_instance = WrapperOneOf.from_json(json)
# print the JSON string representation of the object
print(WrapperOneOf.to_json())

# convert the object into a dict
wrapper_one_of_dict = wrapper_one_of_instance.to_dict()
# create an instance of WrapperOneOf from a dict
wrapper_one_of_form_dict = wrapper_one_of.from_dict(wrapper_one_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.a import A
from test_project.models.all_of_inline_and_refs import AllOfInlineAndRefs
from test_project.models.all_of_refs import AllOfRefs
from test_project.models.any_of_inline_and_refs import AnyOfInlineAndRefs
from test_project.models.any_of_inline_and_refs_any_of import AnyOfInlineAndRefsAnyOf
from test_project.models.any_of_inline_and_refs_any_of1 import AnyOfInlineAndRefsAnyOf1
from test_project.models.any_of_primitives import AnyOfPrimitives
from test_project.models.any_of_primitives_and_refs import AnyOfPrimitivesAndRefs
from test_project.models.any_of_refs import AnyOfRefs
from test_project.models.b import B
from test_project.models.c import C
from test_project.models.one_of_inline_and_refs import OneOfInlineAndRefs
from test_project.models.one_of_inline_and_refs_one_of import OneOfInlineAndRefsOneOf
from test_project.models.one_of_inline_and_refs_one_of1 import OneOfInlineAndRefsOneOf1
from test_project.models.one_of_primitives import OneOfPrimitives
from test_project.models.one_of_primitives_and_refs import OneOfPrimitivesAndRefs
from test_project.models.one_of_refs import OneOfRefs
from test_project.models.wrapper import Wrapper
from test_project.models.wrapper_all_of import WrapperAllOf
from test_project.models.wrapper_any_of import WrapperAnyOf
from test_project.models.wrapper_one_of import WrapperOneOf
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.wrapper import Wrapper

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def op_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Wrapper:
        """op_get
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._op_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Wrapper"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def op_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Wrapper]:
        """op_get
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._op_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Wrapper"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def op_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """op_get
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._op_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Wrapper"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _op_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/op',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    op_get: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "op_get": {
        "path": "/op",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class OpGetRequestParameters(BaseModel):
    """
    Query, path and header parameters for the OpGet operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> OpGetRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> OpGetRequestParameters:
        if obj is None:
            return None
        return OpGetRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
OpGetRequestBody = Any

OpGet200OperationResponse = ApiResponse[Literal[200], Wrapper]

OpGetOperationResponses = Union[OpGet200OperationResponse, ]

# Request type for op_get
OpGetRequest = ApiRequest[OpGetRequestParameters, OpGetRequestBody]
OpGetChainedRequest = ChainedApiRequest[OpGetRequestParameters, OpGetRequestBody]

class OpGetHandlerFunction(Protocol):
    def __call__(self, input: OpGetRequest, **kwargs) -> OpGetOperationResponses:
        ...

OpGetInterceptor = Callable[[OpGetChainedRequest], OpGetOperationResponses]

def op_get_handler(_handler: OpGetHandlerFunction = None, interceptors: List[OpGetInterceptor] = []):
    """
    Decorator for an api handler for the op_get operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: OpGetHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = OpGetRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "op_get",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by op_get_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  op_get: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.a import A
from test_project.models.all_of_inline_and_refs import AllOfInlineAndRefs
from test_project.models.all_of_refs import AllOfRefs
from test_project.models.any_of_inline_and_refs import AnyOfInlineAndRefs
from test_project.models.any_of_inline_and_refs_any_of import AnyOfInlineAndRefsAnyOf
from test_project.models.any_of_inline_and_refs_any_of1 import AnyOfInlineAndRefsAnyOf1
from test_project.models.any_of_primitives import AnyOfPrimitives
from test_project.models.any_of_primitives_and_refs import AnyOfPrimitivesAndRefs
from test_project.models.any_of_refs import AnyOfRefs
from test_project.models.b import B
from test_project.models.c import C
from test_project.models.one_of_inline_and_refs import OneOfInlineAndRefs
from test_project.models.one_of_inline_and_refs_one_of import OneOfInlineAndRefsOneOf
from test_project.models.one_of_inline_and_refs_one_of1 import OneOfInlineAndRefsOneOf1
from test_project.models.one_of_primitives import OneOfPrimitives
from test_project.models.one_of_primitives_and_refs import OneOfPrimitivesAndRefs
from test_project.models.one_of_refs import OneOfRefs
from test_project.models.wrapper import Wrapper
from test_project.models.wrapper_all_of import WrapperAllOf
from test_project.models.wrapper_any_of import WrapperAnyOf
from test_project.models.wrapper_one_of import WrapperOneOf
",
  "test_project/models/a.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class A(BaseModel):
    """
    A
    """ # noqa: E501
    a: StrictStr
    __properties: ClassVar[List[str]] = ["a"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of A from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of A from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "a": obj.get("a")
        })
        return _obj

",
  "test_project/models/all_of_inline_and_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class AllOfInlineAndRefs(BaseModel):
    """
    AllOfInlineAndRefs
    """ # noqa: E501
    d: StrictStr
    a: StrictStr
    b: StrictStr
    c: StrictStr
    e: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["d", "a", "b", "c", "e"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of AllOfInlineAndRefs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of AllOfInlineAndRefs from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "d": obj.get("d"),
            "a": obj.get("a"),
            "b": obj.get("b"),
            "c": obj.get("c"),
            "e": obj.get("e")
        })
        return _obj

",
  "test_project/models/all_of_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class AllOfRefs(BaseModel):
    """
    AllOfRefs
    """ # noqa: E501
    a: StrictStr
    b: StrictStr
    c: StrictStr
    __properties: ClassVar[List[str]] = ["a", "b", "c"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of AllOfRefs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of AllOfRefs from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "a": obj.get("a"),
            "b": obj.get("b"),
            "c": obj.get("c")
        })
        return _obj

",
  "test_project/models/any_of_inline_and_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
from test_project.models.any_of_inline_and_refs_any_of import AnyOfInlineAndRefsAnyOf
from test_project.models.any_of_inline_and_refs_any_of1 import AnyOfInlineAndRefsAnyOf1
from test_project.models.b import B
from test_project.models.c import C
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ANYOFINLINEANDREFS_ANY_OF_SCHEMAS = ["AnyOfInlineAndRefsAnyOf", "A", "B", "C", "AnyOfInlineAndRefsAnyOf1"]

class AnyOfInlineAndRefs(BaseModel):
    """
    AnyOfInlineAndRefs
    """ # noqa: E501
    # data type: AnyOfInlineAndRefsAnyOf
    anyof_schema_1_validator: Optional[AnyOfInlineAndRefsAnyOf] = None
    # data type: A
    anyof_schema_2_validator: Optional[A] = None
    # data type: B
    anyof_schema_3_validator: Optional[B] = None
    # data type: C
    anyof_schema_4_validator: Optional[C] = None
    # data type: AnyOfInlineAndRefsAnyOf1
    anyof_schema_5_validator: Optional[AnyOfInlineAndRefsAnyOf1] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = Literal[ANYOFINLINEANDREFS_ANY_OF_SCHEMAS]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = AnyOfInlineAndRefs.model_construct()
        error_messages = []
        # validate data type: AnyOfInlineAndRefsAnyOf
        if not isinstance(v, AnyOfInlineAndRefsAnyOf):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`AnyOfInlineAndRefsAnyOf\`")
        else:
            return v

        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            return v

        # validate data type: B
        if not isinstance(v, B):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`B\`")
        else:
            return v

        # validate data type: C
        if not isinstance(v, C):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`C\`")
        else:
            return v

        # validate data type: AnyOfInlineAndRefsAnyOf1
        if not isinstance(v, AnyOfInlineAndRefsAnyOf1):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`AnyOfInlineAndRefsAnyOf1\`")
        else:
            return v

        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in AnyOfInlineAndRefs with anyOf schemas: AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # anyof_schema_1_validator: Optional[AnyOfInlineAndRefsAnyOf] = None
        try:
            instance.actual_instance = AnyOfInlineAndRefsAnyOf.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_2_validator: Optional[A] = None
        try:
            instance.actual_instance = A.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_3_validator: Optional[B] = None
        try:
            instance.actual_instance = B.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_4_validator: Optional[C] = None
        try:
            instance.actual_instance = C.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_5_validator: Optional[AnyOfInlineAndRefsAnyOf1] = None
        try:
            instance.actual_instance = AnyOfInlineAndRefsAnyOf1.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AnyOfInlineAndRefs with anyOf schemas: AnyOfInlineAndRefsAnyOf, A, B, C, AnyOfInlineAndRefsAnyOf1. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/any_of_inline_and_refs_any_of.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class AnyOfInlineAndRefsAnyOf(BaseModel):
    """
    AnyOfInlineAndRefsAnyOf
    """ # noqa: E501
    d: StrictStr
    __properties: ClassVar[List[str]] = ["d"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of AnyOfInlineAndRefsAnyOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of AnyOfInlineAndRefsAnyOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "d": obj.get("d")
        })
        return _obj

",
  "test_project/models/any_of_inline_and_refs_any_of1.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class AnyOfInlineAndRefsAnyOf1(BaseModel):
    """
    AnyOfInlineAndRefsAnyOf1
    """ # noqa: E501
    e: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["e"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of AnyOfInlineAndRefsAnyOf1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of AnyOfInlineAndRefsAnyOf1 from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "e": obj.get("e")
        })
        return _obj

",
  "test_project/models/any_of_primitives.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ANYOFPRIMITIVES_ANY_OF_SCHEMAS = ["str", "int"]

class AnyOfPrimitives(BaseModel):
    """
    AnyOfPrimitives
    """ # noqa: E501
    # data type: str
    anyof_schema_1_validator: Optional[StrictStr] = None
    # data type: int
    anyof_schema_2_validator: Optional[StrictInt] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[str, int]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = Literal[ANYOFPRIMITIVES_ANY_OF_SCHEMAS]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = AnyOfPrimitives.model_construct()
        error_messages = []
        # validate data type: str
        try:
            instance.anyof_schema_1_validator = v
            return v
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: int
        try:
            instance.anyof_schema_2_validator = v
            return v
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in AnyOfPrimitives with anyOf schemas: str, int. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # deserialize data into str
        try:
            # validation
            instance.anyof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.anyof_schema_1_validator
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into int
        try:
            # validation
            instance.anyof_schema_2_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.anyof_schema_2_validator
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AnyOfPrimitives with anyOf schemas: str, int. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/any_of_primitives_and_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ANYOFPRIMITIVESANDREFS_ANY_OF_SCHEMAS = ["str", "A"]

class AnyOfPrimitivesAndRefs(BaseModel):
    """
    AnyOfPrimitivesAndRefs
    """ # noqa: E501
    # data type: str
    anyof_schema_1_validator: Optional[StrictStr] = None
    # data type: A
    anyof_schema_2_validator: Optional[A] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[str, A]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = Literal[ANYOFPRIMITIVESANDREFS_ANY_OF_SCHEMAS]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = AnyOfPrimitivesAndRefs.model_construct()
        error_messages = []
        # validate data type: str
        try:
            instance.anyof_schema_1_validator = v
            return v
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            return v

        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in AnyOfPrimitivesAndRefs with anyOf schemas: str, A. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # deserialize data into str
        try:
            # validation
            instance.anyof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.anyof_schema_1_validator
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_2_validator: Optional[A] = None
        try:
            instance.actual_instance = A.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AnyOfPrimitivesAndRefs with anyOf schemas: str, A. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/any_of_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
from test_project.models.b import B
from test_project.models.c import C
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ANYOFREFS_ANY_OF_SCHEMAS = ["A", "B", "C"]

class AnyOfRefs(BaseModel):
    """
    AnyOfRefs
    """ # noqa: E501
    # data type: A
    anyof_schema_1_validator: Optional[A] = None
    # data type: B
    anyof_schema_2_validator: Optional[B] = None
    # data type: C
    anyof_schema_3_validator: Optional[C] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[A, B, C]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = Literal[ANYOFREFS_ANY_OF_SCHEMAS]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = AnyOfRefs.model_construct()
        error_messages = []
        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            return v

        # validate data type: B
        if not isinstance(v, B):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`B\`")
        else:
            return v

        # validate data type: C
        if not isinstance(v, C):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`C\`")
        else:
            return v

        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in AnyOfRefs with anyOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # anyof_schema_1_validator: Optional[A] = None
        try:
            instance.actual_instance = A.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_2_validator: Optional[B] = None
        try:
            instance.actual_instance = B.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # anyof_schema_3_validator: Optional[C] = None
        try:
            instance.actual_instance = C.from_json(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AnyOfRefs with anyOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/b.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class B(BaseModel):
    """
    B
    """ # noqa: E501
    b: StrictStr
    __properties: ClassVar[List[str]] = ["b"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of B from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of B from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "b": obj.get("b")
        })
        return _obj

",
  "test_project/models/c.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class C(BaseModel):
    """
    C
    """ # noqa: E501
    c: StrictStr
    __properties: ClassVar[List[str]] = ["c"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of C from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of C from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "c": obj.get("c")
        })
        return _obj

",
  "test_project/models/one_of_inline_and_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
from test_project.models.b import B
from test_project.models.c import C
from test_project.models.one_of_inline_and_refs_one_of import OneOfInlineAndRefsOneOf
from test_project.models.one_of_inline_and_refs_one_of1 import OneOfInlineAndRefsOneOf1
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ONEOFINLINEANDREFS_ONE_OF_SCHEMAS = ["OneOfInlineAndRefsOneOf", "A", "B", "C", "OneOfInlineAndRefsOneOf1"]

class OneOfInlineAndRefs(BaseModel):
    """
    OneOfInlineAndRefs
    """ # noqa: E501
    # data type: OneOfInlineAndRefsOneOf
    oneof_schema_1_validator: Optional[OneOfInlineAndRefsOneOf] = None
    # data type: A
    oneof_schema_2_validator: Optional[A] = None
    # data type: B
    oneof_schema_3_validator: Optional[B] = None
    # data type: C
    oneof_schema_4_validator: Optional[C] = None
    # data type: OneOfInlineAndRefsOneOf1
    oneof_schema_5_validator: Optional[OneOfInlineAndRefsOneOf1] = None
    actual_instance: Optional[Union[OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1]] = None
    one_of_schemas: List[str] = Literal["OneOfInlineAndRefsOneOf", "A", "B", "C", "OneOfInlineAndRefsOneOf1"]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = OneOfInlineAndRefs.model_construct()
        error_messages = []
        match = 0
        # validate data type: OneOfInlineAndRefsOneOf
        if not isinstance(v, OneOfInlineAndRefsOneOf):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`OneOfInlineAndRefsOneOf\`")
        else:
            match += 1
        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            match += 1
        # validate data type: B
        if not isinstance(v, B):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`B\`")
        else:
            match += 1
        # validate data type: C
        if not isinstance(v, C):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`C\`")
        else:
            match += 1
        # validate data type: OneOfInlineAndRefsOneOf1
        if not isinstance(v, OneOfInlineAndRefsOneOf1):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`OneOfInlineAndRefsOneOf1\`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting \`actual_instance\` in OneOfInlineAndRefs with oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting \`actual_instance\` in OneOfInlineAndRefs with oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into OneOfInlineAndRefsOneOf
        try:
            instance.actual_instance = OneOfInlineAndRefsOneOf.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into A
        try:
            instance.actual_instance = A.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into B
        try:
            instance.actual_instance = B.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into C
        try:
            instance.actual_instance = C.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into OneOfInlineAndRefsOneOf1
        try:
            instance.actual_instance = OneOfInlineAndRefsOneOf1.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into OneOfInlineAndRefs with oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into OneOfInlineAndRefs with oneOf schemas: OneOfInlineAndRefsOneOf, A, B, C, OneOfInlineAndRefsOneOf1. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/one_of_inline_and_refs_one_of.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OneOfInlineAndRefsOneOf(BaseModel):
    """
    OneOfInlineAndRefsOneOf
    """ # noqa: E501
    d: StrictStr
    __properties: ClassVar[List[str]] = ["d"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OneOfInlineAndRefsOneOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OneOfInlineAndRefsOneOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "d": obj.get("d")
        })
        return _obj

",
  "test_project/models/one_of_inline_and_refs_one_of1.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OneOfInlineAndRefsOneOf1(BaseModel):
    """
    OneOfInlineAndRefsOneOf1
    """ # noqa: E501
    e: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["e"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OneOfInlineAndRefsOneOf1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OneOfInlineAndRefsOneOf1 from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "e": obj.get("e")
        })
        return _obj

",
  "test_project/models/one_of_primitives.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ONEOFPRIMITIVES_ONE_OF_SCHEMAS = ["str", "int"]

class OneOfPrimitives(BaseModel):
    """
    OneOfPrimitives
    """ # noqa: E501
    # data type: str
    oneof_schema_1_validator: Optional[StrictStr] = None
    # data type: int
    oneof_schema_2_validator: Optional[StrictInt] = None
    actual_instance: Optional[Union[str, int]] = None
    one_of_schemas: List[str] = Literal["str", "int"]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = OneOfPrimitives.model_construct()
        error_messages = []
        match = 0
        # validate data type: str
        try:
            instance.oneof_schema_1_validator = v
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: int
        try:
            instance.oneof_schema_2_validator = v
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting \`actual_instance\` in OneOfPrimitives with oneOf schemas: str, int. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting \`actual_instance\` in OneOfPrimitives with oneOf schemas: str, int. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into str
        try:
            # validation
            instance.oneof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.oneof_schema_1_validator
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into int
        try:
            # validation
            instance.oneof_schema_2_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.oneof_schema_2_validator
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into OneOfPrimitives with oneOf schemas: str, int. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into OneOfPrimitives with oneOf schemas: str, int. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/one_of_primitives_and_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ONEOFPRIMITIVESANDREFS_ONE_OF_SCHEMAS = ["str", "A"]

class OneOfPrimitivesAndRefs(BaseModel):
    """
    OneOfPrimitivesAndRefs
    """ # noqa: E501
    # data type: str
    oneof_schema_1_validator: Optional[StrictStr] = None
    # data type: A
    oneof_schema_2_validator: Optional[A] = None
    actual_instance: Optional[Union[str, A]] = None
    one_of_schemas: List[str] = Literal["str", "A"]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = OneOfPrimitivesAndRefs.model_construct()
        error_messages = []
        match = 0
        # validate data type: str
        try:
            instance.oneof_schema_1_validator = v
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting \`actual_instance\` in OneOfPrimitivesAndRefs with oneOf schemas: str, A. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting \`actual_instance\` in OneOfPrimitivesAndRefs with oneOf schemas: str, A. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into str
        try:
            # validation
            instance.oneof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.oneof_schema_1_validator
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into A
        try:
            instance.actual_instance = A.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into OneOfPrimitivesAndRefs with oneOf schemas: str, A. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into OneOfPrimitivesAndRefs with oneOf schemas: str, A. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/one_of_refs.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.a import A
from test_project.models.b import B
from test_project.models.c import C
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

ONEOFREFS_ONE_OF_SCHEMAS = ["A", "B", "C"]

class OneOfRefs(BaseModel):
    """
    OneOfRefs
    """ # noqa: E501
    # data type: A
    oneof_schema_1_validator: Optional[A] = None
    # data type: B
    oneof_schema_2_validator: Optional[B] = None
    # data type: C
    oneof_schema_3_validator: Optional[C] = None
    actual_instance: Optional[Union[A, B, C]] = None
    one_of_schemas: List[str] = Literal["A", "B", "C"]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = OneOfRefs.model_construct()
        error_messages = []
        match = 0
        # validate data type: A
        if not isinstance(v, A):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`A\`")
        else:
            match += 1
        # validate data type: B
        if not isinstance(v, B):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`B\`")
        else:
            match += 1
        # validate data type: C
        if not isinstance(v, C):
            error_messages.append(f"Error! Input type \`{type(v)}\` is not \`C\`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting \`actual_instance\` in OneOfRefs with oneOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting \`actual_instance\` in OneOfRefs with oneOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into A
        try:
            instance.actual_instance = A.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into B
        try:
            instance.actual_instance = B.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into C
        try:
            instance.actual_instance = C.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into OneOfRefs with oneOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into OneOfRefs with oneOf schemas: A, B, C. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/wrapper.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.wrapper_all_of import WrapperAllOf
from test_project.models.wrapper_any_of import WrapperAnyOf
from test_project.models.wrapper_one_of import WrapperOneOf
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Wrapper(BaseModel):
    """
    Wrapper
    """ # noqa: E501
    all_of: Optional[WrapperAllOf] = Field(default=None, alias="allOf")
    any_of: Optional[WrapperAnyOf] = Field(default=None, alias="anyOf")
    one_of: Optional[WrapperOneOf] = Field(default=None, alias="oneOf")
    __properties: ClassVar[List[str]] = ["allOf", "anyOf", "oneOf"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Wrapper from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of all_of
        if self.all_of:
            _dict['allOf'] = self.all_of.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of any_of
        if self.any_of:
            _dict['anyOf'] = self.any_of.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of one_of
        if self.one_of:
            _dict['oneOf'] = self.one_of.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Wrapper from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allOf": WrapperAllOf.from_dict(obj.get("allOf")) if obj.get("allOf") is not None else None,
            "anyOf": WrapperAnyOf.from_dict(obj.get("anyOf")) if obj.get("anyOf") is not None else None,
            "oneOf": WrapperOneOf.from_dict(obj.get("oneOf")) if obj.get("oneOf") is not None else None
        })
        return _obj

",
  "test_project/models/wrapper_all_of.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.all_of_inline_and_refs import AllOfInlineAndRefs
from test_project.models.all_of_refs import AllOfRefs
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class WrapperAllOf(BaseModel):
    """
    WrapperAllOf
    """ # noqa: E501
    refs: Optional[AllOfRefs] = None
    inline_and_refs: Optional[AllOfInlineAndRefs] = Field(default=None, alias="inlineAndRefs")
    __properties: ClassVar[List[str]] = ["refs", "inlineAndRefs"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of WrapperAllOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of refs
        if self.refs:
            _dict['refs'] = self.refs.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of inline_and_refs
        if self.inline_and_refs:
            _dict['inlineAndRefs'] = self.inline_and_refs.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of WrapperAllOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "refs": AllOfRefs.from_dict(obj.get("refs")) if obj.get("refs") is not None else None,
            "inlineAndRefs": AllOfInlineAndRefs.from_dict(obj.get("inlineAndRefs")) if obj.get("inlineAndRefs") is not None else None
        })
        return _obj

",
  "test_project/models/wrapper_any_of.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.any_of_inline_and_refs import AnyOfInlineAndRefs
from test_project.models.any_of_primitives import AnyOfPrimitives
from test_project.models.any_of_primitives_and_refs import AnyOfPrimitivesAndRefs
from test_project.models.any_of_refs import AnyOfRefs
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class WrapperAnyOf(BaseModel):
    """
    WrapperAnyOf
    """ # noqa: E501
    refs: Optional[AnyOfRefs] = None
    inline_and_refs: Optional[AnyOfInlineAndRefs] = Field(default=None, alias="inlineAndRefs")
    primitives: Optional[AnyOfPrimitives] = None
    primitives_and_refs: Optional[AnyOfPrimitivesAndRefs] = Field(default=None, alias="primitivesAndRefs")
    __properties: ClassVar[List[str]] = ["refs", "inlineAndRefs", "primitives", "primitivesAndRefs"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of WrapperAnyOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of refs
        if self.refs:
            _dict['refs'] = self.refs.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of inline_and_refs
        if self.inline_and_refs:
            _dict['inlineAndRefs'] = self.inline_and_refs.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of primitives
        if self.primitives:
            _dict['primitives'] = self.primitives.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of primitives_and_refs
        if self.primitives_and_refs:
            _dict['primitivesAndRefs'] = self.primitives_and_refs.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of WrapperAnyOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "refs": AnyOfRefs.from_dict(obj.get("refs")) if obj.get("refs") is not None else None,
            "inlineAndRefs": AnyOfInlineAndRefs.from_dict(obj.get("inlineAndRefs")) if obj.get("inlineAndRefs") is not None else None,
            "primitives": AnyOfPrimitives.from_dict(obj.get("primitives")) if obj.get("primitives") is not None else None,
            "primitivesAndRefs": AnyOfPrimitivesAndRefs.from_dict(obj.get("primitivesAndRefs")) if obj.get("primitivesAndRefs") is not None else None
        })
        return _obj

",
  "test_project/models/wrapper_one_of.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.one_of_inline_and_refs import OneOfInlineAndRefs
from test_project.models.one_of_primitives import OneOfPrimitives
from test_project.models.one_of_primitives_and_refs import OneOfPrimitivesAndRefs
from test_project.models.one_of_refs import OneOfRefs
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class WrapperOneOf(BaseModel):
    """
    WrapperOneOf
    """ # noqa: E501
    refs: Optional[OneOfRefs] = None
    inline_and_refs: Optional[OneOfInlineAndRefs] = Field(default=None, alias="inlineAndRefs")
    primitives: Optional[OneOfPrimitives] = None
    primitives_and_refs: Optional[OneOfPrimitivesAndRefs] = Field(default=None, alias="primitivesAndRefs")
    __properties: ClassVar[List[str]] = ["refs", "inlineAndRefs", "primitives", "primitivesAndRefs"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of WrapperOneOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of refs
        if self.refs:
            _dict['refs'] = self.refs.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of inline_and_refs
        if self.inline_and_refs:
            _dict['inlineAndRefs'] = self.inline_and_refs.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of primitives
        if self.primitives:
            _dict['primitives'] = self.primitives.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of primitives_and_refs
        if self.primitives_and_refs:
            _dict['primitivesAndRefs'] = self.primitives_and_refs.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of WrapperOneOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "refs": OneOfRefs.from_dict(obj.get("refs")) if obj.get("refs") is not None else None,
            "inlineAndRefs": OneOfInlineAndRefs.from_dict(obj.get("inlineAndRefs")) if obj.get("inlineAndRefs") is not None else None,
            "primitives": OneOfPrimitives.from_dict(obj.get("primitives")) if obj.get("primitives") is not None else None,
            "primitivesAndRefs": OneOfPrimitivesAndRefs.from_dict(obj.get("primitivesAndRefs")) if obj.get("primitivesAndRefs") is not None else None
        })
        return _obj

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    composite models

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With data-types.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/DataTypes200Response.md
docs/DataTypes200ResponseMyAllOf.md
docs/DataTypes200ResponseMyAnyOf.md
docs/DataTypes200ResponseMyNotNot.md
docs/DataTypes200ResponseMyObject.md
docs/DataTypes200ResponseMyObjectOne.md
docs/DataTypes200ResponseMyObjectOneTwo.md
docs/DataTypes200ResponseMyOneOf.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/data_types200_response.py
test_project/models/data_types200_response_my_all_of.py
test_project/models/data_types200_response_my_any_of.py
test_project/models/data_types200_response_my_not_not.py
test_project/models/data_types200_response_my_object.py
test_project/models/data_types200_response_my_object_one.py
test_project/models/data_types200_response_my_object_one_two.py
test_project/models/data_types200_response_my_one_of.py",
  "README.md": "# Data Types


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.data_types()
        print("The response of DefaultApi->data_types:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->data_types: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**data_types**](docs/DefaultApi.md#data_types) | **GET** /types | 

## Documentation For Models

 - [DataTypes200Response](docs/DataTypes200Response.md)
 - [DataTypes200ResponseMyAllOf](docs/DataTypes200ResponseMyAllOf.md)
 - [DataTypes200ResponseMyAllOfAllOf](docs/DataTypes200ResponseMyAllOfAllOf.md)
 - [DataTypes200ResponseMyAllOfAllOf1](docs/DataTypes200ResponseMyAllOfAllOf1.md)
 - [DataTypes200ResponseMyAnyOf](docs/DataTypes200ResponseMyAnyOf.md)
 - [DataTypes200ResponseMyNotNot](docs/DataTypes200ResponseMyNotNot.md)
 - [DataTypes200ResponseMyObject](docs/DataTypes200ResponseMyObject.md)
 - [DataTypes200ResponseMyObjectOne](docs/DataTypes200ResponseMyObjectOne.md)
 - [DataTypes200ResponseMyObjectOneTwo](docs/DataTypes200ResponseMyObjectOneTwo.md)
 - [DataTypes200ResponseMyOneOf](docs/DataTypes200ResponseMyOneOf.md)
",
  "docs/DataTypes200Response.md": "# DataTypes200Response

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**my_int** | **int** |  | [optional] 
**my_exclusive_int** | **int** |  | [optional] 
**my_string** | **str** |  | [optional] 
**my_string_length** | **str** |  | [optional] 
**my_long_min_string_length** | **str** |  | [optional] 
**my_bool** | **bool** |  | [optional] 
**my_number** | **float** |  | [optional] 
**my_date_array** | **List[date]** |  | [optional] 
**my_email** | **str** |  | [optional] 
**my_url** | **str** |  | [optional] 
**my_hostname** | **str** |  | [optional] 
**my_ipv4** | **str** |  | [optional] 
**my_ipv6** | **str** |  | [optional] 
**my_uuid** | **str** |  | [optional] 
**my_byte** | **str** |  | [optional] 
**my_constrained_byte** | **str** |  | [optional] 
**my_date_time** | **datetime** |  | [optional] 
**my_regex_pattern** | **str** |  | [optional] 
**my_one_of** | [**DataTypes200ResponseMyOneOf**](DataTypes200ResponseMyOneOf.md) |  | [optional] 
**my_any_of** | [**DataTypes200ResponseMyAnyOf**](DataTypes200ResponseMyAnyOf.md) |  | [optional] 
**my_all_of** | [**DataTypes200ResponseMyAllOf**](DataTypes200ResponseMyAllOf.md) |  | [optional] 
**my_not** | **object** |  | [optional] 
**my_not_string** | **object** |  | [optional] 
**my_additional_properties** | **Dict[str, List[int]]** |  | [optional] 
**my_object** | [**DataTypes200ResponseMyObject**](DataTypes200ResponseMyObject.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response import DataTypes200Response

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200Response from a JSON string
data_types200_response_instance = DataTypes200Response.from_json(json)
# print the JSON string representation of the object
print(DataTypes200Response.to_json())

# convert the object into a dict
data_types200_response_dict = data_types200_response_instance.to_dict()
# create an instance of DataTypes200Response from a dict
data_types200_response_form_dict = data_types200_response.from_dict(data_types200_response_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyAllOf.md": "# DataTypes200ResponseMyAllOf

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**first** | **str** |  | [optional] 
**second** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_all_of import DataTypes200ResponseMyAllOf

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyAllOf from a JSON string
data_types200_response_my_all_of_instance = DataTypes200ResponseMyAllOf.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyAllOf.to_json())

# convert the object into a dict
data_types200_response_my_all_of_dict = data_types200_response_my_all_of_instance.to_dict()
# create an instance of DataTypes200ResponseMyAllOf from a dict
data_types200_response_my_all_of_form_dict = data_types200_response_my_all_of.from_dict(data_types200_response_my_all_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyAnyOf.md": "# DataTypes200ResponseMyAnyOf

## Composed Of

This model can be set to any of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
**float** | 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_any_of import DataTypes200ResponseMyAnyOf

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyAnyOf from a JSON string
data_types200_response_my_any_of_instance = DataTypes200ResponseMyAnyOf.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyAnyOf.to_json())

# convert the object into a dict
data_types200_response_my_any_of_dict = data_types200_response_my_any_of_instance.to_dict()
# create an instance of DataTypes200ResponseMyAnyOf from a dict
data_types200_response_my_any_of_form_dict = data_types200_response_my_any_of.from_dict(data_types200_response_my_any_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyNotNot.md": "# DataTypes200ResponseMyNotNot

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**foo** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_not_not import DataTypes200ResponseMyNotNot

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyNotNot from a JSON string
data_types200_response_my_not_not_instance = DataTypes200ResponseMyNotNot.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyNotNot.to_json())

# convert the object into a dict
data_types200_response_my_not_not_dict = data_types200_response_my_not_not_instance.to_dict()
# create an instance of DataTypes200ResponseMyNotNot from a dict
data_types200_response_my_not_not_form_dict = data_types200_response_my_not_not.from_dict(data_types200_response_my_not_not_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyObject.md": "# DataTypes200ResponseMyObject

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**one** | [**DataTypes200ResponseMyObjectOne**](DataTypes200ResponseMyObjectOne.md) |  | [optional] 
**one_string** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_object import DataTypes200ResponseMyObject

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyObject from a JSON string
data_types200_response_my_object_instance = DataTypes200ResponseMyObject.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyObject.to_json())

# convert the object into a dict
data_types200_response_my_object_dict = data_types200_response_my_object_instance.to_dict()
# create an instance of DataTypes200ResponseMyObject from a dict
data_types200_response_my_object_form_dict = data_types200_response_my_object.from_dict(data_types200_response_my_object_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyObjectOne.md": "# DataTypes200ResponseMyObjectOne

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**two_string** | **str** |  | [optional] 
**two** | [**DataTypes200ResponseMyObjectOneTwo**](DataTypes200ResponseMyObjectOneTwo.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_object_one import DataTypes200ResponseMyObjectOne

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyObjectOne from a JSON string
data_types200_response_my_object_one_instance = DataTypes200ResponseMyObjectOne.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyObjectOne.to_json())

# convert the object into a dict
data_types200_response_my_object_one_dict = data_types200_response_my_object_one_instance.to_dict()
# create an instance of DataTypes200ResponseMyObjectOne from a dict
data_types200_response_my_object_one_form_dict = data_types200_response_my_object_one.from_dict(data_types200_response_my_object_one_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyObjectOneTwo.md": "# DataTypes200ResponseMyObjectOneTwo

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**three_string** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_object_one_two import DataTypes200ResponseMyObjectOneTwo

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyObjectOneTwo from a JSON string
data_types200_response_my_object_one_two_instance = DataTypes200ResponseMyObjectOneTwo.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyObjectOneTwo.to_json())

# convert the object into a dict
data_types200_response_my_object_one_two_dict = data_types200_response_my_object_one_two_instance.to_dict()
# create an instance of DataTypes200ResponseMyObjectOneTwo from a dict
data_types200_response_my_object_one_two_form_dict = data_types200_response_my_object_one_two.from_dict(data_types200_response_my_object_one_two_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DataTypes200ResponseMyOneOf.md": "# DataTypes200ResponseMyOneOf

## Composed Of

This model can be set to one of the following types:

Type | Description | Notes
------------- | ------------- | -------------
**str** | 
**float** | 

## Example

\`\`\`python
from test_project.models.data_types200_response_my_one_of import DataTypes200ResponseMyOneOf

# TODO update the JSON string below
json = "{}"
# create an instance of DataTypes200ResponseMyOneOf from a JSON string
data_types200_response_my_one_of_instance = DataTypes200ResponseMyOneOf.from_json(json)
# print the JSON string representation of the object
print(DataTypes200ResponseMyOneOf.to_json())

# convert the object into a dict
data_types200_response_my_one_of_dict = data_types200_response_my_one_of_instance.to_dict()
# create an instance of DataTypes200ResponseMyOneOf from a dict
data_types200_response_my_one_of_form_dict = data_types200_response_my_one_of.from_dict(data_types200_response_my_one_of_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**data_types**](DefaultApi.md#data_types) | **GET** /types | 

# **data_types**
> DataTypes200Response data_types()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.data_types()
        print("The response of DefaultApi->data_types:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->data_types: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**DataTypes200Response**](DataTypes200Response.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.data_types200_response import DataTypes200Response
from test_project.models.data_types200_response_my_all_of import DataTypes200ResponseMyAllOf
from test_project.models.data_types200_response_my_any_of import DataTypes200ResponseMyAnyOf
from test_project.models.data_types200_response_my_not_not import DataTypes200ResponseMyNotNot
from test_project.models.data_types200_response_my_object import DataTypes200ResponseMyObject
from test_project.models.data_types200_response_my_object_one import DataTypes200ResponseMyObjectOne
from test_project.models.data_types200_response_my_object_one_two import DataTypes200ResponseMyObjectOneTwo
from test_project.models.data_types200_response_my_one_of import DataTypes200ResponseMyOneOf
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.data_types200_response import DataTypes200Response

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def data_types(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DataTypes200Response:
        """data_types
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._data_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataTypes200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def data_types_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DataTypes200Response]:
        """data_types
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._data_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataTypes200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def data_types_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """data_types
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._data_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DataTypes200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _data_types_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    data_types: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "data_types": {
        "path": "/types",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class DataTypesRequestParameters(BaseModel):
    """
    Query, path and header parameters for the DataTypes operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> DataTypesRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> DataTypesRequestParameters:
        if obj is None:
            return None
        return DataTypesRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
DataTypesRequestBody = Any

DataTypes200OperationResponse = ApiResponse[Literal[200], DataTypes200Response]

DataTypesOperationResponses = Union[DataTypes200OperationResponse, ]

# Request type for data_types
DataTypesRequest = ApiRequest[DataTypesRequestParameters, DataTypesRequestBody]
DataTypesChainedRequest = ChainedApiRequest[DataTypesRequestParameters, DataTypesRequestBody]

class DataTypesHandlerFunction(Protocol):
    def __call__(self, input: DataTypesRequest, **kwargs) -> DataTypesOperationResponses:
        ...

DataTypesInterceptor = Callable[[DataTypesChainedRequest], DataTypesOperationResponses]

def data_types_handler(_handler: DataTypesHandlerFunction = None, interceptors: List[DataTypesInterceptor] = []):
    """
    Decorator for an api handler for the data_types operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: DataTypesHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = DataTypesRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "data_types",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by data_types_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  data_types: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.data_types200_response import DataTypes200Response
from test_project.models.data_types200_response_my_all_of import DataTypes200ResponseMyAllOf
from test_project.models.data_types200_response_my_any_of import DataTypes200ResponseMyAnyOf
from test_project.models.data_types200_response_my_not_not import DataTypes200ResponseMyNotNot
from test_project.models.data_types200_response_my_object import DataTypes200ResponseMyObject
from test_project.models.data_types200_response_my_object_one import DataTypes200ResponseMyObjectOne
from test_project.models.data_types200_response_my_object_one_two import DataTypes200ResponseMyObjectOneTwo
from test_project.models.data_types200_response_my_one_of import DataTypes200ResponseMyOneOf
",
  "test_project/models/data_types200_response.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.data_types200_response_my_all_of import DataTypes200ResponseMyAllOf
from test_project.models.data_types200_response_my_any_of import DataTypes200ResponseMyAnyOf
from test_project.models.data_types200_response_my_object import DataTypes200ResponseMyObject
from test_project.models.data_types200_response_my_one_of import DataTypes200ResponseMyOneOf
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200Response(BaseModel):
    """
    DataTypes200Response
    """ # noqa: E501
    my_int: Optional[Annotated[int, Field(strict=True, le=3, ge=7)]] = Field(default=None, alias="myInt")
    my_exclusive_int: Optional[Annotated[int, Field(strict=True, lt=3, gt=7)]] = Field(default=None, alias="myExclusiveInt")
    my_string: Optional[StrictStr] = Field(default=None, alias="myString")
    my_string_length: Optional[Annotated[str, Field(strict=True, min_length=4, max_length=5)]] = Field(default=None, alias="myStringLength")
    my_long_min_string_length: Optional[Annotated[str, Field(strict=True, min_length=1000)]] = Field(default=None, alias="myLongMinStringLength")
    my_bool: Optional[StrictBool] = Field(default=None, alias="myBool")
    my_number: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="myNumber")
    my_date_array: Optional[List[date]] = Field(default=None, alias="myDateArray")
    my_email: Optional[StrictStr] = Field(default=None, alias="myEmail")
    my_url: Optional[StrictStr] = Field(default=None, alias="myUrl")
    my_hostname: Optional[StrictStr] = Field(default=None, alias="myHostname")
    my_ipv4: Optional[StrictStr] = Field(default=None, alias="myIpv4")
    my_ipv6: Optional[StrictStr] = Field(default=None, alias="myIpv6")
    my_uuid: Optional[StrictStr] = Field(default=None, alias="myUuid")
    my_byte: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, alias="myByte")
    my_constrained_byte: Optional[Union[Annotated[bytes, Field(strict=True, max_length=42)], Annotated[str, Field(strict=True, max_length=42)]]] = Field(default=None, alias="myConstrainedByte")
    my_date_time: Optional[datetime] = Field(default=None, alias="myDateTime")
    my_regex_pattern: Optional[StrictStr] = Field(default=None, alias="myRegexPattern")
    my_one_of: Optional[DataTypes200ResponseMyOneOf] = Field(default=None, alias="myOneOf")
    my_any_of: Optional[DataTypes200ResponseMyAnyOf] = Field(default=None, alias="myAnyOf")
    my_all_of: Optional[DataTypes200ResponseMyAllOf] = Field(default=None, alias="myAllOf")
    my_not: Optional[Any] = Field(default=None, alias="myNot")
    my_not_string: Optional[Any] = Field(default=None, alias="myNotString")
    my_additional_properties: Optional[Dict[str, Annotated[List[Annotated[int, Field(strict=True, le=10, ge=20)]], Field(strict=True, min_length=2, max_length=5)]]] = Field(default=None, alias="myAdditionalProperties")
    my_object: Optional[DataTypes200ResponseMyObject] = Field(default=None, alias="myObject")
    __properties: ClassVar[List[str]] = ["myInt", "myExclusiveInt", "myString", "myStringLength", "myLongMinStringLength", "myBool", "myNumber", "myDateArray", "myEmail", "myUrl", "myHostname", "myIpv4", "myIpv6", "myUuid", "myByte", "myConstrainedByte", "myDateTime", "myRegexPattern", "myOneOf", "myAnyOf", "myAllOf", "myNot", "myNotString", "myAdditionalProperties", "myObject"]

    @field_validator('my_regex_pattern')
    def my_regex_pattern_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\\d{4}-pattern-[a-z]+$", value):
            raise ValueError(r"must validate the regular expression /^\\d{4}-pattern-[a-z]+$/")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of my_one_of
        if self.my_one_of:
            _dict['myOneOf'] = self.my_one_of.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of my_any_of
        if self.my_any_of:
            _dict['myAnyOf'] = self.my_any_of.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of my_all_of
        if self.my_all_of:
            _dict['myAllOf'] = self.my_all_of.to_dict()
        # override the default output from pydantic by calling \`to_dict()\` of my_object
        if self.my_object:
            _dict['myObject'] = self.my_object.to_dict()
        # set to None if my_not (nullable) is None
        # and model_fields_set contains the field
        if self.my_not is None and "my_not" in self.model_fields_set:
            _dict['myNot'] = None

        # set to None if my_not_string (nullable) is None
        # and model_fields_set contains the field
        if self.my_not_string is None and "my_not_string" in self.model_fields_set:
            _dict['myNotString'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200Response from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "myInt": obj.get("myInt"),
            "myExclusiveInt": obj.get("myExclusiveInt"),
            "myString": obj.get("myString"),
            "myStringLength": obj.get("myStringLength"),
            "myLongMinStringLength": obj.get("myLongMinStringLength"),
            "myBool": obj.get("myBool"),
            "myNumber": obj.get("myNumber"),
            "myDateArray": obj.get("myDateArray"),
            "myEmail": obj.get("myEmail"),
            "myUrl": obj.get("myUrl"),
            "myHostname": obj.get("myHostname"),
            "myIpv4": obj.get("myIpv4"),
            "myIpv6": obj.get("myIpv6"),
            "myUuid": obj.get("myUuid"),
            "myByte": obj.get("myByte"),
            "myConstrainedByte": obj.get("myConstrainedByte"),
            "myDateTime": obj.get("myDateTime"),
            "myRegexPattern": obj.get("myRegexPattern"),
            "myOneOf": DataTypes200ResponseMyOneOf.from_dict(obj.get("myOneOf")) if obj.get("myOneOf") is not None else None,
            "myAnyOf": DataTypes200ResponseMyAnyOf.from_dict(obj.get("myAnyOf")) if obj.get("myAnyOf") is not None else None,
            "myAllOf": DataTypes200ResponseMyAllOf.from_dict(obj.get("myAllOf")) if obj.get("myAllOf") is not None else None,
            "myNot": obj.get("myNot"),
            "myNotString": obj.get("myNotString"),
            "myAdditionalProperties": obj.get("myAdditionalProperties"),
            "myObject": DataTypes200ResponseMyObject.from_dict(obj.get("myObject")) if obj.get("myObject") is not None else None
        })
        return _obj

",
  "test_project/models/data_types200_response_my_all_of.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200ResponseMyAllOf(BaseModel):
    """
    DataTypes200ResponseMyAllOf
    """ # noqa: E501
    first: Optional[StrictStr] = None
    second: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["first", "second"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200ResponseMyAllOf from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200ResponseMyAllOf from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "first": obj.get("first"),
            "second": obj.get("second")
        })
        return _obj

",
  "test_project/models/data_types200_response_my_any_of.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

DATATYPES200RESPONSEMYANYOF_ANY_OF_SCHEMAS = ["str", "float"]

class DataTypes200ResponseMyAnyOf(BaseModel):
    """
    DataTypes200ResponseMyAnyOf
    """ # noqa: E501
    # data type: str
    anyof_schema_1_validator: Optional[StrictStr] = None
    # data type: float
    anyof_schema_2_validator: Optional[Union[StrictFloat, StrictInt]] = None
    if TYPE_CHECKING:
        actual_instance: Optional[Union[str, float]] = None
    else:
        actual_instance: Any = None
    any_of_schemas: List[str] = Literal[DATATYPES200RESPONSEMYANYOF_ANY_OF_SCHEMAS]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_anyof(cls, v):
        instance = DataTypes200ResponseMyAnyOf.model_construct()
        error_messages = []
        # validate data type: str
        try:
            instance.anyof_schema_1_validator = v
            return v
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: float
        try:
            instance.anyof_schema_2_validator = v
            return v
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        if error_messages:
            # no match
            raise ValueError("No match found when setting the actual_instance in DataTypes200ResponseMyAnyOf with anyOf schemas: str, float. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        # deserialize data into str
        try:
            # validation
            instance.anyof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.anyof_schema_1_validator
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into float
        try:
            # validation
            instance.anyof_schema_2_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.anyof_schema_2_validator
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if error_messages:
            # no match
            raise ValueError("No match found when deserializing the JSON string into DataTypes200ResponseMyAnyOf with anyOf schemas: str, float. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/models/data_types200_response_my_not_not.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200ResponseMyNotNot(BaseModel):
    """
    DataTypes200ResponseMyNotNot
    """ # noqa: E501
    foo: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["foo"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200ResponseMyNotNot from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200ResponseMyNotNot from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "foo": obj.get("foo")
        })
        return _obj

",
  "test_project/models/data_types200_response_my_object.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.data_types200_response_my_object_one import DataTypes200ResponseMyObjectOne
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200ResponseMyObject(BaseModel):
    """
    DataTypes200ResponseMyObject
    """ # noqa: E501
    one: Optional[DataTypes200ResponseMyObjectOne] = None
    one_string: Optional[StrictStr] = Field(default=None, alias="oneString")
    __properties: ClassVar[List[str]] = ["one", "oneString"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200ResponseMyObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of one
        if self.one:
            _dict['one'] = self.one.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200ResponseMyObject from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "one": DataTypes200ResponseMyObjectOne.from_dict(obj.get("one")) if obj.get("one") is not None else None,
            "oneString": obj.get("oneString")
        })
        return _obj

",
  "test_project/models/data_types200_response_my_object_one.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.data_types200_response_my_object_one_two import DataTypes200ResponseMyObjectOneTwo
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200ResponseMyObjectOne(BaseModel):
    """
    DataTypes200ResponseMyObjectOne
    """ # noqa: E501
    two_string: Optional[StrictStr] = Field(default=None, alias="twoString")
    two: Optional[DataTypes200ResponseMyObjectOneTwo] = None
    __properties: ClassVar[List[str]] = ["twoString", "two"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200ResponseMyObjectOne from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of two
        if self.two:
            _dict['two'] = self.two.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200ResponseMyObjectOne from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "twoString": obj.get("twoString"),
            "two": DataTypes200ResponseMyObjectOneTwo.from_dict(obj.get("two")) if obj.get("two") is not None else None
        })
        return _obj

",
  "test_project/models/data_types200_response_my_object_one_two.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DataTypes200ResponseMyObjectOneTwo(BaseModel):
    """
    DataTypes200ResponseMyObjectOneTwo
    """ # noqa: E501
    three_string: Optional[StrictStr] = Field(default=None, alias="threeString")
    __properties: ClassVar[List[str]] = ["threeString"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DataTypes200ResponseMyObjectOneTwo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DataTypes200ResponseMyObjectOneTwo from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "threeString": obj.get("threeString")
        })
        return _obj

",
  "test_project/models/data_types200_response_my_one_of.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

DATATYPES200RESPONSEMYONEOF_ONE_OF_SCHEMAS = ["str", "float"]

class DataTypes200ResponseMyOneOf(BaseModel):
    """
    DataTypes200ResponseMyOneOf
    """ # noqa: E501
    # data type: str
    oneof_schema_1_validator: Optional[StrictStr] = None
    # data type: float
    oneof_schema_2_validator: Optional[Union[StrictFloat, StrictInt]] = None
    actual_instance: Optional[Union[str, float]] = None
    one_of_schemas: List[str] = Literal["str", "float"]

    model_config = {
        "validate_assignment": True
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set \`actual_instance\`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = DataTypes200ResponseMyOneOf.model_construct()
        error_messages = []
        match = 0
        # validate data type: str
        try:
            instance.oneof_schema_1_validator = v
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # validate data type: float
        try:
            instance.oneof_schema_2_validator = v
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting \`actual_instance\` in DataTypes200ResponseMyOneOf with oneOf schemas: str, float. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting \`actual_instance\` in DataTypes200ResponseMyOneOf with oneOf schemas: str, float. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into str
        try:
            # validation
            instance.oneof_schema_1_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.oneof_schema_1_validator
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into float
        try:
            # validation
            instance.oneof_schema_2_validator = json.loads(json_str)
            # assign value to actual_instance
            instance.actual_instance = instance.oneof_schema_2_validator
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into DataTypes200ResponseMyOneOf with oneOf schemas: str, float. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into DataTypes200ResponseMyOneOf with oneOf schemas: str, float. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    Data Types

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With default-response.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/SayHelloResponseContent.md
docs/ServiceUnavailableErrorResponseContent.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/say_hello_response_content.py
test_project/models/service_unavailable_error_response_content.py",
  "README.md": "# My API
See https://github.com/aws/aws-pdk/issues/841

This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    name = "cedo laborum articulus" # str | 

    try:
        api_response = api_instance.say_hello(name)
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**say_hello**](docs/DefaultApi.md#say_hello) | **GET** /hello | 

## Documentation For Models

 - [SayHelloResponseContent](docs/SayHelloResponseContent.md)
 - [ServiceUnavailableErrorResponseContent](docs/ServiceUnavailableErrorResponseContent.md)
",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**say_hello**](DefaultApi.md#say_hello) | **GET** /hello | 

# **say_hello**
> SayHelloResponseContent say_hello(name)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    name = "cedo laborum articulus" # str | 

    try:
        api_response = api_instance.say_hello(name)
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **name** | **str** |  | 

### Return type

[**SayHelloResponseContent**](SayHelloResponseContent.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |
**0** | An error due to the client not being authorized to access the resource |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/SayHelloResponseContent.md": "# SayHelloResponseContent

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** |  | [optional] 
**message** | **str** |  | 

## Example

\`\`\`python
from test_project.models.say_hello_response_content import SayHelloResponseContent

# TODO update the JSON string below
json = "{}"
# create an instance of SayHelloResponseContent from a JSON string
say_hello_response_content_instance = SayHelloResponseContent.from_json(json)
# print the JSON string representation of the object
print(SayHelloResponseContent.to_json())

# convert the object into a dict
say_hello_response_content_dict = say_hello_response_content_instance.to_dict()
# create an instance of SayHelloResponseContent from a dict
say_hello_response_content_form_dict = say_hello_response_content.from_dict(say_hello_response_content_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/ServiceUnavailableErrorResponseContent.md": "# ServiceUnavailableErrorResponseContent

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**message** | **str** |  | 

## Example

\`\`\`python
from test_project.models.service_unavailable_error_response_content import ServiceUnavailableErrorResponseContent

# TODO update the JSON string below
json = "{}"
# create an instance of ServiceUnavailableErrorResponseContent from a JSON string
service_unavailable_error_response_content_instance = ServiceUnavailableErrorResponseContent.from_json(json)
# print the JSON string representation of the object
print(ServiceUnavailableErrorResponseContent.to_json())

# convert the object into a dict
service_unavailable_error_response_content_dict = service_unavailable_error_response_content_instance.to_dict()
# create an instance of ServiceUnavailableErrorResponseContent from a dict
service_unavailable_error_response_content_form_dict = service_unavailable_error_response_content.from_dict(service_unavailable_error_response_content_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.say_hello_response_content import SayHelloResponseContent
from test_project.models.service_unavailable_error_response_content import ServiceUnavailableErrorResponseContent
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.say_hello_response_content import SayHelloResponseContent
from test_project.models.service_unavailable_error_response_content import ServiceUnavailableErrorResponseContent

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def say_hello(
        self,
        name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SayHelloResponseContent:
        """say_hello
        :param name: (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SayHelloResponseContent",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def say_hello_with_http_info(
        self,
        name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SayHelloResponseContent]:
        """say_hello
        :param name: (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SayHelloResponseContent",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def say_hello_without_preload_content(
        self,
        name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """say_hello
        :param name: (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SayHelloResponseContent",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _say_hello_serialize(
        self,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            _query_params.append(('name', name))
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hello',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    say_hello: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "say_hello": {
        "path": "/hello",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class SayHelloRequestParameters(BaseModel):
    """
    Query, path and header parameters for the SayHello operation
    """
    name: StrictStr

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SayHelloRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> SayHelloRequestParameters:
        if obj is None:
            return None
        return SayHelloRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
SayHelloRequestBody = Any

SayHello200OperationResponse = ApiResponse[Literal[200], SayHelloResponseContent]
SayHello0OperationResponse = ApiResponse[Literal[0], ServiceUnavailableErrorResponseContent]

SayHelloOperationResponses = Union[SayHello200OperationResponse, SayHello0OperationResponse, ]

# Request type for say_hello
SayHelloRequest = ApiRequest[SayHelloRequestParameters, SayHelloRequestBody]
SayHelloChainedRequest = ChainedApiRequest[SayHelloRequestParameters, SayHelloRequestBody]

class SayHelloHandlerFunction(Protocol):
    def __call__(self, input: SayHelloRequest, **kwargs) -> SayHelloOperationResponses:
        ...

SayHelloInterceptor = Callable[[SayHelloChainedRequest], SayHelloOperationResponses]

def say_hello_handler(_handler: SayHelloHandlerFunction = None, interceptors: List[SayHelloInterceptor] = []):
    """
    Decorator for an api handler for the say_hello operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: SayHelloHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                if status_code == 0 and "ServiceUnavailableErrorResponseContent".endswith("ResponseContent"):
                    headers_for_status["x-amzn-errortype"] = "ServiceUnavailableErrorResponseContent"[:-len("ResponseContent")]
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = SayHelloRequestParameters.from_dict({
                    "name": coerce_parameter("name", "str", raw_string_parameters, raw_string_array_parameters, True),
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "say_hello",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()
            elif response.status_code == 0:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by say_hello_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  say_hello: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.say_hello_response_content import SayHelloResponseContent
from test_project.models.service_unavailable_error_response_content import ServiceUnavailableErrorResponseContent
",
  "test_project/models/say_hello_response_content.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class SayHelloResponseContent(BaseModel):
    """
    SayHelloResponseContent
    """ # noqa: E501
    id: Optional[StrictStr] = None
    message: StrictStr
    __properties: ClassVar[List[str]] = ["id", "message"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of SayHelloResponseContent from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of SayHelloResponseContent from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "message": obj.get("message")
        })
        return _obj

",
  "test_project/models/service_unavailable_error_response_content.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ServiceUnavailableErrorResponseContent(BaseModel):
    """
    ServiceUnavailableErrorResponseContent
    """ # noqa: E501
    message: StrictStr
    __properties: ClassVar[List[str]] = ["message"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ServiceUnavailableErrorResponseContent from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ServiceUnavailableErrorResponseContent from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "message": obj.get("message")
        })
        return _obj

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    My API

    See https://github.com/aws/aws-pdk/issues/841

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With edge-cases.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/InlineEnum200Response.md
docs/InlineEnum200ResponseCategoryEnum.md
docs/InlineRequestBodyRequestContent.md
docs/MyEnum.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/inline_enum200_response.py
test_project/models/inline_enum200_response_category_enum.py
test_project/models/inline_request_body_request_content.py
test_project/models/my_enum.py",
  "README.md": "# Edge Cases


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    my_string_array_request_params = [] # List[str] |  (optional)
    my_enum_array_request_params = [] # List[MyEnum] |  (optional)
    my_integer_array_request_params = [2436284417048576,6600606720458752,2769288930787328] # List[int] |  (optional)
    my_long_array_request_params = [3479256564760576,857015102472192,5661035377721344] # List[int] |  (optional)
    my_int32_array_request_params = [] # List[int] |  (optional)
    my_number_array_request_params = [0.1599486346822232,0.4432248624507338,0.8626475473865867] # List[float] |  (optional)
    my_float_array_request_params = [0.7941185790114105,0.005342561984434724,0.36126157245598733] # List[float] |  (optional)
    my_double_array_request_params = [0.3810686601791531] # List[float] |  (optional)
    my_enum_request_param = test_project.MyEnum() # MyEnum |  (optional)

    try:
        api_instance.array_request_parameters(my_string_array_request_params=my_string_array_request_params, my_enum_array_request_params=my_enum_array_request_params, my_integer_array_request_params=my_integer_array_request_params, my_long_array_request_params=my_long_array_request_params, my_int32_array_request_params=my_int32_array_request_params, my_number_array_request_params=my_number_array_request_params, my_float_array_request_params=my_float_array_request_params, my_double_array_request_params=my_double_array_request_params, my_enum_request_param=my_enum_request_param)
    except ApiException as e:
        print("Exception when calling DefaultApi->array_request_parameters: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**array_request_parameters**](docs/DefaultApi.md#array_request_parameters) | **GET** /array-request-parameters | 
*DefaultApi* | [**inline_enum**](docs/DefaultApi.md#inline_enum) | **GET** /inline-enum | 
*DefaultApi* | [**inline_request_body**](docs/DefaultApi.md#inline_request_body) | **POST** /inline-request-body | 
*DefaultApi* | [**reserved_keywords**](docs/DefaultApi.md#reserved_keywords) | **GET** /reserved-keywords | 

## Documentation For Models

 - [InlineEnum200Response](docs/InlineEnum200Response.md)
 - [InlineEnum200ResponseCategoryEnum](docs/InlineEnum200ResponseCategoryEnum.md)
 - [InlineRequestBodyRequestContent](docs/InlineRequestBodyRequestContent.md)
 - [MyEnum](docs/MyEnum.md)
",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**array_request_parameters**](DefaultApi.md#array_request_parameters) | **GET** /array-request-parameters | 
[**inline_enum**](DefaultApi.md#inline_enum) | **GET** /inline-enum | 
[**inline_request_body**](DefaultApi.md#inline_request_body) | **POST** /inline-request-body | 
[**reserved_keywords**](DefaultApi.md#reserved_keywords) | **GET** /reserved-keywords | 

# **array_request_parameters**
> array_request_parameters(my_string_array_request_params=my_string_array_request_params, my_enum_array_request_params=my_enum_array_request_params, my_integer_array_request_params=my_integer_array_request_params, my_long_array_request_params=my_long_array_request_params, my_int32_array_request_params=my_int32_array_request_params, my_number_array_request_params=my_number_array_request_params, my_float_array_request_params=my_float_array_request_params, my_double_array_request_params=my_double_array_request_params, my_enum_request_param=my_enum_request_param)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    my_string_array_request_params = [] # List[str] |  (optional)
    my_enum_array_request_params = [] # List[MyEnum] |  (optional)
    my_integer_array_request_params = [2436284417048576,6600606720458752,2769288930787328] # List[int] |  (optional)
    my_long_array_request_params = [3479256564760576,857015102472192,5661035377721344] # List[int] |  (optional)
    my_int32_array_request_params = [] # List[int] |  (optional)
    my_number_array_request_params = [0.1599486346822232,0.4432248624507338,0.8626475473865867] # List[float] |  (optional)
    my_float_array_request_params = [0.7941185790114105,0.005342561984434724,0.36126157245598733] # List[float] |  (optional)
    my_double_array_request_params = [0.3810686601791531] # List[float] |  (optional)
    my_enum_request_param = test_project.MyEnum() # MyEnum |  (optional)

    try:
        api_instance.array_request_parameters(my_string_array_request_params=my_string_array_request_params, my_enum_array_request_params=my_enum_array_request_params, my_integer_array_request_params=my_integer_array_request_params, my_long_array_request_params=my_long_array_request_params, my_int32_array_request_params=my_int32_array_request_params, my_number_array_request_params=my_number_array_request_params, my_float_array_request_params=my_float_array_request_params, my_double_array_request_params=my_double_array_request_params, my_enum_request_param=my_enum_request_param)
    except ApiException as e:
        print("Exception when calling DefaultApi->array_request_parameters: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **my_string_array_request_params** | **List[str]** |  | [optional] 
 **my_enum_array_request_params** | **List[MyEnum]** |  | [optional] 
 **my_integer_array_request_params** | **List[int]** |  | [optional] 
 **my_long_array_request_params** | **List[int]** |  | [optional] 
 **my_int32_array_request_params** | **List[int]** |  | [optional] 
 **my_number_array_request_params** | **List[float]** |  | [optional] 
 **my_float_array_request_params** | **List[float]** |  | [optional] 
 **my_double_array_request_params** | **List[float]** |  | [optional] 
 **my_enum_request_param** | [**MyEnum**](MyEnum.md) |  | [optional] 

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **inline_enum**
> InlineEnum200Response inline_enum()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.inline_enum()
        print("The response of DefaultApi->inline_enum:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->inline_enum: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**InlineEnum200Response**](InlineEnum200Response.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **inline_request_body**
> inline_request_body(inline_request_body_request_content=inline_request_body_request_content)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    inline_request_body_request_content = test_project.InlineRequestBodyRequestContent() # InlineRequestBodyRequestContent |  (optional)

    try:
        api_instance.inline_request_body(inline_request_body_request_content=inline_request_body_request_content)
    except ApiException as e:
        print("Exception when calling DefaultApi->inline_request_body: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **inline_request_body_request_content** | [**InlineRequestBodyRequestContent**](InlineRequestBodyRequestContent.md) |  | [optional] 

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: application/json
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**204** | ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **reserved_keywords**
> reserved_keywords(var_with=var_with, var_if=var_if, var_class=var_class)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    var_with = "cedo laborum articulus" # str |  (optional)
    var_if = "benevolentia chirographum illo" # str |  (optional)
    var_class = "degenero ademptio commemoro" # str |  (optional)

    try:
        api_instance.reserved_keywords(var_with=var_with, var_if=var_if, var_class=var_class)
    except ApiException as e:
        print("Exception when calling DefaultApi->reserved_keywords: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **var_with** | **str** |  | [optional] 
 **var_if** | **str** |  | [optional] 
 **var_class** | **str** |  | [optional] 

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/InlineEnum200Response.md": "# InlineEnum200Response

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**category** | [**InlineEnum200ResponseCategoryEnum**](InlineEnum200ResponseCategoryEnum.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.inline_enum200_response import InlineEnum200Response

# TODO update the JSON string below
json = "{}"
# create an instance of InlineEnum200Response from a JSON string
inline_enum200_response_instance = InlineEnum200Response.from_json(json)
# print the JSON string representation of the object
print(InlineEnum200Response.to_json())

# convert the object into a dict
inline_enum200_response_dict = inline_enum200_response_instance.to_dict()
# create an instance of InlineEnum200Response from a dict
inline_enum200_response_form_dict = inline_enum200_response.from_dict(inline_enum200_response_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/InlineEnum200ResponseCategoryEnum.md": "# InlineEnum200ResponseCategoryEnum

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------

[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/InlineRequestBodyRequestContent.md": "# InlineRequestBodyRequestContent

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**some_property** | **str** |  | 

## Example

\`\`\`python
from test_project.models.inline_request_body_request_content import InlineRequestBodyRequestContent

# TODO update the JSON string below
json = "{}"
# create an instance of InlineRequestBodyRequestContent from a JSON string
inline_request_body_request_content_instance = InlineRequestBodyRequestContent.from_json(json)
# print the JSON string representation of the object
print(InlineRequestBodyRequestContent.to_json())

# convert the object into a dict
inline_request_body_request_content_dict = inline_request_body_request_content_instance.to_dict()
# create an instance of InlineRequestBodyRequestContent from a dict
inline_request_body_request_content_form_dict = inline_request_body_request_content.from_dict(inline_request_body_request_content_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/MyEnum.md": "# MyEnum

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------

[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.inline_enum200_response import InlineEnum200Response
from test_project.models.inline_enum200_response_category_enum import InlineEnum200ResponseCategoryEnum
from test_project.models.inline_request_body_request_content import InlineRequestBodyRequestContent
from test_project.models.my_enum import MyEnum
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.inline_enum200_response import InlineEnum200Response
from test_project.models.inline_request_body_request_content import InlineRequestBodyRequestContent
from test_project.models.my_enum import MyEnum

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def array_request_parameters(
        self,
        my_string_array_request_params: Optional[List[StrictStr]] = None,
        my_enum_array_request_params: Optional[List[MyEnum]] = None,
        my_integer_array_request_params: Optional[List[StrictInt]] = None,
        my_long_array_request_params: Optional[List[StrictInt]] = None,
        my_int32_array_request_params: Optional[List[StrictInt]] = None,
        my_number_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_float_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_double_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_enum_request_param: Optional[MyEnum] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """array_request_parameters
        :param my_string_array_request_params: (optional)
        :type my_string_array_request_params: List[str], optional
        :param my_enum_array_request_params: (optional)
        :type my_enum_array_request_params: List[MyEnum], optional
        :param my_integer_array_request_params: (optional)
        :type my_integer_array_request_params: List[int], optional
        :param my_long_array_request_params: (optional)
        :type my_long_array_request_params: List[int], optional
        :param my_int32_array_request_params: (optional)
        :type my_int32_array_request_params: List[int], optional
        :param my_number_array_request_params: (optional)
        :type my_number_array_request_params: List[float], optional
        :param my_float_array_request_params: (optional)
        :type my_float_array_request_params: List[float], optional
        :param my_double_array_request_params: (optional)
        :type my_double_array_request_params: List[float], optional
        :param my_enum_request_param: (optional)
        :type my_enum_request_param: MyEnum, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._array_request_parameters_serialize(
            my_string_array_request_params=my_string_array_request_params,
            my_enum_array_request_params=my_enum_array_request_params,
            my_integer_array_request_params=my_integer_array_request_params,
            my_long_array_request_params=my_long_array_request_params,
            my_int32_array_request_params=my_int32_array_request_params,
            my_number_array_request_params=my_number_array_request_params,
            my_float_array_request_params=my_float_array_request_params,
            my_double_array_request_params=my_double_array_request_params,
            my_enum_request_param=my_enum_request_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def array_request_parameters_with_http_info(
        self,
        my_string_array_request_params: Optional[List[StrictStr]] = None,
        my_enum_array_request_params: Optional[List[MyEnum]] = None,
        my_integer_array_request_params: Optional[List[StrictInt]] = None,
        my_long_array_request_params: Optional[List[StrictInt]] = None,
        my_int32_array_request_params: Optional[List[StrictInt]] = None,
        my_number_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_float_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_double_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_enum_request_param: Optional[MyEnum] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """array_request_parameters
        :param my_string_array_request_params: (optional)
        :type my_string_array_request_params: List[str], optional
        :param my_enum_array_request_params: (optional)
        :type my_enum_array_request_params: List[MyEnum], optional
        :param my_integer_array_request_params: (optional)
        :type my_integer_array_request_params: List[int], optional
        :param my_long_array_request_params: (optional)
        :type my_long_array_request_params: List[int], optional
        :param my_int32_array_request_params: (optional)
        :type my_int32_array_request_params: List[int], optional
        :param my_number_array_request_params: (optional)
        :type my_number_array_request_params: List[float], optional
        :param my_float_array_request_params: (optional)
        :type my_float_array_request_params: List[float], optional
        :param my_double_array_request_params: (optional)
        :type my_double_array_request_params: List[float], optional
        :param my_enum_request_param: (optional)
        :type my_enum_request_param: MyEnum, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._array_request_parameters_serialize(
            my_string_array_request_params=my_string_array_request_params,
            my_enum_array_request_params=my_enum_array_request_params,
            my_integer_array_request_params=my_integer_array_request_params,
            my_long_array_request_params=my_long_array_request_params,
            my_int32_array_request_params=my_int32_array_request_params,
            my_number_array_request_params=my_number_array_request_params,
            my_float_array_request_params=my_float_array_request_params,
            my_double_array_request_params=my_double_array_request_params,
            my_enum_request_param=my_enum_request_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def array_request_parameters_without_preload_content(
        self,
        my_string_array_request_params: Optional[List[StrictStr]] = None,
        my_enum_array_request_params: Optional[List[MyEnum]] = None,
        my_integer_array_request_params: Optional[List[StrictInt]] = None,
        my_long_array_request_params: Optional[List[StrictInt]] = None,
        my_int32_array_request_params: Optional[List[StrictInt]] = None,
        my_number_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_float_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_double_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        my_enum_request_param: Optional[MyEnum] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """array_request_parameters
        :param my_string_array_request_params: (optional)
        :type my_string_array_request_params: List[str], optional
        :param my_enum_array_request_params: (optional)
        :type my_enum_array_request_params: List[MyEnum], optional
        :param my_integer_array_request_params: (optional)
        :type my_integer_array_request_params: List[int], optional
        :param my_long_array_request_params: (optional)
        :type my_long_array_request_params: List[int], optional
        :param my_int32_array_request_params: (optional)
        :type my_int32_array_request_params: List[int], optional
        :param my_number_array_request_params: (optional)
        :type my_number_array_request_params: List[float], optional
        :param my_float_array_request_params: (optional)
        :type my_float_array_request_params: List[float], optional
        :param my_double_array_request_params: (optional)
        :type my_double_array_request_params: List[float], optional
        :param my_enum_request_param: (optional)
        :type my_enum_request_param: MyEnum, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._array_request_parameters_serialize(
            my_string_array_request_params=my_string_array_request_params,
            my_enum_array_request_params=my_enum_array_request_params,
            my_integer_array_request_params=my_integer_array_request_params,
            my_long_array_request_params=my_long_array_request_params,
            my_int32_array_request_params=my_int32_array_request_params,
            my_number_array_request_params=my_number_array_request_params,
            my_float_array_request_params=my_float_array_request_params,
            my_double_array_request_params=my_double_array_request_params,
            my_enum_request_param=my_enum_request_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _array_request_parameters_serialize(
        self,
        my_string_array_request_params,
        my_enum_array_request_params,
        my_integer_array_request_params,
        my_long_array_request_params,
        my_int32_array_request_params,
        my_number_array_request_params,
        my_float_array_request_params,
        my_double_array_request_params,
        my_enum_request_param,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            'my-string-array-request-params': 'multi',
            'my-enum-array-request-params': 'multi',
            'my-integer-array-request-params': 'multi',
            'my-long-array-request-params': 'multi',
            'my-int32-array-request-params': 'multi',
            'my-number-array-request-params': 'multi',
            'my-float-array-request-params': 'multi',
            'my-double-array-request-params': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if my_string_array_request_params is not None:
            _query_params.append(('my-string-array-request-params', my_string_array_request_params))
        if my_enum_array_request_params is not None:
            _query_params.append(('my-enum-array-request-params', my_enum_array_request_params))
        if my_integer_array_request_params is not None:
            _query_params.append(('my-integer-array-request-params', my_integer_array_request_params))
        if my_long_array_request_params is not None:
            _query_params.append(('my-long-array-request-params', my_long_array_request_params))
        if my_int32_array_request_params is not None:
            _query_params.append(('my-int32-array-request-params', my_int32_array_request_params))
        if my_number_array_request_params is not None:
            _query_params.append(('my-number-array-request-params', my_number_array_request_params))
        if my_float_array_request_params is not None:
            _query_params.append(('my-float-array-request-params', my_float_array_request_params))
        if my_double_array_request_params is not None:
            _query_params.append(('my-double-array-request-params', my_double_array_request_params))
        if my_enum_request_param is not None:
            _query_params.append(('my-enum-request-param', my_enum_request_param))
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/array-request-parameters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def inline_enum(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> InlineEnum200Response:
        """inline_enum
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_enum_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InlineEnum200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inline_enum_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[InlineEnum200Response]:
        """inline_enum
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_enum_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InlineEnum200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inline_enum_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inline_enum
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_enum_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InlineEnum200Response"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inline_enum_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inline-enum',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def inline_request_body(
        self,
        inline_request_body_request_content: Optional[InlineRequestBodyRequestContent] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inline_request_body
        :param inline_request_body_request_content: (optional)
        :type inline_request_body_request_content: InlineRequestBodyRequestContent, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_request_body_serialize(
            inline_request_body_request_content=inline_request_body_request_content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inline_request_body_with_http_info(
        self,
        inline_request_body_request_content: Optional[InlineRequestBodyRequestContent] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inline_request_body
        :param inline_request_body_request_content: (optional)
        :type inline_request_body_request_content: InlineRequestBodyRequestContent, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_request_body_serialize(
            inline_request_body_request_content=inline_request_body_request_content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inline_request_body_without_preload_content(
        self,
        inline_request_body_request_content: Optional[InlineRequestBodyRequestContent] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inline_request_body
        :param inline_request_body_request_content: (optional)
        :type inline_request_body_request_content: InlineRequestBodyRequestContent, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inline_request_body_serialize(
            inline_request_body_request_content=inline_request_body_request_content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inline_request_body_serialize(
        self,
        inline_request_body_request_content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inline_request_body_request_content is not None:
            _body_params = inline_request_body_request_content



        # set the HTTP header \`Content-Type\`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inline-request-body',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def reserved_keywords(
        self,
        var_with: Optional[StrictStr] = None,
        var_if: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """reserved_keywords
        :param var_with: (optional)
        :type var_with: str, optional
        :param var_if: (optional)
        :type var_if: str, optional
        :param var_class: (optional)
        :type var_class: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reserved_keywords_serialize(
            var_with=var_with,
            var_if=var_if,
            var_class=var_class,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reserved_keywords_with_http_info(
        self,
        var_with: Optional[StrictStr] = None,
        var_if: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """reserved_keywords
        :param var_with: (optional)
        :type var_with: str, optional
        :param var_if: (optional)
        :type var_if: str, optional
        :param var_class: (optional)
        :type var_class: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reserved_keywords_serialize(
            var_with=var_with,
            var_if=var_if,
            var_class=var_class,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reserved_keywords_without_preload_content(
        self,
        var_with: Optional[StrictStr] = None,
        var_if: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reserved_keywords
        :param var_with: (optional)
        :type var_with: str, optional
        :param var_if: (optional)
        :type var_if: str, optional
        :param var_class: (optional)
        :type var_class: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reserved_keywords_serialize(
            var_with=var_with,
            var_if=var_if,
            var_class=var_class,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reserved_keywords_serialize(
        self,
        var_with,
        var_if,
        var_class,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if var_with is not None:
            _query_params.append(('with', var_with))
        if var_if is not None:
            _query_params.append(('if', var_if))
        if var_class is not None:
            _query_params.append(('class', var_class))
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/reserved-keywords',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    array_request_parameters: T
    inline_enum: T
    inline_request_body: T
    reserved_keywords: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "array_request_parameters": {
        "path": "/array-request-parameters",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "inline_enum": {
        "path": "/inline-enum",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "inline_request_body": {
        "path": "/inline-request-body",
        "method": "POST",
        "contentTypes": ["application/json"]
    },
    "reserved_keywords": {
        "path": "/reserved-keywords",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class ArrayRequestParametersRequestParameters(BaseModel):
    """
    Query, path and header parameters for the ArrayRequestParameters operation
    """
    my_string_array_request_params: Optional[List[StrictStr]]
    my_enum_array_request_params: Optional[List[MyEnum]]
    my_integer_array_request_params: Optional[List[StrictInt]]
    my_long_array_request_params: Optional[List[StrictInt]]
    my_int32_array_request_params: Optional[List[StrictInt]]
    my_number_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]]
    my_float_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]]
    my_double_array_request_params: Optional[List[Union[StrictFloat, StrictInt]]]
    my_enum_request_param: Optional[MyEnum]

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ArrayRequestParametersRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> ArrayRequestParametersRequestParameters:
        if obj is None:
            return None
        return ArrayRequestParametersRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
ArrayRequestParametersRequestBody = Any

ArrayRequestParameters200OperationResponse = ApiResponse[Literal[200], None]

ArrayRequestParametersOperationResponses = Union[ArrayRequestParameters200OperationResponse, ]

# Request type for array_request_parameters
ArrayRequestParametersRequest = ApiRequest[ArrayRequestParametersRequestParameters, ArrayRequestParametersRequestBody]
ArrayRequestParametersChainedRequest = ChainedApiRequest[ArrayRequestParametersRequestParameters, ArrayRequestParametersRequestBody]

class ArrayRequestParametersHandlerFunction(Protocol):
    def __call__(self, input: ArrayRequestParametersRequest, **kwargs) -> ArrayRequestParametersOperationResponses:
        ...

ArrayRequestParametersInterceptor = Callable[[ArrayRequestParametersChainedRequest], ArrayRequestParametersOperationResponses]

def array_request_parameters_handler(_handler: ArrayRequestParametersHandlerFunction = None, interceptors: List[ArrayRequestParametersInterceptor] = []):
    """
    Decorator for an api handler for the array_request_parameters operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: ArrayRequestParametersHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = ArrayRequestParametersRequestParameters.from_dict({
                    "my_string_array_request_params": coerce_parameter("my-string-array-request-params", "List[str]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_enum_array_request_params": coerce_parameter("my-enum-array-request-params", "List[MyEnum]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_integer_array_request_params": coerce_parameter("my-integer-array-request-params", "List[int]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_long_array_request_params": coerce_parameter("my-long-array-request-params", "List[int]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_int32_array_request_params": coerce_parameter("my-int32-array-request-params", "List[int]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_number_array_request_params": coerce_parameter("my-number-array-request-params", "List[float]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_float_array_request_params": coerce_parameter("my-float-array-request-params", "List[float]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_double_array_request_params": coerce_parameter("my-double-array-request-params", "List[float]", raw_string_parameters, raw_string_array_parameters, False),
                    "my_enum_request_param": coerce_parameter("my-enum-request-param", "MyEnum", raw_string_parameters, raw_string_array_parameters, False),
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "array_request_parameters",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by array_request_parameters_handler.")

class InlineEnumRequestParameters(BaseModel):
    """
    Query, path and header parameters for the InlineEnum operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InlineEnumRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> InlineEnumRequestParameters:
        if obj is None:
            return None
        return InlineEnumRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
InlineEnumRequestBody = Any

InlineEnum200OperationResponse = ApiResponse[Literal[200], InlineEnum200Response]

InlineEnumOperationResponses = Union[InlineEnum200OperationResponse, ]

# Request type for inline_enum
InlineEnumRequest = ApiRequest[InlineEnumRequestParameters, InlineEnumRequestBody]
InlineEnumChainedRequest = ChainedApiRequest[InlineEnumRequestParameters, InlineEnumRequestBody]

class InlineEnumHandlerFunction(Protocol):
    def __call__(self, input: InlineEnumRequest, **kwargs) -> InlineEnumOperationResponses:
        ...

InlineEnumInterceptor = Callable[[InlineEnumChainedRequest], InlineEnumOperationResponses]

def inline_enum_handler(_handler: InlineEnumHandlerFunction = None, interceptors: List[InlineEnumInterceptor] = []):
    """
    Decorator for an api handler for the inline_enum operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: InlineEnumHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = InlineEnumRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "inline_enum",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by inline_enum_handler.")

class InlineRequestBodyRequestParameters(BaseModel):
    """
    Query, path and header parameters for the InlineRequestBody operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> InlineRequestBodyRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> InlineRequestBodyRequestParameters:
        if obj is None:
            return None
        return InlineRequestBodyRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
InlineRequestBodyRequestBody = InlineRequestBodyRequestContent

InlineRequestBody204OperationResponse = ApiResponse[Literal[204], None]

InlineRequestBodyOperationResponses = Union[InlineRequestBody204OperationResponse, ]

# Request type for inline_request_body
InlineRequestBodyRequest = ApiRequest[InlineRequestBodyRequestParameters, InlineRequestBodyRequestBody]
InlineRequestBodyChainedRequest = ChainedApiRequest[InlineRequestBodyRequestParameters, InlineRequestBodyRequestBody]

class InlineRequestBodyHandlerFunction(Protocol):
    def __call__(self, input: InlineRequestBodyRequest, **kwargs) -> InlineRequestBodyOperationResponses:
        ...

InlineRequestBodyInterceptor = Callable[[InlineRequestBodyChainedRequest], InlineRequestBodyOperationResponses]

def inline_request_body_handler(_handler: InlineRequestBodyHandlerFunction = None, interceptors: List[InlineRequestBodyInterceptor] = []):
    """
    Decorator for an api handler for the inline_request_body operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: InlineRequestBodyHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = InlineRequestBodyRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            # Non-primitive type so parse the body into the appropriate model
            body = parse_body(event['body'], ['application/json'], InlineRequestBodyRequestBody)
            interceptor_context = {
                "operationId": "inline_request_body",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 204:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by inline_request_body_handler.")

class ReservedKeywordsRequestParameters(BaseModel):
    """
    Query, path and header parameters for the ReservedKeywords operation
    """
    var_with: Optional[StrictStr]
    var_if: Optional[StrictStr]
    var_class: Optional[StrictStr]

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ReservedKeywordsRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> ReservedKeywordsRequestParameters:
        if obj is None:
            return None
        return ReservedKeywordsRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
ReservedKeywordsRequestBody = Any

ReservedKeywords200OperationResponse = ApiResponse[Literal[200], None]

ReservedKeywordsOperationResponses = Union[ReservedKeywords200OperationResponse, ]

# Request type for reserved_keywords
ReservedKeywordsRequest = ApiRequest[ReservedKeywordsRequestParameters, ReservedKeywordsRequestBody]
ReservedKeywordsChainedRequest = ChainedApiRequest[ReservedKeywordsRequestParameters, ReservedKeywordsRequestBody]

class ReservedKeywordsHandlerFunction(Protocol):
    def __call__(self, input: ReservedKeywordsRequest, **kwargs) -> ReservedKeywordsOperationResponses:
        ...

ReservedKeywordsInterceptor = Callable[[ReservedKeywordsChainedRequest], ReservedKeywordsOperationResponses]

def reserved_keywords_handler(_handler: ReservedKeywordsHandlerFunction = None, interceptors: List[ReservedKeywordsInterceptor] = []):
    """
    Decorator for an api handler for the reserved_keywords operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: ReservedKeywordsHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = ReservedKeywordsRequestParameters.from_dict({
                    "var_with": coerce_parameter("with", "str", raw_string_parameters, raw_string_array_parameters, False),
                    "var_if": coerce_parameter("if", "str", raw_string_parameters, raw_string_array_parameters, False),
                    "var_class": coerce_parameter("class", "str", raw_string_parameters, raw_string_array_parameters, False),
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "reserved_keywords",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by reserved_keywords_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  array_request_parameters: Callable[[Dict, Any], Dict]
  inline_enum: Callable[[Dict, Any], Dict]
  inline_request_body: Callable[[Dict, Any], Dict]
  reserved_keywords: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.inline_enum200_response import InlineEnum200Response
from test_project.models.inline_enum200_response_category_enum import InlineEnum200ResponseCategoryEnum
from test_project.models.inline_request_body_request_content import InlineRequestBodyRequestContent
from test_project.models.my_enum import MyEnum
",
  "test_project/models/inline_enum200_response.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.inline_enum200_response_category_enum import InlineEnum200ResponseCategoryEnum
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class InlineEnum200Response(BaseModel):
    """
    InlineEnum200Response
    """ # noqa: E501
    category: Optional[InlineEnum200ResponseCategoryEnum] = None
    __properties: ClassVar[List[str]] = ["category"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of InlineEnum200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of category
        if self.category:
            _dict['category'] = self.category.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of InlineEnum200Response from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "category": InlineEnum200ResponseCategoryEnum.from_dict(obj.get("category")) if obj.get("category") is not None else None
        })
        return _obj

",
  "test_project/models/inline_enum200_response_category_enum.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class InlineEnum200ResponseCategoryEnum(str, Enum):
    """
    InlineEnum200ResponseCategoryEnum
    """

    """
    allowed enum values
    """
    FRUIT = 'fruit'
    VEGETABLE = 'vegetable'

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of InlineEnum200ResponseCategoryEnum from a JSON string"""
        return cls(json.loads(json_str))



",
  "test_project/models/inline_request_body_request_content.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class InlineRequestBodyRequestContent(BaseModel):
    """
    InlineRequestBodyRequestContent
    """ # noqa: E501
    some_property: StrictStr = Field(alias="someProperty")
    __properties: ClassVar[List[str]] = ["someProperty"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of InlineRequestBodyRequestContent from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of InlineRequestBodyRequestContent from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "someProperty": obj.get("someProperty")
        })
        return _obj

",
  "test_project/models/my_enum.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class MyEnum(str, Enum):
    """
    MyEnum
    """

    """
    allowed enum values
    """
    ONE = 'one'
    TWO = 'two'
    THREE = 'three'

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of MyEnum from a JSON string"""
        return cls(json.loads(json_str))



",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    Edge Cases

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With multiple-tags.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/Tag1Api.md
docs/Tag2Api.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/tag1_api.py
test_project/api/tag2_api.py
test_project/api/__init__.py
test_project/models/__init__.py",
  "README.md": "# Multiple Tags Test


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_instance.neither()
    except ApiException as e:
        print("Exception when calling DefaultApi->neither: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**neither**](docs/DefaultApi.md#neither) | **GET** /neither | 
*Tag1Api* | [**both**](docs/Tag1Api.md#both) | **GET** /both | 
*Tag1Api* | [**tag1**](docs/Tag1Api.md#tag1) | **GET** /tag1 | 
*Tag2Api* | [**tag2**](docs/Tag2Api.md#tag2) | **GET** /tag2 | 

## Documentation For Models

",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**neither**](DefaultApi.md#neither) | **GET** /neither | 

# **neither**
> neither()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_instance.neither()
    except ApiException as e:
        print("Exception when calling DefaultApi->neither: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/Tag1Api.md": "# test_project.Tag1Api

Method | HTTP request | Description
------------- | ------------- | -------------
[**both**](Tag1Api.md#both) | **GET** /both | 
[**tag1**](Tag1Api.md#tag1) | **GET** /tag1 | 

# **both**
> both()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.Tag1Api(api_client)

    try:
        api_instance.both()
    except ApiException as e:
        print("Exception when calling Tag1Api->both: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **tag1**
> tag1()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.Tag1Api(api_client)

    try:
        api_instance.tag1()
    except ApiException as e:
        print("Exception when calling Tag1Api->tag1: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/Tag2Api.md": "# test_project.Tag2Api

Method | HTTP request | Description
------------- | ------------- | -------------
[**tag2**](Tag2Api.md#tag2) | **GET** /tag2 | 

# **tag2**
> tag2()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.Tag2Api(api_client)

    try:
        api_instance.tag2()
    except ApiException as e:
        print("Exception when calling Tag2Api->tag2: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Ok |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi
from test_project.api.tag1_api import Tag1Api
from test_project.api.tag2_api import Tag2Api

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
from test_project.api.tag1_api import Tag1Api
from test_project.api.tag2_api import Tag2Api
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated


from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def neither(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """neither
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._neither_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def neither_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """neither
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._neither_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def neither_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """neither
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._neither_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _neither_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/neither',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    neither: T
    both: T
    tag1: T
    tag2: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "neither": {
        "path": "/neither",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "both": {
        "path": "/both",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "tag1": {
        "path": "/tag1",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "tag2": {
        "path": "/tag2",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class NeitherRequestParameters(BaseModel):
    """
    Query, path and header parameters for the Neither operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> NeitherRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> NeitherRequestParameters:
        if obj is None:
            return None
        return NeitherRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
NeitherRequestBody = Any

Neither200OperationResponse = ApiResponse[Literal[200], None]

NeitherOperationResponses = Union[Neither200OperationResponse, ]

# Request type for neither
NeitherRequest = ApiRequest[NeitherRequestParameters, NeitherRequestBody]
NeitherChainedRequest = ChainedApiRequest[NeitherRequestParameters, NeitherRequestBody]

class NeitherHandlerFunction(Protocol):
    def __call__(self, input: NeitherRequest, **kwargs) -> NeitherOperationResponses:
        ...

NeitherInterceptor = Callable[[NeitherChainedRequest], NeitherOperationResponses]

def neither_handler(_handler: NeitherHandlerFunction = None, interceptors: List[NeitherInterceptor] = []):
    """
    Decorator for an api handler for the neither operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: NeitherHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = NeitherRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "neither",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by neither_handler.")

class BothRequestParameters(BaseModel):
    """
    Query, path and header parameters for the Both operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> BothRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> BothRequestParameters:
        if obj is None:
            return None
        return BothRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
BothRequestBody = Any

Both200OperationResponse = ApiResponse[Literal[200], None]

BothOperationResponses = Union[Both200OperationResponse, ]

# Request type for both
BothRequest = ApiRequest[BothRequestParameters, BothRequestBody]
BothChainedRequest = ChainedApiRequest[BothRequestParameters, BothRequestBody]

class BothHandlerFunction(Protocol):
    def __call__(self, input: BothRequest, **kwargs) -> BothOperationResponses:
        ...

BothInterceptor = Callable[[BothChainedRequest], BothOperationResponses]

def both_handler(_handler: BothHandlerFunction = None, interceptors: List[BothInterceptor] = []):
    """
    Decorator for an api handler for the both operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: BothHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = BothRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "both",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by both_handler.")

class Tag1RequestParameters(BaseModel):
    """
    Query, path and header parameters for the Tag1 operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Tag1RequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> Tag1RequestParameters:
        if obj is None:
            return None
        return Tag1RequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
Tag1RequestBody = Any

Tag1200OperationResponse = ApiResponse[Literal[200], None]

Tag1OperationResponses = Union[Tag1200OperationResponse, ]

# Request type for tag1
Tag1Request = ApiRequest[Tag1RequestParameters, Tag1RequestBody]
Tag1ChainedRequest = ChainedApiRequest[Tag1RequestParameters, Tag1RequestBody]

class Tag1HandlerFunction(Protocol):
    def __call__(self, input: Tag1Request, **kwargs) -> Tag1OperationResponses:
        ...

Tag1Interceptor = Callable[[Tag1ChainedRequest], Tag1OperationResponses]

def tag1_handler(_handler: Tag1HandlerFunction = None, interceptors: List[Tag1Interceptor] = []):
    """
    Decorator for an api handler for the tag1 operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: Tag1HandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = Tag1RequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "tag1",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by tag1_handler.")

class Tag2RequestParameters(BaseModel):
    """
    Query, path and header parameters for the Tag2 operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Tag2RequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> Tag2RequestParameters:
        if obj is None:
            return None
        return Tag2RequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
Tag2RequestBody = Any

Tag2200OperationResponse = ApiResponse[Literal[200], None]

Tag2OperationResponses = Union[Tag2200OperationResponse, ]

# Request type for tag2
Tag2Request = ApiRequest[Tag2RequestParameters, Tag2RequestBody]
Tag2ChainedRequest = ChainedApiRequest[Tag2RequestParameters, Tag2RequestBody]

class Tag2HandlerFunction(Protocol):
    def __call__(self, input: Tag2Request, **kwargs) -> Tag2OperationResponses:
        ...

Tag2Interceptor = Callable[[Tag2ChainedRequest], Tag2OperationResponses]

def tag2_handler(_handler: Tag2HandlerFunction = None, interceptors: List[Tag2Interceptor] = []):
    """
    Decorator for an api handler for the tag2 operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: Tag2HandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = Tag2RequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "tag2",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by tag2_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  neither: Callable[[Dict, Any], Dict]
  both: Callable[[Dict, Any], Dict]
  tag1: Callable[[Dict, Any], Dict]
  tag2: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api/tag1_api.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated


from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class Tag1Api:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def both(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """both
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._both_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def both_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """both
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._both_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def both_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """both
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._both_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _both_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/both',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def tag1(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """tag1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag1_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tag1_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """tag1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag1_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tag1_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tag1
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag1_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tag1_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tag1',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/tag2_api.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated


from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class Tag2Api:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def tag2(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """tag2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag2_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tag2_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """tag2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag2_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tag2_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tag2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tag2_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tag2_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tag2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api_client.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    Multiple Tags Test

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With parameter-refs.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/HelloResponse.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/hello_response.py",
  "README.md": "# Example API


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    id = "cedo laborum articulus" # str |  (optional)

    try:
        api_response = api_instance.say_hello(id=id)
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**say_hello**](docs/DefaultApi.md#say_hello) | **GET** /hello | 

## Documentation For Models

 - [HelloResponse](docs/HelloResponse.md)
",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**say_hello**](DefaultApi.md#say_hello) | **GET** /hello | 

# **say_hello**
> HelloResponse say_hello(id=id)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    id = "cedo laborum articulus" # str |  (optional)

    try:
        api_response = api_instance.say_hello(id=id)
        print("The response of DefaultApi->say_hello:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->say_hello: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **str** |  | [optional] 

### Return type

[**HelloResponse**](HelloResponse.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/HelloResponse.md": "# HelloResponse

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** |  | 
**message** | [**HelloResponse**](HelloResponse.md) |  | [optional] 

## Example

\`\`\`python
from test_project.models.hello_response import HelloResponse

# TODO update the JSON string below
json = "{}"
# create an instance of HelloResponse from a JSON string
hello_response_instance = HelloResponse.from_json(json)
# print the JSON string representation of the object
print(HelloResponse.to_json())

# convert the object into a dict
hello_response_dict = hello_response_instance.to_dict()
# create an instance of HelloResponse from a dict
hello_response_form_dict = hello_response.from_dict(hello_response_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.hello_response import HelloResponse
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.hello_response import HelloResponse

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def say_hello(
        self,
        id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HelloResponse:
        """say_hello
        :param id: (optional)
        :type id: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HelloResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def say_hello_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HelloResponse]:
        """say_hello
        :param id: (optional)
        :type id: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HelloResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def say_hello_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """say_hello
        :param id: (optional)
        :type id: str, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._say_hello_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HelloResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _say_hello_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            _query_params.append(('id', id))
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hello',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    say_hello: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "say_hello": {
        "path": "/hello",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class SayHelloRequestParameters(BaseModel):
    """
    Query, path and header parameters for the SayHello operation
    """
    id: Optional[StrictStr]

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SayHelloRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> SayHelloRequestParameters:
        if obj is None:
            return None
        return SayHelloRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
SayHelloRequestBody = Any

SayHello200OperationResponse = ApiResponse[Literal[200], HelloResponse]

SayHelloOperationResponses = Union[SayHello200OperationResponse, ]

# Request type for say_hello
SayHelloRequest = ApiRequest[SayHelloRequestParameters, SayHelloRequestBody]
SayHelloChainedRequest = ChainedApiRequest[SayHelloRequestParameters, SayHelloRequestBody]

class SayHelloHandlerFunction(Protocol):
    def __call__(self, input: SayHelloRequest, **kwargs) -> SayHelloOperationResponses:
        ...

SayHelloInterceptor = Callable[[SayHelloChainedRequest], SayHelloOperationResponses]

def say_hello_handler(_handler: SayHelloHandlerFunction = None, interceptors: List[SayHelloInterceptor] = []):
    """
    Decorator for an api handler for the say_hello operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: SayHelloHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = SayHelloRequestParameters.from_dict({
                    "id": coerce_parameter("id", "str", raw_string_parameters, raw_string_array_parameters, False),
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "say_hello",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by say_hello_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  say_hello: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.hello_response import HelloResponse
",
  "test_project/models/hello_response.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.hello_response import HelloResponse
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class HelloResponse(BaseModel):
    """
    HelloResponse
    """ # noqa: E501
    id: StrictStr
    message: Optional[HelloResponse] = None
    __properties: ClassVar[List[str]] = ["id", "message"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of HelloResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of message
        if self.message:
            _dict['message'] = self.message.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of HelloResponse from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "message": HelloResponse.from_dict(obj.get("message")) if obj.get("message") is not None else None
        })
        return _obj

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;

exports[`Python Client Code Generation Script Unit Tests Generates With single.yaml 1`] = `
{
  ".gitattributes": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

/.gitattributes linguist-generated
/.github/workflows/pull-request-lint.yml linguist-generated
/.gitignore linguist-generated
/.projen/** linguist-generated
/.projen/deps.json linguist-generated
/.projen/files.json linguist-generated
/.projen/tasks.json linguist-generated
/pyproject.toml linguist-generated",
  ".github/workflows/pull-request-lint.yml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

name: pull-request-lint
on:
  pull_request_target:
    types:
      - labeled
      - opened
      - synchronize
      - reopened
      - ready_for_review
      - edited
jobs:
  validate:
    name: Validate PR title
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - uses: amannn/action-semantic-pull-request@v5.4.0
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat
            fix
            chore
          requireScope: false
",
  ".gitignore": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".
node_modules/
!/.gitattributes
!/.projen/tasks.json
!/.projen/deps.json
!/.projen/files.json
!/.github/workflows/pull-request-lint.yml
!/pyproject.toml
/poetry.toml
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
*.manifest
*.spec
pip-log.txt
pip-delete-this-directory.txt
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.mo
*.pot
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
instance/
.webassets-cache
.scrapy
docs/_build/
.pybuilder/
target/
.ipynb_checkpoints
profile_default/
ipython_config.py
__pypackages__/
celerybeat-schedule
celerybeat.pid
*.sage.py
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.spyderproject
.spyproject
.ropeproject
/site
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
cython_debug/
test_project
docs
README.md
.openapi-generator
.tsapi-manifest
!/.projenrc.py
",
  ".projen/deps.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "dependencies": [
      {
        "name": "projen",
        "type": "devenv",
        "version": "99.99.99",
      },
      {
        "name": "aenum",
        "type": "runtime",
        "version": "^3.1.11",
      },
      {
        "name": "aws-lambda-powertools",
        "type": "runtime",
        "version": "{extras=["tracer", "aws-sdk"],version="^2.28.0"}",
      },
      {
        "name": "pydantic",
        "type": "runtime",
        "version": "^2.5.2",
      },
      {
        "name": "python-dateutil",
        "type": "runtime",
        "version": "~2.8.2",
      },
      {
        "name": "python",
        "type": "runtime",
        "version": "^3.9",
      },
      {
        "name": "urllib3",
        "type": "runtime",
        "version": "~1.26.7",
      },
    ],
  },
  ".projen/files.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "files": [
      ".gitattributes",
      ".github/workflows/pull-request-lint.yml",
      ".gitignore",
      ".projen/deps.json",
      ".projen/files.json",
      ".projen/tasks.json",
      "poetry.toml",
      "pyproject.toml",
    ],
  },
  ".projen/tasks.json": {
    "//": "~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".",
    "env": {
      "AWS_PDK_VERSION": "0.0.0",
      "PATH": "$(echo $(poetry env info -p)/bin:$PATH)",
      "VIRTUAL_ENV": "$(poetry env info -p || poetry run poetry env info -p)",
    },
    "tasks": {
      "build": {
        "description": "Full release build",
        "name": "build",
        "steps": [
          {
            "spawn": "default",
          },
          {
            "spawn": "pre-compile",
          },
          {
            "spawn": "compile",
          },
          {
            "spawn": "post-compile",
          },
          {
            "spawn": "test",
          },
          {
            "spawn": "package",
          },
        ],
      },
      "clobber": {
        "condition": "git diff --exit-code > /dev/null",
        "description": "hard resets to HEAD of origin and cleans the local repo",
        "env": {
          "BRANCH": "$(git branch --show-current)",
        },
        "name": "clobber",
        "steps": [
          {
            "exec": "git checkout -b scratch",
            "name": "save current HEAD in "scratch" branch",
          },
          {
            "exec": "git checkout $BRANCH",
          },
          {
            "exec": "git fetch origin",
            "name": "fetch latest changes from origin",
          },
          {
            "exec": "git reset --hard origin/$BRANCH",
            "name": "hard reset to origin commit",
          },
          {
            "exec": "git clean -fdx",
            "name": "clean all untracked files",
          },
          {
            "say": "ready to rock! (unpushed commits are under the "scratch" branch)",
          },
        ],
      },
      "compile": {
        "description": "Only compile",
        "name": "compile",
      },
      "default": {
        "description": "Synthesize project files",
        "name": "default",
        "steps": [
          {
            "exec": "python .projenrc.py",
          },
        ],
      },
      "eject": {
        "description": "Remove projen from the project",
        "env": {
          "PROJEN_EJECTING": "true",
        },
        "name": "eject",
        "steps": [
          {
            "spawn": "default",
          },
        ],
      },
      "generate": {
        "name": "generate",
        "steps": [
          {
            "exec": "npx --yes -p @aws/pdk@$AWS_PDK_VERSION type-safe-api generate --specPath spec.yaml --outputPath . --templateDirs "python" --metadata '{"srcDir":"test_project","moduleName":"test_project","projectName":"test_project"}'",
          },
        ],
      },
      "install": {
        "description": "Install dependencies and update lockfile",
        "name": "install",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry update",
          },
        ],
      },
      "install:ci": {
        "description": "Install dependencies with frozen lockfile",
        "name": "install:ci",
        "steps": [
          {
            "exec": "mkdir -p test_project && touch test_project/__init__.py README.md",
          },
          {
            "exec": "poetry check --lock && poetry install",
          },
        ],
      },
      "package": {
        "description": "Creates the distribution package",
        "name": "package",
        "steps": [
          {
            "exec": "poetry build",
          },
        ],
      },
      "post-compile": {
        "description": "Runs after successful compilation",
        "name": "post-compile",
      },
      "pre-compile": {
        "description": "Prepare the project for compilation",
        "name": "pre-compile",
        "steps": [
          {
            "spawn": "generate",
          },
        ],
      },
      "publish": {
        "description": "Uploads the package to PyPI.",
        "name": "publish",
        "steps": [
          {
            "exec": "poetry publish",
          },
        ],
      },
      "publish:test": {
        "description": "Uploads the package against a test PyPI endpoint.",
        "name": "publish:test",
        "steps": [
          {
            "exec": "poetry publish -r testpypi",
          },
        ],
      },
      "test": {
        "description": "Run tests",
        "name": "test",
      },
    },
  },
  ".tsapi-manifest": "test_project/api_client.py
test_project/api_response.py
test_project/configuration.py
test_project/exceptions.py
test_project/__init__.py
test_project/py.typed
test_project/rest.py
docs/DefaultApi.md
docs/ApiError.md
docs/MapResponse.md
docs/MapResponseMapPropertyValue.md
docs/TestRequest.md
docs/TestResponse.md
docs/TestResponseMessagesInner.md
README.md
test_project/interceptors/try_catch.py
test_project/interceptors/response_headers.py
test_project/interceptors/powertools/logger.py
test_project/interceptors/powertools/tracer.py
test_project/interceptors/powertools/metrics.py
test_project/interceptors/__init__.py
test_project/api/operation_config.py
test_project/response.py
test_project/api/default_api.py
test_project/api/__init__.py
test_project/models/__init__.py
test_project/models/api_error.py
test_project/models/map_response.py
test_project/models/map_response_map_property_value.py
test_project/models/test_request.py
test_project/models/test_response.py
test_project/models/test_response_messages_inner.py",
  "README.md": "# Example API


This Python package is automatically generated.

- API version: 1.0.0

## Requirements.

Python 3.7+

## Getting Started

See the following example for usage:

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    body = None # object |  (optional)

    try:
        api_response = api_instance.any_request_response(body=body)
        print("The response of DefaultApi->any_request_response:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->any_request_response: %s\\n" % e)
\`\`\`

## Documentation for API Endpoints

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DefaultApi* | [**any_request_response**](docs/DefaultApi.md#any_request_response) | **PUT** /any-request-response | 
*DefaultApi* | [**empty**](docs/DefaultApi.md#empty) | **PUT** /empty-response | 
*DefaultApi* | [**map_response**](docs/DefaultApi.md#map_response) | **GET** /map-response | 
*DefaultApi* | [**media_types**](docs/DefaultApi.md#media_types) | **POST** /different-media-type | 
*DefaultApi* | [**multiple_content_types**](docs/DefaultApi.md#multiple_content_types) | **POST** /multiple-content-types | 
*DefaultApi* | [**operation_one**](docs/DefaultApi.md#operation_one) | **POST** /path/{pathParam} | 
*DefaultApi* | [**without_operation_id_delete**](docs/DefaultApi.md#without_operation_id_delete) | **DELETE** /without-operation-id | 

## Documentation For Models

 - [ApiError](docs/ApiError.md)
 - [MapResponse](docs/MapResponse.md)
 - [MapResponseMapPropertyValue](docs/MapResponseMapPropertyValue.md)
 - [TestRequest](docs/TestRequest.md)
 - [TestResponse](docs/TestResponse.md)
 - [TestResponseMessagesInner](docs/TestResponseMessagesInner.md)
",
  "docs/ApiError.md": "# ApiError

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**error_message** | **str** |  | 

## Example

\`\`\`python
from test_project.models.api_error import ApiError

# TODO update the JSON string below
json = "{}"
# create an instance of ApiError from a JSON string
api_error_instance = ApiError.from_json(json)
# print the JSON string representation of the object
print(ApiError.to_json())

# convert the object into a dict
api_error_dict = api_error_instance.to_dict()
# create an instance of ApiError from a dict
api_error_form_dict = api_error.from_dict(api_error_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/DefaultApi.md": "# test_project.DefaultApi

Method | HTTP request | Description
------------- | ------------- | -------------
[**any_request_response**](DefaultApi.md#any_request_response) | **PUT** /any-request-response | 
[**empty**](DefaultApi.md#empty) | **PUT** /empty-response | 
[**map_response**](DefaultApi.md#map_response) | **GET** /map-response | 
[**media_types**](DefaultApi.md#media_types) | **POST** /different-media-type | 
[**multiple_content_types**](DefaultApi.md#multiple_content_types) | **POST** /multiple-content-types | 
[**operation_one**](DefaultApi.md#operation_one) | **POST** /path/{pathParam} | 
[**without_operation_id_delete**](DefaultApi.md#without_operation_id_delete) | **DELETE** /without-operation-id | 

# **any_request_response**
> object any_request_response(body=body)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    body = None # object |  (optional)

    try:
        api_response = api_instance.any_request_response(body=body)
        print("The response of DefaultApi->any_request_response:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->any_request_response: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **body** | **object** |  | [optional] 

### Return type

**object**

### HTTP request headers

 - **Content-Type**: application/json
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Any response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **empty**
> empty()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_instance.empty()
    except ApiException as e:
        print("Exception when calling DefaultApi->empty: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

void (empty response body)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: Not defined

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**204** | No response body! |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **map_response**
> MapResponse map_response()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.map_response()
        print("The response of DefaultApi->map_response:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->map_response: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**MapResponse**](MapResponse.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **media_types**
> str media_types(body)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    body = None # bytearray | 

    try:
        api_response = api_instance.media_types(body)
        print("The response of DefaultApi->media_types:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->media_types: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **body** | **bytearray** |  | 

### Return type

**str**

### HTTP request headers

 - **Content-Type**: application/pdf
 - **Accept**: application/x-mpegurl

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Success |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **multiple_content_types**
> str multiple_content_types(test_request)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    test_request = test_project.TestRequest() # TestRequest | 

    try:
        api_response = api_instance.multiple_content_types(test_request)
        print("The response of DefaultApi->multiple_content_types:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->multiple_content_types: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **test_request** | [**TestRequest**](TestRequest.md) |  | 

### Return type

**str**

### HTTP request headers

 - **Content-Type**: application/json, application/pdf
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Success |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **operation_one**
> TestResponse operation_one(param1, param2, param3, path_param, x_header_param, test_request, param4=param4, x_multi_value_header_param=x_multi_value_header_param)


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)
    param1 = "cedo laborum articulus" # str | This is parameter 1
    param2 = [] # List[str] | This is parameter 2
    param3 = 0.03397139022126794 # float | 
    path_param = "commemoro canto eaque" # str | 
    x_header_param = "omnis cedo conculco" # str | This is a header parameter
    test_request = test_project.TestRequest() # TestRequest | 
    param4 = "cerno tabella cohors" # str |  (optional)
    x_multi_value_header_param = [] # List[str] |  (optional)

    try:
        api_response = api_instance.operation_one(param1, param2, param3, path_param, x_header_param, test_request, param4=param4, x_multi_value_header_param=x_multi_value_header_param)
        print("The response of DefaultApi->operation_one:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->operation_one: %s\\n" % e)
\`\`\`

### Parameters
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **param1** | **str** | This is parameter 1 | 
 **param2** | **List[str]** | This is parameter 2 | 
 **param3** | **float** |  | 
 **path_param** | **str** |  | 
 **x_header_param** | **str** | This is a header parameter | 
 **test_request** | [**TestRequest**](TestRequest.md) |  | 
 **param4** | **str** |  | [optional] 
 **x_multi_value_header_param** | **List[str]** |  | [optional] 

### Return type

[**TestResponse**](TestResponse.md)

### HTTP request headers

 - **Content-Type**: application/json
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |
**400** | Error response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **without_operation_id_delete**
> TestResponse without_operation_id_delete()


### Example

\`\`\`python
import time
import test_project
from test_project.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to http://localhost
# See configuration.py for a list of all supported configuration parameters.
configuration = test_project.Configuration(
    host = "http://localhost"
)

# Enter a context with an instance of the API client
with test_project.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = test_project.DefaultApi(api_client)

    try:
        api_response = api_instance.without_operation_id_delete()
        print("The response of DefaultApi->without_operation_id_delete:\\n")
        pprint(api_response)
    except ApiException as e:
        print("Exception when calling DefaultApi->without_operation_id_delete: %s\\n" % e)
\`\`\`

### Parameters
This endpoint does not need any parameters.

### Return type

[**TestResponse**](TestResponse.md)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | Successful response |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

",
  "docs/MapResponse.md": "# MapResponse

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**map_property** | **Dict[str, MapResponseMapPropertyValue]** |  | 

## Example

\`\`\`python
from test_project.models.map_response import MapResponse

# TODO update the JSON string below
json = "{}"
# create an instance of MapResponse from a JSON string
map_response_instance = MapResponse.from_json(json)
# print the JSON string representation of the object
print(MapResponse.to_json())

# convert the object into a dict
map_response_dict = map_response_instance.to_dict()
# create an instance of MapResponse from a dict
map_response_form_dict = map_response.from_dict(map_response_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/MapResponseMapPropertyValue.md": "# MapResponseMapPropertyValue

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**a** | **str** |  | 
**b** | **str** |  | [optional] 

## Example

\`\`\`python
from test_project.models.map_response_map_property_value import MapResponseMapPropertyValue

# TODO update the JSON string below
json = "{}"
# create an instance of MapResponseMapPropertyValue from a JSON string
map_response_map_property_value_instance = MapResponseMapPropertyValue.from_json(json)
# print the JSON string representation of the object
print(MapResponseMapPropertyValue.to_json())

# convert the object into a dict
map_response_map_property_value_dict = map_response_map_property_value_instance.to_dict()
# create an instance of MapResponseMapPropertyValue from a dict
map_response_map_property_value_form_dict = map_response_map_property_value.from_dict(map_response_map_property_value_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/TestRequest.md": "# TestRequest

This is a test request
## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**my_input** | **float** |  | [optional] 

## Example

\`\`\`python
from test_project.models.test_request import TestRequest

# TODO update the JSON string below
json = "{}"
# create an instance of TestRequest from a JSON string
test_request_instance = TestRequest.from_json(json)
# print the JSON string representation of the object
print(TestRequest.to_json())

# convert the object into a dict
test_request_dict = test_request_instance.to_dict()
# create an instance of TestRequest from a dict
test_request_form_dict = test_request.from_dict(test_request_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/TestResponse.md": "# TestResponse

This is a test response
## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**messages** | **List[TestResponseMessagesInner]** |  | 

## Example

\`\`\`python
from test_project.models.test_response import TestResponse

# TODO update the JSON string below
json = "{}"
# create an instance of TestResponse from a JSON string
test_response_instance = TestResponse.from_json(json)
# print the JSON string representation of the object
print(TestResponse.to_json())

# convert the object into a dict
test_response_dict = test_response_instance.to_dict()
# create an instance of TestResponse from a dict
test_response_form_dict = test_response.from_dict(test_response_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "docs/TestResponseMessagesInner.md": "# TestResponseMessagesInner

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**message** | **str** | This is a message | [optional] 
**id** | **int** |  | 

## Example

\`\`\`python
from test_project.models.test_response_messages_inner import TestResponseMessagesInner

# TODO update the JSON string below
json = "{}"
# create an instance of TestResponseMessagesInner from a JSON string
test_response_messages_inner_instance = TestResponseMessagesInner.from_json(json)
# print the JSON string representation of the object
print(TestResponseMessagesInner.to_json())

# convert the object into a dict
test_response_messages_inner_dict = test_response_messages_inner_instance.to_dict()
# create an instance of TestResponseMessagesInner from a dict
test_response_messages_inner_form_dict = test_response_messages_inner.from_dict(test_response_messages_inner_dict)
\`\`\`
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

",
  "poetry.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[repositories.testpypi]
url = "https://test.pypi.org/legacy/"
",
  "pyproject.toml": "# ~~ Generated by projen. To modify, edit .projenrc.py and run "npx projen".

[tool.poetry]
name = "test_project"
version = "1.0.0"
description = ""
authors = [ "test <me@example.com>" ]
readme = "README.md"
include = [ "test_project", "test_project/**/*.py" ]

  [[tool.poetry.packages]]
  include = "test_project"

  [tool.poetry.dependencies]
  aenum = "^3.1.11"
  pydantic = "^2.5.2"
  python-dateutil = "~2.8.2"
  python = "^3.9"
  urllib3 = "~1.26.7"

    [tool.poetry.dependencies.aws-lambda-powertools]
    extras = [ "tracer", "aws-sdk" ]
    version = "^2.28.0"

[tool.poetry.group.dev.dependencies]
projen = "99.99.99"

[build-system]
requires = [ "poetry-core" ]
build-backend = "poetry.core.masonry.api"
",
  "test_project/__init__.py": "# coding: utf-8

# flake8: noqa

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

__version__ = "1.0.0"

# import apis into sdk package
from test_project.api.default_api import DefaultApi

# import ApiClient
from test_project.api_response import ApiResponse
from test_project.api_client import ApiClient
from test_project.configuration import Configuration
from test_project.exceptions import OpenApiException
from test_project.exceptions import ApiTypeError
from test_project.exceptions import ApiValueError
from test_project.exceptions import ApiKeyError
from test_project.exceptions import ApiAttributeError
from test_project.exceptions import ApiException

# import models into sdk package
from test_project.models.api_error import ApiError
from test_project.models.map_response import MapResponse
from test_project.models.map_response_map_property_value import MapResponseMapPropertyValue
from test_project.models.test_request import TestRequest
from test_project.models.test_response import TestResponse
from test_project.models.test_response_messages_inner import TestResponseMessagesInner
",
  "test_project/api/__init__.py": "# flake8: noqa

# import apis into api package
from test_project.api.default_api import DefaultApi
",
  "test_project/api/default_api.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from test_project.models.api_error import ApiError
from test_project.models.map_response import MapResponse
from test_project.models.test_request import TestRequest
from test_project.models.test_response import TestResponse

from test_project.api_client import ApiClient
from test_project.api_response import ApiResponse
from test_project.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def any_request_response(
        self,
        body: Optional[Any] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """any_request_response
        :param body: (optional)
        :type body: object, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._any_request_response_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def any_request_response_with_http_info(
        self,
        body: Optional[Any] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """any_request_response
        :param body: (optional)
        :type body: object, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._any_request_response_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def any_request_response_without_preload_content(
        self,
        body: Optional[Any] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """any_request_response
        :param body: (optional)
        :type body: object, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._any_request_response_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _any_request_response_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header \`Content-Type\`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/any-request-response',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def empty(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """empty
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._empty_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def empty_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """empty
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._empty_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def empty_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """empty
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._empty_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _empty_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/empty-response',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def map_response(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MapResponse:
        """map_response
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_response_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MapResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def map_response_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MapResponse]:
        """map_response
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_response_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MapResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def map_response_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """map_response
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_response_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MapResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _map_response_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/map-response',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def media_types(
        self,
        body: Union[StrictBytes, StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """media_types
        :param body: (required)
        :type body: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._media_types_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def media_types_with_http_info(
        self,
        body: Union[StrictBytes, StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """media_types
        :param body: (required)
        :type body: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._media_types_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def media_types_without_preload_content(
        self,
        body: Union[StrictBytes, StrictStr],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """media_types
        :param body: (required)
        :type body: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._media_types_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _media_types_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            # convert to byte array if the input is a file name (str)
            if isinstance(body, str):
                with io.open(body, "rb") as _fp:
                    _body_params = _fp.read()
            else:
                _body_params = body


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/x-mpegurl'
            ]
        )

        # set the HTTP header \`Content-Type\`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/pdf'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/different-media-type',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def multiple_content_types(
        self,
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """multiple_content_types
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._multiple_content_types_serialize(
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def multiple_content_types_with_http_info(
        self,
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """multiple_content_types
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._multiple_content_types_serialize(
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def multiple_content_types_without_preload_content(
        self,
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """multiple_content_types
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._multiple_content_types_serialize(
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _multiple_content_types_serialize(
        self,
        test_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if test_request is not None:
            _body_params = test_request


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header \`Content-Type\`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json',
                        'application/pdf'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/multiple-content-types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def operation_one(
        self,
        param1: StrictStr,
        param2: List[StrictStr],
        param3: Union[StrictFloat, StrictInt],
        path_param: StrictStr,
        x_header_param: StrictStr,
        test_request: TestRequest,
        param4: Optional[StrictStr] = None,
        x_multi_value_header_param: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestResponse:
        """operation_one
        :param param1: This is parameter 1 (required)
        :type param1: str
        :param param2: This is parameter 2 (required)
        :type param2: List[str]
        :param param3: (required)
        :type param3: float
        :param path_param: (required)
        :type path_param: str
        :param x_header_param: This is a header parameter (required)
        :type x_header_param: str
        :param test_request: (required)
        :type test_request: TestRequest
        :param param4: (optional)
        :type param4: str, optional
        :param x_multi_value_header_param: (optional)
        :type x_multi_value_header_param: List[str], optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._operation_one_serialize(
            param1=param1,
            param2=param2,
            param3=param3,
            path_param=path_param,
            x_header_param=x_header_param,
            test_request=test_request,
            param4=param4,
            x_multi_value_header_param=x_multi_value_header_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse",
            '400': "ApiError"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def operation_one_with_http_info(
        self,
        param1: StrictStr,
        param2: List[StrictStr],
        param3: Union[StrictFloat, StrictInt],
        path_param: StrictStr,
        x_header_param: StrictStr,
        test_request: TestRequest,
        param4: Optional[StrictStr] = None,
        x_multi_value_header_param: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestResponse]:
        """operation_one
        :param param1: This is parameter 1 (required)
        :type param1: str
        :param param2: This is parameter 2 (required)
        :type param2: List[str]
        :param param3: (required)
        :type param3: float
        :param path_param: (required)
        :type path_param: str
        :param x_header_param: This is a header parameter (required)
        :type x_header_param: str
        :param test_request: (required)
        :type test_request: TestRequest
        :param param4: (optional)
        :type param4: str, optional
        :param x_multi_value_header_param: (optional)
        :type x_multi_value_header_param: List[str], optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._operation_one_serialize(
            param1=param1,
            param2=param2,
            param3=param3,
            path_param=path_param,
            x_header_param=x_header_param,
            test_request=test_request,
            param4=param4,
            x_multi_value_header_param=x_multi_value_header_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse",
            '400': "ApiError"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def operation_one_without_preload_content(
        self,
        param1: StrictStr,
        param2: List[StrictStr],
        param3: Union[StrictFloat, StrictInt],
        path_param: StrictStr,
        x_header_param: StrictStr,
        test_request: TestRequest,
        param4: Optional[StrictStr] = None,
        x_multi_value_header_param: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """operation_one
        :param param1: This is parameter 1 (required)
        :type param1: str
        :param param2: This is parameter 2 (required)
        :type param2: List[str]
        :param param3: (required)
        :type param3: float
        :param path_param: (required)
        :type path_param: str
        :param x_header_param: This is a header parameter (required)
        :type x_header_param: str
        :param test_request: (required)
        :type test_request: TestRequest
        :param param4: (optional)
        :type param4: str, optional
        :param x_multi_value_header_param: (optional)
        :type x_multi_value_header_param: List[str], optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._operation_one_serialize(
            param1=param1,
            param2=param2,
            param3=param3,
            path_param=path_param,
            x_header_param=x_header_param,
            test_request=test_request,
            param4=param4,
            x_multi_value_header_param=x_multi_value_header_param,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse",
            '400': "ApiError"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _operation_one_serialize(
        self,
        param1,
        param2,
        param3,
        path_param,
        x_header_param,
        test_request,
        param4,
        x_multi_value_header_param,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            'param2': 'multi',
            'x-multi-value-header-param': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path_param is not None:
            _path_params['pathParam'] = path_param
        # process the query parameters
        if param1 is not None:
            _query_params.append(('param1', param1))
        if param2 is not None:
            _query_params.append(('param2', param2))
        if param3 is not None:
            _query_params.append(('param3', param3))
        if param4 is not None:
            _query_params.append(('param4', param4))
        # process the header parameters
        if x_header_param is not None:
            _header_params['x-header-param'] = x_header_param
        if x_multi_value_header_param is not None:
            _header_params['x-multi-value-header-param'] = x_multi_value_header_param
        # process the form parameters
        # process the body parameter
        if test_request is not None:
            _body_params = test_request


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header \`Content-Type\`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/path/{pathParam}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )



    @validate_call
    def without_operation_id_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestResponse:
        """without_operation_id_delete
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._without_operation_id_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def without_operation_id_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestResponse]:
        """without_operation_id_delete
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._without_operation_id_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def without_operation_id_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """without_operation_id_delete
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._without_operation_id_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResponse"
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _without_operation_id_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header \`Accept\`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/without-operation-id',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


",
  "test_project/api/operation_config.py": "from __future__ import annotations
import urllib.parse
import json
from typing import Callable, Any, Dict, List, NamedTuple, TypeVar, Generic, Union, TypedDict, Protocol, Optional, Literal, Annotated
from functools import wraps
from dataclasses import dataclass, fields
from datetime import datetime
import dateutil.parser
from pydantic import BaseModel, Field, StrictStr, conlist, StrictBool, StrictInt, StrictFloat

from test_project.models import *

T = TypeVar('T')

# Generic type for object keyed by operation names
@dataclass
class OperationConfig(Generic[T]):
    any_request_response: T
    empty: T
    map_response: T
    media_types: T
    multiple_content_types: T
    operation_one: T
    without_operation_id_delete: T
    ...

# Look up path and http method for a given operation name
OperationLookup = {
    "any_request_response": {
        "path": "/any-request-response",
        "method": "PUT",
        "contentTypes": ["application/json"]
    },
    "empty": {
        "path": "/empty-response",
        "method": "PUT",
        "contentTypes": ["application/json"]
    },
    "map_response": {
        "path": "/map-response",
        "method": "GET",
        "contentTypes": ["application/json"]
    },
    "media_types": {
        "path": "/different-media-type",
        "method": "POST",
        "contentTypes": ["application/pdf"]
    },
    "multiple_content_types": {
        "path": "/multiple-content-types",
        "method": "POST",
        "contentTypes": ["application/json","application/pdf"]
    },
    "operation_one": {
        "path": "/path/{pathParam}",
        "method": "POST",
        "contentTypes": ["application/json"]
    },
    "without_operation_id_delete": {
        "path": "/without-operation-id",
        "method": "DELETE",
        "contentTypes": ["application/json"]
    },
}

class Operations:
    @staticmethod
    def all(value: T) -> OperationConfig[T]:
        """
        Returns an OperationConfig with the same value for every operation
        """
        return OperationConfig(**{ operation_id: value for operation_id, _ in OperationLookup.items() })

def uri_decode(value):
    """
    URI decode a value or list of values
    """
    if isinstance(value, list):
        return [urllib.parse.unquote(v) for v in value]
    return urllib.parse.unquote(value)

def decode_request_parameters(parameters):
    """
    URI decode api request parameters (path, query or multi-value query)
    """
    return { key: uri_decode(parameters[key]) if parameters[key] is not None else parameters[key] for key in parameters.keys() }

def parse_body(body, content_types, model):
    """
    Parse the body of an api request into the given model if present
    """
    if len([c for c in content_types if c != 'application/json']) == 0:
        if model != Any:
            body = model.model_validate(json.loads(body))
        else:
            body = json.loads(body or '{}')
    return body

def assert_required(required, base_name, parameters):
    if required and parameters.get(base_name) is None:
        raise Exception(f"Missing required request parameter '{base_name}'")

def coerce_float(base_name, s):
    try:
        return float(s)
    except Exception as e:
        raise Exception(f"Expected a number for request parameter '{base_name}'")

def coerce_int(base_name, s):
    try:
        return int(s)
    except Exception as e:
        raise Exception(f"Expected an integer for request parameter '{base_name}'")

def coerce_datetime(base_name, s):
    try:
        return dateutil.parser.parse(s)
    except Exception as e:
        raise Exception(f"Expected a valid date (iso format) for request parameter '{base_name}'")

def coerce_bool(base_name, s):
    if s == "true":
        return True
    elif s == "false":
        return False
    raise Exception(f"Expected a boolean (true or false) for request parameter '{base_name}'")

def coerce_parameter(base_name, data_type, raw_string_parameters, raw_string_array_parameters, required):
    if data_type == "float":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_float(base_name, param)
    elif data_type == "int":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_int(base_name, param)
    elif data_type == "bool":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_bool(base_name, param)
    elif data_type == "datetime":
        assert_required(required, base_name, raw_string_parameters)
        param = raw_string_parameters.get(base_name)
        return None if param is None else coerce_datetime(base_name, param)
    elif data_type == "List[float]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_float(base_name, p) for p in param]
    elif data_type == "List[int]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_int(base_name, p) for p in param]
    elif data_type == "List[bool]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_bool(base_name, p) for p in param]
    elif data_type == "List[datetime]":
        assert_required(required, base_name, raw_string_array_parameters)
        param = raw_string_array_parameters.get(base_name)
        return None if param is None else [coerce_datetime(base_name, p) for p in param]
    elif data_type == "List[str]":
        assert_required(required, base_name, raw_string_array_parameters)
        return raw_string_array_parameters.get(base_name)
    else: # data_type == "str"
        assert_required(required, base_name, raw_string_parameters)
        return raw_string_parameters.get(base_name)


def extract_response_headers_from_interceptors(interceptors):
    headers = {}
    for interceptor in interceptors:
        additional_headers = getattr(interceptor, "__type_safe_api_response_headers", None)
        headers = {**headers, **(additional_headers or {})}
    return headers


RequestParameters = TypeVar('RequestParameters')
RequestBody = TypeVar('RequestBody')
ResponseBody = TypeVar('ResponseBody')
StatusCode = TypeVar('StatusCode')

@dataclass
class ApiRequest(Generic[RequestParameters, RequestBody]):
    request_parameters: RequestParameters
    body: RequestBody
    event: Any
    context: Any
    interceptor_context: Dict[str, Any]

@dataclass
class ChainedApiRequest(ApiRequest[RequestParameters, RequestBody],
    Generic[RequestParameters, RequestBody]):

    chain: 'HandlerChain'

@dataclass
class ApiResponse(Exception, Generic[StatusCode, ResponseBody]):
    status_code: StatusCode
    headers: Dict[str, str]
    body: ResponseBody
    multi_value_headers: Optional[Dict[str, List[str]]] = None

class HandlerChain(Generic[RequestParameters, RequestBody, StatusCode, ResponseBody]):
    def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
        raise Exception("Not implemented!")

def _build_handler_chain(_interceptors, handler) -> HandlerChain:
    if len(_interceptors) == 0:
        class BaseHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return handler(request)
        return BaseHandlerChain()
    else:
        interceptor = _interceptors[0]

        class RemainingHandlerChain(HandlerChain[RequestParameters, RequestBody, StatusCode, ResponseBody]):
            def next(self, request: ChainedApiRequest[RequestParameters, RequestBody]) -> ApiResponse[StatusCode, ResponseBody]:
                return interceptor(ChainedApiRequest(
                    request_parameters = request.request_parameters,
                    body = request.body,
                    event = request.event,
                    context = request.context,
                    interceptor_context = request.interceptor_context,
                    chain = _build_handler_chain(_interceptors[1:len(_interceptors)], handler),
                ))
        return RemainingHandlerChain()


class AnyRequestResponseRequestParameters(BaseModel):
    """
    Query, path and header parameters for the AnyRequestResponse operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> AnyRequestResponseRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> AnyRequestResponseRequestParameters:
        if obj is None:
            return None
        return AnyRequestResponseRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
AnyRequestResponseRequestBody = str

AnyRequestResponse200OperationResponse = ApiResponse[Literal[200], str]

AnyRequestResponseOperationResponses = Union[AnyRequestResponse200OperationResponse, ]

# Request type for any_request_response
AnyRequestResponseRequest = ApiRequest[AnyRequestResponseRequestParameters, AnyRequestResponseRequestBody]
AnyRequestResponseChainedRequest = ChainedApiRequest[AnyRequestResponseRequestParameters, AnyRequestResponseRequestBody]

class AnyRequestResponseHandlerFunction(Protocol):
    def __call__(self, input: AnyRequestResponseRequest, **kwargs) -> AnyRequestResponseOperationResponses:
        ...

AnyRequestResponseInterceptor = Callable[[AnyRequestResponseChainedRequest], AnyRequestResponseOperationResponses]

def any_request_response_handler(_handler: AnyRequestResponseHandlerFunction = None, interceptors: List[AnyRequestResponseInterceptor] = []):
    """
    Decorator for an api handler for the any_request_response operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: AnyRequestResponseHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = AnyRequestResponseRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            # Primitive type so body is passed as the original string
            body = event['body']
            interceptor_context = {
                "operationId": "any_request_response",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by any_request_response_handler.")

class EmptyRequestParameters(BaseModel):
    """
    Query, path and header parameters for the Empty operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> EmptyRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> EmptyRequestParameters:
        if obj is None:
            return None
        return EmptyRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
EmptyRequestBody = Any

Empty204OperationResponse = ApiResponse[Literal[204], None]

EmptyOperationResponses = Union[Empty204OperationResponse, ]

# Request type for empty
EmptyRequest = ApiRequest[EmptyRequestParameters, EmptyRequestBody]
EmptyChainedRequest = ChainedApiRequest[EmptyRequestParameters, EmptyRequestBody]

class EmptyHandlerFunction(Protocol):
    def __call__(self, input: EmptyRequest, **kwargs) -> EmptyOperationResponses:
        ...

EmptyInterceptor = Callable[[EmptyChainedRequest], EmptyOperationResponses]

def empty_handler(_handler: EmptyHandlerFunction = None, interceptors: List[EmptyInterceptor] = []):
    """
    Decorator for an api handler for the empty operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: EmptyHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = EmptyRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "empty",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 204:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by empty_handler.")

class MapResponseRequestParameters(BaseModel):
    """
    Query, path and header parameters for the MapResponse operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> MapResponseRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> MapResponseRequestParameters:
        if obj is None:
            return None
        return MapResponseRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
MapResponseRequestBody = Any

MapResponse200OperationResponse = ApiResponse[Literal[200], MapResponse]

MapResponseOperationResponses = Union[MapResponse200OperationResponse, ]

# Request type for map_response
MapResponseRequest = ApiRequest[MapResponseRequestParameters, MapResponseRequestBody]
MapResponseChainedRequest = ChainedApiRequest[MapResponseRequestParameters, MapResponseRequestBody]

class MapResponseHandlerFunction(Protocol):
    def __call__(self, input: MapResponseRequest, **kwargs) -> MapResponseOperationResponses:
        ...

MapResponseInterceptor = Callable[[MapResponseChainedRequest], MapResponseOperationResponses]

def map_response_handler(_handler: MapResponseHandlerFunction = None, interceptors: List[MapResponseInterceptor] = []):
    """
    Decorator for an api handler for the map_response operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: MapResponseHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = MapResponseRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "map_response",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by map_response_handler.")

class MediaTypesRequestParameters(BaseModel):
    """
    Query, path and header parameters for the MediaTypes operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> MediaTypesRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> MediaTypesRequestParameters:
        if obj is None:
            return None
        return MediaTypesRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
MediaTypesRequestBody = str

MediaTypes200OperationResponse = ApiResponse[Literal[200], str]

MediaTypesOperationResponses = Union[MediaTypes200OperationResponse, ]

# Request type for media_types
MediaTypesRequest = ApiRequest[MediaTypesRequestParameters, MediaTypesRequestBody]
MediaTypesChainedRequest = ChainedApiRequest[MediaTypesRequestParameters, MediaTypesRequestBody]

class MediaTypesHandlerFunction(Protocol):
    def __call__(self, input: MediaTypesRequest, **kwargs) -> MediaTypesOperationResponses:
        ...

MediaTypesInterceptor = Callable[[MediaTypesChainedRequest], MediaTypesOperationResponses]

def media_types_handler(_handler: MediaTypesHandlerFunction = None, interceptors: List[MediaTypesInterceptor] = []):
    """
    Decorator for an api handler for the media_types operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: MediaTypesHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = MediaTypesRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            # Primitive type so body is passed as the original string
            body = event['body']
            interceptor_context = {
                "operationId": "media_types",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by media_types_handler.")

class MultipleContentTypesRequestParameters(BaseModel):
    """
    Query, path and header parameters for the MultipleContentTypes operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> MultipleContentTypesRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> MultipleContentTypesRequestParameters:
        if obj is None:
            return None
        return MultipleContentTypesRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
MultipleContentTypesRequestBody = TestRequest

MultipleContentTypes200OperationResponse = ApiResponse[Literal[200], str]

MultipleContentTypesOperationResponses = Union[MultipleContentTypes200OperationResponse, ]

# Request type for multiple_content_types
MultipleContentTypesRequest = ApiRequest[MultipleContentTypesRequestParameters, MultipleContentTypesRequestBody]
MultipleContentTypesChainedRequest = ChainedApiRequest[MultipleContentTypesRequestParameters, MultipleContentTypesRequestBody]

class MultipleContentTypesHandlerFunction(Protocol):
    def __call__(self, input: MultipleContentTypesRequest, **kwargs) -> MultipleContentTypesOperationResponses:
        ...

MultipleContentTypesInterceptor = Callable[[MultipleContentTypesChainedRequest], MultipleContentTypesOperationResponses]

def multiple_content_types_handler(_handler: MultipleContentTypesHandlerFunction = None, interceptors: List[MultipleContentTypesInterceptor] = []):
    """
    Decorator for an api handler for the multiple_content_types operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: MultipleContentTypesHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = MultipleContentTypesRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            # Non-primitive type so parse the body into the appropriate model
            body = parse_body(event['body'], ['application/json','application/pdf'], MultipleContentTypesRequestBody)
            interceptor_context = {
                "operationId": "multiple_content_types",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by multiple_content_types_handler.")

class OperationOneRequestParameters(BaseModel):
    """
    Query, path and header parameters for the OperationOne operation
    """
    param1: StrictStr
    param2: List[StrictStr]
    param3: Union[StrictFloat, StrictInt]
    path_param: StrictStr
    x_header_param: StrictStr
    param4: Optional[StrictStr]
    x_multi_value_header_param: Optional[List[StrictStr]]

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> OperationOneRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> OperationOneRequestParameters:
        if obj is None:
            return None
        return OperationOneRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
OperationOneRequestBody = TestRequest

OperationOne200OperationResponse = ApiResponse[Literal[200], TestResponse]
OperationOne400OperationResponse = ApiResponse[Literal[400], ApiError]

OperationOneOperationResponses = Union[OperationOne200OperationResponse, OperationOne400OperationResponse, ]

# Request type for operation_one
OperationOneRequest = ApiRequest[OperationOneRequestParameters, OperationOneRequestBody]
OperationOneChainedRequest = ChainedApiRequest[OperationOneRequestParameters, OperationOneRequestBody]

class OperationOneHandlerFunction(Protocol):
    def __call__(self, input: OperationOneRequest, **kwargs) -> OperationOneOperationResponses:
        ...

OperationOneInterceptor = Callable[[OperationOneChainedRequest], OperationOneOperationResponses]

def operation_one_handler(_handler: OperationOneHandlerFunction = None, interceptors: List[OperationOneInterceptor] = []):
    """
    Decorator for an api handler for the operation_one operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: OperationOneHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                if status_code == 400 and "ApiError".endswith("ResponseContent"):
                    headers_for_status["x-amzn-errortype"] = "ApiError"[:-len("ResponseContent")]
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = OperationOneRequestParameters.from_dict({
                    "param1": coerce_parameter("param1", "str", raw_string_parameters, raw_string_array_parameters, True),
                    "param2": coerce_parameter("param2", "List[str]", raw_string_parameters, raw_string_array_parameters, True),
                    "param3": coerce_parameter("param3", "float", raw_string_parameters, raw_string_array_parameters, True),
                    "path_param": coerce_parameter("pathParam", "str", raw_string_parameters, raw_string_array_parameters, True),
                    "x_header_param": coerce_parameter("x-header-param", "str", raw_string_parameters, raw_string_array_parameters, True),
                    "param4": coerce_parameter("param4", "str", raw_string_parameters, raw_string_array_parameters, False),
                    "x_multi_value_header_param": coerce_parameter("x-multi-value-header-param", "List[str]", raw_string_parameters, raw_string_array_parameters, False),
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            # Non-primitive type so parse the body into the appropriate model
            body = parse_body(event['body'], ['application/json'], OperationOneRequestBody)
            interceptor_context = {
                "operationId": "operation_one",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()
            elif response.status_code == 400:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by operation_one_handler.")

class WithoutOperationIdDeleteRequestParameters(BaseModel):
    """
    Query, path and header parameters for the WithoutOperationIdDelete operation
    """

    class Config:
        """Pydantic configuration"""
        populate_by_name = True
        validate_assignment = True

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> WithoutOperationIdDeleteRequestParameters:
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        return self.model_dump(exclude={}, exclude_none=True)

    @classmethod
    def from_dict(cls, obj: dict) -> WithoutOperationIdDeleteRequestParameters:
        if obj is None:
            return None
        return WithoutOperationIdDeleteRequestParameters.model_validate(obj)


# Request body type (default to Any when no body parameters exist, or leave unchanged as str if it's a primitive type)
WithoutOperationIdDeleteRequestBody = Any

WithoutOperationIdDelete200OperationResponse = ApiResponse[Literal[200], TestResponse]

WithoutOperationIdDeleteOperationResponses = Union[WithoutOperationIdDelete200OperationResponse, ]

# Request type for without_operation_id_delete
WithoutOperationIdDeleteRequest = ApiRequest[WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestBody]
WithoutOperationIdDeleteChainedRequest = ChainedApiRequest[WithoutOperationIdDeleteRequestParameters, WithoutOperationIdDeleteRequestBody]

class WithoutOperationIdDeleteHandlerFunction(Protocol):
    def __call__(self, input: WithoutOperationIdDeleteRequest, **kwargs) -> WithoutOperationIdDeleteOperationResponses:
        ...

WithoutOperationIdDeleteInterceptor = Callable[[WithoutOperationIdDeleteChainedRequest], WithoutOperationIdDeleteOperationResponses]

def without_operation_id_delete_handler(_handler: WithoutOperationIdDeleteHandlerFunction = None, interceptors: List[WithoutOperationIdDeleteInterceptor] = []):
    """
    Decorator for an api handler for the without_operation_id_delete operation, providing a typed interface for inputs and outputs
    """
    def _handler_wrapper(handler: WithoutOperationIdDeleteHandlerFunction):
        @wraps(handler)
        def wrapper(event, context, additional_interceptors = [], **kwargs):
            all_interceptors = additional_interceptors + interceptors

            raw_string_parameters = decode_request_parameters({
                **(event.get('pathParameters', {}) or {}),
                **(event.get('queryStringParameters', {}) or {}),
                **(event.get('headers', {}) or {}),
            })
            raw_string_array_parameters = decode_request_parameters({
                **(event.get('multiValueQueryStringParameters', {}) or {}),
                **(event.get('multiValueHeaders', {}) or {}),
            })

            def response_headers_for_status_code(status_code):
                headers_for_status = {}
                return headers_for_status

            request_parameters = None
            try:
                request_parameters = WithoutOperationIdDeleteRequestParameters.from_dict({
                })
            except Exception as e:
                return {
                    'statusCode': 400,
                    'headers': {**response_headers_for_status_code(400), **extract_response_headers_from_interceptors(all_interceptors)},
                    'body': '{"message": "' + str(e) + '"}',
                }

            body = {}
            interceptor_context = {
                "operationId": "without_operation_id_delete",
            }

            chain = _build_handler_chain(all_interceptors, handler)
            response = chain.next(ApiRequest(
                request_parameters,
                body,
                event,
                context,
                interceptor_context,
            ), **kwargs)

            response_headers = {** (response.headers or {}), **response_headers_for_status_code(response.status_code)}
            response_body = ''
            if response.body is None:
                pass
            elif response.status_code == 200:
                response_body = response.body.to_json()

            return {
                'statusCode': response.status_code,
                'headers': response_headers,
                'multiValueHeaders': response.multi_value_headers or {},
                'body': response_body,
            }
        return wrapper

    # Support use as a decorator with no arguments, or with interceptor arguments
    if callable(_handler):
        return _handler_wrapper(_handler)
    elif _handler is None:
        return _handler_wrapper
    else:
        raise Exception("Positional arguments are not supported by without_operation_id_delete_handler.")

Interceptor = Callable[[ChainedApiRequest[RequestParameters, RequestBody]], ApiResponse[StatusCode, ResponseBody]]

def concat_method_and_path(method: str, path: str):
    return "{}||{}".format(method.lower(), path)

OperationIdByMethodAndPath = { concat_method_and_path(method_and_path["method"], method_and_path["path"]): operation for operation, method_and_path in OperationLookup.items() }

@dataclass
class HandlerRouterHandlers:
  any_request_response: Callable[[Dict, Any], Dict]
  empty: Callable[[Dict, Any], Dict]
  map_response: Callable[[Dict, Any], Dict]
  media_types: Callable[[Dict, Any], Dict]
  multiple_content_types: Callable[[Dict, Any], Dict]
  operation_one: Callable[[Dict, Any], Dict]
  without_operation_id_delete: Callable[[Dict, Any], Dict]

def handler_router(handlers: HandlerRouterHandlers, interceptors: List[Interceptor] = []):
    """
    Returns a lambda handler which can be used to route requests to the appropriate typed lambda handler function.
    """
    _handlers = { field.name: getattr(handlers, field.name) for field in fields(handlers) }

    def handler_wrapper(event, context):
        operation_id = OperationIdByMethodAndPath[concat_method_and_path(event['requestContext']['httpMethod'], event['requestContext']['resourcePath'])]
        handler = _handlers[operation_id]
        return handler(event, context, additional_interceptors=interceptors)
    return handler_wrapper
",
  "test_project/api_client.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import atexit
import datetime
from dateutil.parser import parse
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List

from test_project.configuration import Configuration
from test_project.api_response import ApiResponse
import test_project.models
from test_project import rest
from test_project.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)


class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> Tuple:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for \`multipart/form-data\`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for \`application/x-www-form-urlencoded\`, \`multipart/form-data\`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data=None,
        response_types_map=None
    ) -> ApiResponse:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """


        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        if not 200 <= response_data.status <= 299:
            if response_data.status == 400:
                raise BadRequestException(http_resp=response_data)

            if response_data.status == 401:
                raise UnauthorizedException(http_resp=response_data)

            if response_data.status == 403:
                raise ForbiddenException(http_resp=response_data)

            if response_data.status == 404:
                raise NotFoundException(http_resp=response_data)

            if 500 <= response_data.status <= 599:
                raise ServiceException(http_resp=response_data)
            raise ApiException(http_resp=response_data)

        # deserialize response data

        if response_type == "bytearray":
            return_data = response_data.data
        elif response_type is None:
            return_data = None
        elif response_type == "file":
            return_data = self.__deserialize_file(response_data)
        else:
            match = None
            content_type = response_data.getheader('content-type')
            if content_type is not None:
                match = re.search(r"charset=([a-zA-Z\\-\\d]+)[\\s;]?", content_type)
            encoding = match.group(1) if match else "utf-8"
            response_text = response_data.data.decode(encoding)
            return_data = self.deserialize(response_text, response_type)

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes \`openapi_types\`, \`attribute_map\`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """

        # fetch data from response object
        try:
            data = json.loads(response_text)
        except ValueError:
            data = response_text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(test_project.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (
                            mimetypes.guess_type(filename)[0]
                            or 'application/octet-stream'
                        )
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])])
                        )

        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns \`Accept\` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns \`Content-Type\` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in \`query\` or \`header\`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the \`Content-Disposition\` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(
                r'filename=[\\'"]?([^\\'"\\s]+)[\\'"]?',
                content_disposition
            ).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse \`{0}\` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse \`{0}\` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
",
  "test_project/api_response.py": """"API response object."""

from __future__ import annotations
from typing import Any, Dict, Optional, Generic, TypeVar
from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }
",
  "test_project/configuration.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
import sys
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.

    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ssl_ca_cert=None,
                 ) -> None:
        """Constructor
        """
        self._base_path = "http://localhost" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("test_project")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """


        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use \`get_default\` instead.

        Deprecated. Please use \`get_default\` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default \`logging.WARNING\`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\\n"\\
               "OS: {env}\\n"\\
               "Python Version: {pyversion}\\n"\\
               "Version of the API: 1.0.0\\n"\\
               "SDK Package Version: 1.0.0".\\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \\
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable \`{0}\` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None
",
  "test_project/exceptions.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        if http_resp:
            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data.decode('utf-8')
            self.headers = http_resp.getheaders()
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\\n"\\
                        "Reason: {1}\\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\\n".format(
                self.headers)

        if self.body:
            error_message += "HTTP response body: {0}\\n".format(self.body)

        return error_message

class BadRequestException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(BadRequestException, self).__init__(status, reason, http_resp)

class NotFoundException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(NotFoundException, self).__init__(status, reason, http_resp)


class UnauthorizedException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(UnauthorizedException, self).__init__(status, reason, http_resp)


class ForbiddenException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ForbiddenException, self).__init__(status, reason, http_resp)


class ServiceException(ApiException):

    def __init__(self, status=None, reason=None, http_resp=None) -> None:
        super(ServiceException, self).__init__(status, reason, http_resp)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
",
  "test_project/interceptors/__init__.py": "from test_project.interceptors.response_headers import cors_interceptor
from test_project.interceptors.try_catch import try_catch_interceptor
from test_project.interceptors.powertools.logger import LoggingInterceptor
from test_project.interceptors.powertools.tracer import TracingInterceptor
from test_project.interceptors.powertools.metrics import MetricsInterceptor

# All default interceptors, for logging, tracing, metrics, cors headers and error handling
INTERCEPTORS = [
    cors_interceptor,
    LoggingInterceptor().intercept,
    try_catch_interceptor,
    TracingInterceptor().intercept,
    MetricsInterceptor().intercept,
]
",
  "test_project/interceptors/powertools/logger.py": "from aws_lambda_powertools import Logger
from aws_lambda_powertools.logging.logger import _is_cold_start
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

logger = Logger()

class LoggingInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools logger to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/logger/
        """
        request.interceptor_context["logger"] = logger

        # Add the operation id, lambda context and cold start
        logger.append_keys(
            operationId=request.interceptor_context["operationId"],
            **request.context.__dict__,
            cold_start=_is_cold_start()
        )
        response = request.chain.next(request)
        logger.remove_keys(["operationId"])

        return response

    @staticmethod
    def get_logger(request: ChainedApiRequest) -> Logger:
        if request.interceptor_context.get("logger") is None:
            raise Exception("No logger found. Did you configure the LoggingInterceptor?")
        return request.interceptor_context["logger"]
",
  "test_project/interceptors/powertools/metrics.py": "from aws_lambda_powertools import Metrics
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

metrics = Metrics()

class MetricsInterceptor:

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools metrics instance to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/metrics/
        """
        operation_id = request.interceptor_context["operationId"]

        # Set the namespace if not set via environment variables
        if metrics.namespace is None:
            metrics.namespace = operation_id

        request.interceptor_context["metrics"] = metrics

        try:
            metrics.add_dimension(name="operationId", value=operation_id)
            return request.chain.next(request)
        finally:
            metrics.flush_metrics()

    @staticmethod
    def get_metrics(request: ChainedApiRequest) -> Metrics:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("metrics") is None:
            raise Exception("No metrics found. Did you configure the MetricsInterceptor?")
        return request.interceptor_context["metrics"]
",
  "test_project/interceptors/powertools/tracer.py": "from aws_lambda_powertools import Tracer
from test_project.api.operation_config import ApiResponse, ChainedApiRequest

tracer = Tracer()
is_cold_start = True

class TracingInterceptor:
    def __init__(self, add_response_as_metadata: bool = False):
        self._add_response_as_metadata = add_response_as_metadata

    def intercept(self, request: ChainedApiRequest) -> ApiResponse:
        """
        An interceptor for adding an aws powertools tracer to the interceptor context
        See: https://docs.powertools.aws.dev/lambda/python/latest/core/tracer/
        """
        request.interceptor_context["tracer"] = tracer

        operation_id = request.interceptor_context["operationId"]

        with tracer.provider.in_subsegment(name=f"## {operation_id}") as subsegment:
            try:
                result = request.chain.next(request)
                tracer._add_response_as_metadata(
                    method_name=operation_id,
                    data=result,
                    subsegment=subsegment,
                    capture_response=self._add_response_as_metadata
                )
                return result
            except Exception as e:
                tracer._add_full_exception_as_metadata(
                    method_name=operation_id,
                    error=e,
                    subsegment=subsegment,
                    capture_error=True
                )
                raise
            finally:
                global is_cold_start
                subsegment.put_annotation(key="ColdStart", value=is_cold_start)
                is_cold_start = False

    @staticmethod
    def get_tracer(request: ChainedApiRequest) -> Tracer:
        """
        Retrieve the metrics logger from the request
        """
        if request.interceptor_context.get("tracer") is None:
            raise Exception("No tracer found. Did you configure the TracingInterceptor?")
        return request.interceptor_context["tracer"]
",
  "test_project/interceptors/response_headers.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from typing import Dict

CORS_HEADERS = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "*",
}

def build_response_headers_interceptor(headers: Dict[str, str]):
    """
    Build an interceptor for adding headers to the response.
    """
    def response_headers_interceptor(request: ChainedApiRequest) -> ApiResponse:
        result = request.chain.next(request)
        result.headers = { **headers, **(result.headers or {}) }
        return result

    # Any error responses returned during request validation will include the headers
    response_headers_interceptor.__type_safe_api_response_headers = headers

    return response_headers_interceptor

# Cors interceptor allows all origins and headers. Use build_response_headers_interceptors to customise
cors_interceptor = build_response_headers_interceptor(CORS_HEADERS)

",
  "test_project/interceptors/try_catch.py": "from test_project.api.operation_config import ApiResponse, ChainedApiRequest
from test_project.response import Response


def try_catch_interceptor(request: ChainedApiRequest) -> ApiResponse:
    """
    Interceptor for catching unhandled exceptions and returning a 500 error.
    Uncaught exceptions which are ApiResponses will be returned, such that deeply nested code may return error
    responses, eg: \`throw Response.not_found(...)\`
    """
    try:
        return request.chain.next(request)
    except ApiResponse as response:
        # If the error is a response, return it as the response
        return response
    except Exception as e:
        if request.interceptor_context.get("logger") is not None:
            request.interceptor_context.get("logger").exception("Interceptor caught exception")
        else:
            print("Interceptor caught exception")
            print(e)

        return Response.internal_failure({ "message": "Internal Error" })
",
  "test_project/models/__init__.py": "# coding: utf-8

# flake8: noqa
"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

# import models into model package
from test_project.models.api_error import ApiError
from test_project.models.map_response import MapResponse
from test_project.models.map_response_map_property_value import MapResponseMapPropertyValue
from test_project.models.test_request import TestRequest
from test_project.models.test_response import TestResponse
from test_project.models.test_response_messages_inner import TestResponseMessagesInner
",
  "test_project/models/api_error.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ApiError(BaseModel):
    """
    ApiError
    """ # noqa: E501
    error_message: StrictStr = Field(alias="errorMessage")
    __properties: ClassVar[List[str]] = ["errorMessage"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ApiError from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ApiError from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "errorMessage": obj.get("errorMessage")
        })
        return _obj

",
  "test_project/models/map_response.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.map_response_map_property_value import MapResponseMapPropertyValue
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class MapResponse(BaseModel):
    """
    MapResponse
    """ # noqa: E501
    map_property: Dict[str, MapResponseMapPropertyValue] = Field(alias="mapProperty")
    __properties: ClassVar[List[str]] = ["mapProperty"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of MapResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of each value in map_property (dict)
        _field_dict = {}
        if self.map_property:
            for _key in self.map_property:
                if self.map_property[_key]:
                    _field_dict[_key] = self.map_property[_key].to_dict()
            _dict['mapProperty'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of MapResponse from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "mapProperty": dict(
                (_k, MapResponseMapPropertyValue.from_dict(_v))
                for _k, _v in obj.get("mapProperty").items()
            )
            if obj.get("mapProperty") is not None
            else None
        })
        return _obj

",
  "test_project/models/map_response_map_property_value.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class MapResponseMapPropertyValue(BaseModel):
    """
    MapResponseMapPropertyValue
    """ # noqa: E501
    a: StrictStr
    b: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["a", "b"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of MapResponseMapPropertyValue from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of MapResponseMapPropertyValue from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "a": obj.get("a"),
            "b": obj.get("b")
        })
        return _obj

",
  "test_project/models/test_request.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class TestRequest(BaseModel):
    """
    This is a test request
    """ # noqa: E501
    my_input: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="myInput")
    __properties: ClassVar[List[str]] = ["myInput"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TestRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of TestRequest from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "myInput": obj.get("myInput")
        })
        return _obj

",
  "test_project/models/test_response.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
from test_project.models.test_response_messages_inner import TestResponseMessagesInner
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class TestResponse(BaseModel):
    """
    This is a test response
    """ # noqa: E501
    messages: List[TestResponseMessagesInner]
    __properties: ClassVar[List[str]] = ["messages"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TestResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling \`to_dict()\` of each item in messages (list)
        _items = []
        if self.messages:
            for _item in self.messages:
                if _item:
                    _items.append(_item.to_dict())
            _dict['messages'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of TestResponse from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "messages": [TestResponseMessagesInner.from_dict(_item) for _item in obj.get("messages")] if obj.get("messages") is not None else None
        })
        return _obj

",
  "test_project/models/test_response_messages_inner.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from enum import Enum
from datetime import date, datetime
from typing import Any, List, Union, ClassVar, Dict, Optional, TYPE_CHECKING
from pydantic import Field, StrictStr, ValidationError, field_validator, BaseModel, SecretStr, StrictFloat, StrictInt, StrictBytes, StrictBool
from decimal import Decimal
from typing_extensions import Annotated, Literal
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class TestResponseMessagesInner(BaseModel):
    """
    TestResponseMessagesInner
    """ # noqa: E501
    message: Optional[StrictStr] = Field(default=None, description="This is a message")
    id: StrictInt
    __properties: ClassVar[List[str]] = ["message", "id"]


    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TestResponseMessagesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        \`self.model_dump(by_alias=True)\`:

        * \`None\` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value \`None\`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of TestResponseMessagesInner from a dict"""

        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "message": obj.get("message"),
            "id": obj.get("id")
        })
        return _obj

",
  "test_project/py.typed": "",
  "test_project/response.py": "from typing import TypeVar, Generic, Dict, List
from test_project.api.operation_config import ApiResponse

ResponseBody = TypeVar("ResponseBody")

class Response(Generic[ResponseBody]):
  """
  Helpers for constructing api responses
  """

  @staticmethod
  def success(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[200, ResponseBody]:
    """
    A successful response
    """
    return ApiResponse(status_code=200, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def bad_request(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[400, ResponseBody]:
    """
    A response which indicates a client error
    """
    return ApiResponse(status_code=400, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_found(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[404, ResponseBody]:
    """
    A response which indicates the requested resource was not found
    """
    return ApiResponse(status_code=404, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def not_authorized(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[403, ResponseBody]:
    """
    A response which indicates the caller is not authorised to perform the operation or access the resource
    """
    return ApiResponse(status_code=403, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})

  @staticmethod
  def internal_failure(body: ResponseBody, headers: Dict[str, str] = {}, multi_value_headers: Dict[str, List[str]] = {}) -> ApiResponse[500, ResponseBody]:
    """
    A response to indicate a server error
    """
    return ApiResponse(status_code=500, body=body, headers={**headers}, multi_value_headers={**multi_value_headers})
",
  "test_project/rest.py": "# coding: utf-8

"""
    Example API

    No description provided

    The version of the OpenAPI document: 1.0.0

    NOTE: This class is auto generated.
    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl

import urllib3

from test_project.exceptions import ApiException, ApiValueError

RESTResponseType = urllib3.HTTPResponse

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries

        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name


        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options

        # https pool manager
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                proxy_url=configuration.proxy,
                proxy_headers=configuration.proxy_headers,
                **addition_pool_args
            )
        else:
            self.pool_manager = urllib3.PoolManager(
                cert_reqs=cert_reqs,
                ca_certs=configuration.ssl_ca_cert,
                cert_file=configuration.cert_file,
                key_file=configuration.key_file,
                **addition_pool_args
            )

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for \`application/json\`
        :param post_params: request post parameters,
                            \`application/x-www-form-urlencoded\`
                            and \`multipart/form-data\`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For \`POST\`, \`PUT\`, \`PATCH\`, \`OPTIONS\`, \`DELETE\`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                # no content type provided or payload is json
                content_type = headers.get('Content-Type')
                if (
                    not content_type
                    or re.search('json', content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a \`string\` parameter directly in the body to support
                # other content types than Json when \`body\` argument is
                # provided in serialized form
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For \`GET\`, \`HEAD\`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = "\\n".join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)
",
}
`;
