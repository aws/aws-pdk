###TSAPI_SPLIT_FILE###
{{#apiInfo ~}}
{{#apis ~}}
{{#operations ~}}
{{#operation ~}}
{{#if vendorExtensions.x-handler}}
{{#startsWith vendorExtensions.x-handler.language 'java'}}
###TSAPI_WRITE_FILE###
{
  "dir": ".",
  "name": "{{operationIdCamelCase}}Handler",
  "ext": ".java",
  "overwrite": false
}
###/TSAPI_WRITE_FILE###package {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-handlers-package}}{{/apis.0}}{{/apiInfo}};

import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.interceptors.DefaultInterceptors;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.interceptors.powertools.LoggingInterceptor;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.Interceptor;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.{{operationIdSnakeCase}}.{{operationIdCamelCase}};
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.{{operationIdSnakeCase}}.{{operationIdCamelCase}}Input;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.{{operationIdSnakeCase}}.{{operationIdCamelCase}}500Response;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.{{operationIdSnakeCase}}.{{operationIdCamelCase}}RequestInput;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.api.handlers.{{operationIdSnakeCase}}.{{operationIdCamelCase}}Response;
import {{#apiInfo}}{{#apis.0}}{{vendorExtensions.x-runtime-package}}{{/apis.0}}{{/apiInfo}}.model.*;

import java.util.List;

/**
 * Entry point for the AWS Lambda handler for the {{operationIdCamelCase}} operation.
 * The {{operationIdCamelCase}} class manages marshalling inputs and outputs.
 */
public class {{operationIdCamelCase}}Handler extends {{operationIdCamelCase}} {
    /**
     * Interceptors are initialised once during the lambda "init" phase
     */
    private final List<Interceptor<{{operationIdCamelCase}}Input>> interceptors = DefaultInterceptors.all();

    /**
     * Return the interceptors for this handler.
     * You can also use the @Interceptors annotation on the class to add interceptors
     */
    @Override
    public List<Interceptor<{{operationIdCamelCase}}Input>> getInterceptors() {
        return this.interceptors;
    }

    /**
     * Type-safe handler for the {{operationIdCamelCase}} operation
     */
    @Override
    public {{operationIdCamelCase}}Response handle(final {{operationIdCamelCase}}RequestInput request) {
        LoggingInterceptor.getLogger(request).info("Start {{operationIdCamelCase}} Operation");

        // TODO: Implement {{operationIdCamelCase}} Operation. `input` contains the request input.
        {{operationIdCamelCase}}Input input = request.getInput();

        return {{operationIdCamelCase}}500Response.of(InternalFailureErrorResponseContent.builder()
                .message("Not Implemented!")
                .build());
    }
}

{{~/startsWith}}
{{~/if}}
{{~/operation}}
{{~/operations}}
{{~/apis}}
{{~/apiInfo}}